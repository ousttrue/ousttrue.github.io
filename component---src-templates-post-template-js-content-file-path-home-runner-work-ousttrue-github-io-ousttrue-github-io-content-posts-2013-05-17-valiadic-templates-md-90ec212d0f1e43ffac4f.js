"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[273],{7959:function(e,n,t){t.r(n),t.d(n,{default:function(){return d}});var r=t(1151),c=t(7294);function a(e){const n=Object.assign({p:"p",pre:"pre",code:"code"},(0,r.ah)(),e.components);return c.createElement(c.Fragment,null,c.createElement(n.p,null,"可変長テンプレート引数\n引き続きmsgpack-rpc-asioを実装しているのだが、可変長テンプレート引数(valiadic\ntemplate)を使うと関数登録のような場合にうまく書けることがわかった。\n昨日は関数オブジェクトからstd::functionの型を得るのに下記のようにしていたのだけど、"),"\n",c.createElement(n.pre,null,c.createElement(n.code,{className:"language-c++"},"template Ret helper0(Ret (F::*)(Rest…) const);\n// 1 template A1 helper1(Ret (F::*)(A1, Rest…));\ntemplate A1 helper1(Ret (F::*)(A1, Rest…) const);\n// 2 template A2 helper2(Ret (F::*)(A1, A2, Rest…));\ntemplate A2 helper2(Ret (F::*)(A1, A2, Rest…) const);\ntemplate void add_handler(F handler, const std::string &method) {\ntypedef decltype(handler) functor; typedef\ndecltype(helper0(&functor::operator())) R; typedef\ndecltype(helper1(&functor::operator())) A1; typedef\ndecltype(helper2(&functor::operator())) A2;\n// register function...\nstd::function<R(A1, A2)> func(handler);\n\n} 次のように書けた。c++ template void add_handler(F handler,\nR(C::*)(A1, A2)const) { // register function… std::function\nfunc(handler); }\ntemplate void add_handler(F handler, const std::string &method) {\nadd_handler(handler, &decltype(handler)::operator()); }\n昨日参照させてもらった\nhttp://d.hatena.ne.jp/osyo-manga/20121205/1354674180\nのコードがやっとわかるようになってきた。\n\n上記コードはさらに可変長テンプレート引数で\n\ntemplate void add_handler(F handler, R(C::*)(A…)const) { // register\nfunction… std::function func(handler); }\n``と書けるのですごく便利になる。 msgpack-rpcの関数コールバック登録や、luaのような組み込み言語への関数公開の実装が楽になりそうだ。 上記サイトでも取り上げられているが&decltype(functor)::operator()`を関数テンプレートの型推論に投げることで\n関数オブジェクトから型情報を取れるらしい。\n気をよくして各所を可変長テンプレート引数を使うように書き換えたのだが、\n致命的な問題を発見。\nvc2010はなんと可変長テンプレート引数を未実装だった。\nc++0xの機能がわりと入っているのでできると思っていたのに。\nmsgpack-rpc-asioは、明瞭にvc2010をターゲットにしているので可変長テンプレート引数の使用を断念した。\n２引数関数の操作までしか実装していない時点で気付いて良かった。\nライブラリの不足はboost使えば済むが言語機能が無いのは困るな・・・。\nvc2012に乗り換えたくなった。\n")))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?c.createElement(n,e,c.createElement(a,e)):a(e)};t(8678);function l(e){let{data:n,children:t}=e;return c.createElement(c.Fragment,null,c.createElement("h1",null,n.mdx.frontmatter.title),c.createElement(r.Zo,null,t))}function d(e){return c.createElement(l,e,c.createElement(o,e))}},8678:function(e,n,t){t(7294)},1151:function(e,n,t){t.d(n,{Zo:function(){return l},ah:function(){return a}});var r=t(7294);const c=r.createContext({});function a(e){const n=r.useContext(c);return r.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const o={};function l({components:e,children:n,disableParentContext:t}){let l;return l=t?"function"==typeof e?e({}):e||o:a(e),r.createElement(c.Provider,{value:l},n)}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2013-05-17-valiadic-templates-md-90ec212d0f1e43ffac4f.js.map