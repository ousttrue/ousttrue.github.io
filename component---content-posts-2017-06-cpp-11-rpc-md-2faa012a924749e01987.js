"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[330],{1904:function(e,n,a){a.r(n);var t=a(1151),l=a(7294);function r(e){const n=Object.assign({p:"p",h1:"h1",pre:"pre",code:"code"},(0,t.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.p,null,"最近のC++(-std=c++14)でMessagePack-RPCを再実装してみる。"),"\n",l.createElement(n.h1,null,"基本設計"),"\n",l.createElement(n.p,null,"MessagePack-RPCの仕様をおさらいすると以下の通り。"),"\n",l.createElement(n.p,null,"request"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"[type, msgid, method, params]\n (0)   (int)  (str)   (array)\n")),"\n",l.createElement(n.p,null,"response"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"[type, msgid, error, result]\n (1)   (int)  (any)  (any)\n")),"\n",l.createElement(n.p,null,"msgpackのバイト列を受け取って、msgpackのバイト列を返す関数として一般化する。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"typedef std::vector<std::uint8_t> bytes;\n// msgpackのバイト列を引数にとり、msgpackのバイト列を返す\ntypedef std::function<bytes(const &bytes)> procedurecall;\n")),"\n",l.createElement(n.p,null,"任意の関数呼び出しからprocedurecallを作り出せるようにして、MessagePack-RPCシステムの部品として使えるようにする。\n簡単な例\n例として"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"static int add(int a, int b){ return a+b; }\n")),"\n",l.createElement(n.p,null,"をprocedurecallに変換してみる。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"procedurecall make_procedurecall(int(*f)(int, int))\n{\n    // request -> response ではなくparams -> result\n    return [f](const bytes& src)->bytes\n    {\n        // unpack args\n        auto parser = msgpackpp::parser(src);\n        std::tuple<int, int> args;\n        parser >> args;\n\n        // call\n        auto r = f(std::get<0>(args), std::get<1>(args));\n\n        // pack result\n        msgpackpp::packer packer;\n        packer << r;\n        return packer.get_payload();\n    };\n}\n")),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"int add(int, int)")," を ",l.createElement(n.code,null,"procedurecall")," に変換するというのは、引数のアンパック、関数呼び出し、結果のパックという一連の定型コードの呼び出しになる。"),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"procedurecall")," の使い方は以下の通り。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"// register\nauto proc = msgpackpp::rpc::make_procedurecall(&add);\n\n// call\nauto packer = msgpackpp::packer();\npacker << std::make_tuple(1, 2);\nauto result = proc(packer.get_payload());\n\n// result\nREQUIRE(3 == msgpackpp::parser(result).get_number<int>());\n")),"\n",l.createElement(n.p,null,"とりあえず動いたが、関数を増やすたびにこれだけのコードを記述するのはやってられませぬ。\n以下のような理想形を目指して作りこんでゆく。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"REQUIRE(3 == msgpack_procedurecall([](int a, int b){ return a+b; }, 1, 2));\n")),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"lambda")," が動けば他も動くようにできるので、",l.createElement(n.code,null,"lambda")," を第一に実装する。"),"\n",l.createElement(n.h1,null,"実装"),"\n",l.createElement(n.p,null,"ステップ毎に説明しようと思っていたが分かりにくいので、コードにコメントを追加することにした。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"make_procedurecall\ntemplate<typename F, typename R, typename C, typename ...AS, std::size_t... IS>\nprocedurecall _make_procedurecall(const F &f\n    , R(C::*)(AS...)const // template引数R, C, ASを受け付けるためのダミー\n    , std::index_sequence<IS...> // template引数ISを受け付けるためのダミー\n)\n{\n    // request -> response ではなくparams -> result\n    return [f](const bytes& src)->bytes\n    {\n        // unpack args\n        auto parser = msgpackpp::parser(src);\n        std::tuple<AS...> args;\n        parser >> args;\n\n        // call\n        auto r = f(std::get<IS>(args)...); // 可変長テンプレート引数を展開できる。ISと...が離れていることに注意\n\n        // pack result\n        msgpackpp::packer packer;\n        packer << r;\n        return packer.get_payload();\n    };\n}\n\ntemplate<typename F, typename R, typename C, typename ...AS>\nprocedurecall _make_procedurecall(F f\n    , R(C::*)(AS...)const // template引数R, C, ASを受け付けるためのダミー\n)\n{\n    return _make_procedurecall(f\n        , &decltype(f)::operator() // lambdaの返り値と引数の型を次のテンプレートに渡す\n        , std::index_sequence_for<AS...>{} // std::get呼び出しのためにindex_sequenceを作る。\n    );\n}\n\n//\n// あらゆる型のlambdaを受け付けるようにした\n//\ntemplate<typename F>\nprocedurecall make_procedurecall(F f)\n{\n    return _make_procedurecall(f\n        , &decltype(f)::operator() // lambdaの返り値と引数の型を次のテンプレートに渡す\n    );\n}\n\nmsgpack_call\ntemplate<typename F, typename R, typename C, typename ...AS>\ndecltype(auto) _msgpack_call(F f\n    , R(C::*)(AS...)const // template引数R, C, ASを受けるためのダミー\n    , AS... args)\n{\n    auto proc = msgpackpp::rpc::make_procedurecall(f);\n\n    // call\n    msgpackpp::packer packer;\n    packer << std::make_tuple(args...); // 可変長テンプレート引数を展開できる\n    auto result = proc(packer.get_payload());\n\n    // unpack result\n    R value;\n    msgpackpp::parser(result) >> value;\n    return value;\n}\n\ntemplate<typename F, typename ...AS>\ndecltype(auto) msgpack_call(F f, AS... args) // 返り値の型はreturnから型推論\n{\n    return _msgpack_call(f\n    , &decltype(f)::operator() // lambdaの返り値と引数の型をテンプレート引数に渡す\n    , args...\n    );\n}\n")),"\n",l.createElement(n.h1,null,"使う。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"REQUIRE(3==msgpack_call([](int a, int b) { return a + b; }, 1, 2));\nREQUIRE(-1==msgpack_call([](int a, int b) { return a - b; }, 1, 2));\n")),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"valiadic template")," おそるべし。\n従来であれば、1引数、２引数・・・と引数の個数ごとに手作業でバージョンを増やさねばならなかったものが、わりとさくっと書けるな。"))}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?l.createElement(n,e,l.createElement(r,e)):r(e)}},1151:function(e,n,a){a.d(n,{ah:function(){return r}});var t=a(7294);const l=t.createContext({});function r(e){const n=t.useContext(l);return t.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);
//# sourceMappingURL=component---content-posts-2017-06-cpp-11-rpc-md-2faa012a924749e01987.js.map