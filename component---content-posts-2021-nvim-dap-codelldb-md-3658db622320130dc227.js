"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2756],{5335:function(e,n,t){t.r(n);var l=t(1151),a=t(7294);function r(e){const n=Object.assign({p:"p",a:"a",code:"code",ul:"ul",li:"li",h2:"h2",pre:"pre"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.p,null,a.createElement(n.a,{href:"https://github.com/mfussenegger/nvim-dap"},"nvim-dap")," ã§ rust ã‚’ãƒ‡ãƒãƒƒã‚°ã™ã‚‹ã¹ãæ‚ªæˆ¦è‹¦é—˜ä¸­ã€‚\nnvim-dap ã¨ã„ã†ã®ã¯ã€æ¥ãŸã‚‹ nvim-0.5 ã§å‹•ãã‚ˆã†ã«ãªã‚‹ã€ ",a.createElement(n.code,null,"vscode")," ã®ãƒ‡ãƒãƒƒã‚°ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã‚’å‹•ä½œã•ã›ã‚‹æ©Ÿèƒ½ã€‚"),"\n",a.createElement(n.p,null,"rust(Windows) ã¯ native debugger ã‚’ã‚¢ã‚¿ãƒƒãƒã™ã‚Œã°ã„ã„ã®ã§ã€ã„ãã¤ã‹é¸æŠžè‚¢ãŒã‚ã£ã¦"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools"),"\n",a.createElement(n.li,null,"https://marketplace.visualstudio.com/items?itemName=lanza.lldb-vscode"),"\n",a.createElement(n.li,null,"https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb"),"\n"),"\n",a.createElement(n.p,null,"æœ€å¾Œã®ã€",a.createElement(n.code,null,"vscode-lldb(codelldb)")," https://github.com/vadimcn/vscode-lldb ãŒä½¿ã„ãŸã„ã€‚"),"\n",a.createElement(n.h2,null,"codelldb ã®èµ·å‹•"),"\n",a.createElement(n.p,null,"nvim-dap ã‹ã‚‰ ",a.createElement(n.code,null,"codelldb.exe")," ãƒ—ãƒ­ã‚»ã‚¹ã¯èµ·å‹•ã—ã¦ã„ã‚‹æ§˜å­ã€‚é€šä¿¡ãŒã†ã¾ãã„ã£ã¦ãªã„ã‚ˆã†ã«è¦‹ãˆã‚‹ã€‚"),"\n",a.createElement(n.pre,null,a.createElement(n.code,null,"> .\\.cache\\dein\\repos\\github.com\\puremourning\\vimspector\\gadgets\\windows\\CodeLLDB\\adapter\\codelldb.exe\nListening on port 55201\n")),"\n",a.createElement(n.p,null,"æ¨™æº–å…¥å‡ºåŠ›ã‚’ä½¿ã†ãƒ¢ãƒ¼ãƒ‰ã«ãªã£ã¦ã„ãªã„ã®ã§ã¯ï¼Ÿ"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"adapter/src/lib.rs")),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},'async fn run_debug_server(\n    addr: net::SocketAddr,\n    adapter_settings: debug_protocol::AdapterSettings,\n    multi_session: bool,\n) {\n    let listener = TcpListener::bind(&addr).await.unwrap();\n\n    println!("Listening on port {}", listener.local_addr().unwrap().port());\n')),"\n",a.createElement(n.p,null,"é¡ã‚‹ã€‚ ",a.createElement(n.code,null,"main -> debug_server -> entry -> run_debug_server")),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-rust"},'fn main() -> Result<(), Error> {\n    env_logger::Builder::from_default_env().init();\n\n    let matches = App::new("codelldb")\n        .arg(Arg::with_name("port").long("port").takes_value(true))\n        .arg(Arg::with_name("multi-session").long("multi-session"))\n        .arg(Arg::with_name("preload").long("preload").multiple(true).takes_value(true))\n        .arg(Arg::with_name("liblldb").long("liblldb").takes_value(true))\n        .arg(Arg::with_name("params").long("params").takes_value(true))\n        .subcommand(SubCommand::with_name("terminal-agent").arg(Arg::with_name("port").long("port").takes_value(true)))\n        .get_matches();\n\n    if let Some(matches) = matches.subcommand_matches("terminal-agent") {\n        terminal_agent::terminal_agent(&matches)\n    } else {\n        debug_server(&matches)\n    }\n}\n')),"\n",a.createElement(n.p,null,"ã©ã†ã‚„ã‚‰ã€ ",a.createElement(n.code,null,"executable")," ã‹ã¤ ",a.createElement(n.code,null,"stdio ã§ã¯ãªã tcp")," é€šä¿¡ã¨ã„ã†ã‚¿ã‚¤ãƒ—ã§ nvim-dap ã§ã¯æœªå¯¾å¿œã¨ã„ã†ã“ã¨ã§ã‚ˆã•ãã†ã€‚ï¼Ÿ"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"èµ·å‹•"),"\n",a.createElement(n.li,null,a.createElement(n.code,null,"Listening on port XXXXX")," ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰ port ã‚’å¾—ã‚‹"),"\n",a.createElement(n.li,null,"ãã®ãƒãƒ¼ãƒˆã«å¯¾ã—ã¦ TCP æŽ¥ç¶šã¨ã„ã†æ‰‹é †ãŒå¿…è¦"),"\n"),"\n",a.createElement(n.p,null,"https://code.visualstudio.com/api/extension-guides/debugger-extension#alternative-approach-to-develop-a-debugger-extension"),"\n",a.createElement(n.p,null,"ã® ",a.createElement(n.code,null,"DebugAdapterServer")," ã‚¿ã‚¤ãƒ—ã«ã‚ãŸã‚‹ã€‚"),"\n",a.createElement(n.h2,null,"nvim-dap ã®æ”¹é€ ã‚’è©¦ã¿ã‚‹"),"\n",a.createElement(n.p,null,"adapter.type ",a.createElement(n.code,null,"executable"),", ",a.createElement(n.code,null,"server")," ã«åŠ ãˆã¦ã€ç¬¬3ã® ",a.createElement(n.code,null,"executable_server")," ã‚’ä½œã‚Œã‚‹ã‹ã€‚"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-lua"},"local function run_adapter(adapter, configuration, opts)\n  local name = configuration.name or '[no name]'\n  local options = adapter.options or {}\n  opts = vim.tbl_extend('keep', opts, {\n    cwd = options.cwd,\n    env = options.env\n  })\n  if adapter.type == 'executable' then\n    lazy.progress.report('Running: ' .. name)\n    M.launch(adapter, configuration, opts)\n  elseif adapter.type == 'server' then\n    lazy.progress.report('Running: ' .. name)\n    M.attach(adapter.host, adapter.port, configuration, opts)\n  elseif adapter.type == 'executable_server' then -- ðŸ‘ˆã“ã‚Œã‚’è¿½åŠ ã—ãŸ\n    lazy.progress.report('Running: ' .. name)\n    -- local session = M.launch(adapter, configuration, opts)\n    local stdin, stdout, stderr = executable_server(adapter, opts)\n    -- `Error executing luv callback: vimL function must not be called in a lua loop callback`\n    vim.loop.read_start(stdout, vim.schedule_wrap(function(err, data)\n      -- codelldb ã®å‡ºåŠ›ã‹ã‚‰ port ã‚’å¾—ã‚‹\n      -- Lisening on port xxxxx\n      local port = string.match(data , \"Listening on port (%d+)\" )\n      M.attach(nil, port, configuration, opts)\n    end))\n  else\n    print(string.format('Invalid adapter type %s, expected `executable` or `server`', adapter.type))\n  end\nend\n\nfunction executable_server(adapter, opts)\n  local uv = vim.loop\n  local stdin = uv.new_pipe(false)\n  local stdout = uv.new_pipe(false)\n  local stderr = uv.new_pipe(false)\n  local handle\n  local function onexit()\n    stdin:close()\n    stdout:close()\n    stderr:close()\n    handle:close()\n  end\n  local options = adapter.options or {}\n  local pid_or_err\n  handle, pid_or_err = uv.spawn(adapter.command, {\n    args = adapter.args;\n    stdio = {stdin, stdout, stderr};\n    cwd = options.cwd;\n    env = options.env;\n    detached = true;\n  }, onexit)\n  assert(handle, 'Error running ' .. adapter.command .. ': ' .. pid_or_err)\n\n  return stdin, stdout, stderr\nend\n\nfunction M.attach(host, port, config, opts)\n  if session then\n    session:close()\n  end\n  if not config.request then\n    print('config needs the `request` property which must be one of `attach` or `launch`')\n    return\n  end\n  -- initialize ãŒæ—©ã™ãŽã‚‹ã®ã§ config ã‚’ connect å¼•æ•°ã«\n  session = require('dap.session'):connect(host, port, opts, config)\n  return session\nend\n\nfunction Session:connect(host, port, opts, config)\n  local session = session_defaults(opts or {})\n  setmetatable(session, self)\n  self.__index = self\n\n  local client = uv.new_tcp()\n  session.client = {\n    write = function(line) \n        client:write(line) \n    end;\n    close = function()\n      client:shutdown()\n      client:close()\n    end;\n  }\n  client:connect(host or '127.0.0.1', tonumber(port), function(err)\n    if (err) then print(err) end\n    client:read_start(rpc.create_read_loop(function(body)\n      session:handle_body(body)\n    end))\n\n    -- connect ãŒæˆç«‹ã—ã¦ã‹ã‚‰ initialize ã‚’é€ã‚‹\n    session:initialize(config)\n\n  end)\n  return session\nend\n")),"\n",a.createElement(n.p,null,"å‹•ã„ãŸã€‚ PR ä½œã‚ã†ã€‚"))}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)}},1151:function(e,n,t){t.d(n,{ah:function(){return r}});var l=t(7294);const a=l.createContext({});function r(e){const n=l.useContext(a);return l.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);
//# sourceMappingURL=component---content-posts-2021-nvim-dap-codelldb-md-3658db622320130dc227.js.map