"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2357],{6717:function(n,e,a){a.r(e),a.d(e,{default:function(){return g}});var r=a(1151),t=a(7294);function o(n){const e=Object.assign({p:"p",span:"span"},(0,r.ah)(),n.components);return t.createElement(t.Fragment,null,t.createElement(e.p,null,"アルファブレンディング\nシャドウキャスター\nシャドウレシーバー"),"\n",t.createElement(e.p,null,"なシェーダー。"),"\n",t.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">基本\n新規作成\nCreate -> Shader -> UnLitShader\nCustomShader\n\nShader "CustomShader"\n{\n    Properties\n    {\n        _MainTex ("Texture", 2D) = "white" {}\n    }\n    SubShader\n    {\n        Tags { "RenderType"="Opaque" }\n        LOD 100\n\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            // make fog work\n            #pragma multi_compile_fog\n\n            #include "UnityCG.cginc"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                UNITY_FOG_COORDS(1)\n                float4 vertex : SV_POSITION;\n            };\n\n            sampler2D _MainTex;\n            float4 _MainTex_ST;\n\n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n                o.uv = TRANSFORM_TEX(v.uv, _MainTex);\n                UNITY_TRANSFER_FOG(o,o.vertex);\n                return o;\n            }\n\n            fixed4 frag (v2f i) : SV_Target\n            {\n                // sample the texture\n                fixed4 col = tex2D(_MainTex, i.uv);\n                // apply fog\n                UNITY_APPLY_FOG(i.fogCoord, col);\n                return col;\n            }\n            ENDCG\n        }\n    }\n}\n\nこの時点でテクスチャが表示できるけど一度無にしよう\nShader "CustomShader"\n{\n    SubShader\n    {\n        Tags { "RenderType"="Opaque" }\n        LOD 100\n        Pass\n        {\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            float4 vert(float4 v:POSITION) : SV_POSITION{\n                return mul(UNITY_MATRIX_MVP, v);\n            }\n            fixed4 frag() : COLOR{\n                return fixed4(1.0,0.0,0.0,1.0);\n            }\n            ENDCG\n        }\n    }\n}\n\n\n頂点変形だけを適用して赤一色。\nColor\nべたにマテリアル色が出る。\nShader "CustomShader"\n{\n    Properties\n    {\n        _Color("Color", Color) = (1,1,1,1)\n    }\n    SubShader\n    {\n    Tags{ "RenderType" = "Opaque" }\n    LOD 100\n\n    Pass\n    {\n        CGPROGRAM\n#pragma target 3.0\n#pragma vertex vert\n#pragma fragment frag\n\n        uniform float4 _Color;\n\n        float4 vert(float4 v:POSITION) : SV_POSITION{\n            return mul(UNITY_MATRIX_MVP, v);\n        }\n        fixed4 frag() : COLOR{\n            return _Color;\n        }\n        ENDCG\n    }\n\n    } // SurShader\n}\n\n_Colorプロパティを定義して、uniform変数_Colorを宣言し使う。\nTexture\nテクスチャ色を乗算\nShader "CustomShader"\n{\n    Properties\n    {\n        _Color("Color", Color) = (1,1,1,1)\n        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}\n    }\n    SubShader\n    {\n    Tags{ "RenderType" = "Opaque" }\n    LOD 100\n\n    Pass\n    {\n        CGPROGRAM\n#pragma target 3.0\n#pragma vertex vert\n#pragma fragment frag\n\n        struct appdata\n        {\n            float4 vertex : POSITION;\n            float2 uv : TEXCOORD0;\n        };\n        struct v2f\n        {\n            float2 uv : TEXCOORD0;\n            float4 vertex : SV_POSITION;\n        };\n\n        uniform float4 _Color;\n        uniform sampler2D _MainTex;\n\n        v2f vert(appdata v){\n            v2f o;\n            o.vertex= mul(UNITY_MATRIX_MVP, v.vertex);\n            o.uv = v.uv;\n            return o;\n        }\n        fixed4 frag(v2f i) : COLOR{\n            fixed4 tex = tex2D(_MainTex, i.uv);\n            return _Color * tex;\n        }\n        ENDCG\n    }\n\n    } // SurShader\n}\n\n\nシェーダーの入力に位置とUV、出力に変換済みの位置とUVが必要になったので構造体appdataとv2fを導入\n_MainTexプロパティを導入し、サンプラー_MainTexを宣言してtex2D関数で使う\n\nAlphaBlending\n追加分\nShader "CustomShader"\n{\n    SubShader\n    {\n    // 背景を含む不透明なものの後で描画する\n    Tags{ "Queue" = "Transparent" }\n\n    Pass\n    {\n        Blend SrcAlpha OneMinusSrcAlpha\n    }\n\n    } // SurShader\n}\n\n\nここまでで照明の無い基本的なシェーダーができる。\nUnityCG.cgincを使う\n最初に新規作成したShaderにAplhaBlendingを追加した感じ。\nuniform変数のuniformは省略できる。\nShader "CustomShader"\n{\n    Properties\n    {\n        _Color("Color", Color) = (1,1,1,1)\n        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}\n    }\n    SubShader\n    {\n        Tags{ "Queue" = "Transparent" }\n        LOD 100\n\n    Pass\n    {\n        Blend SrcAlpha OneMinusSrcAlpha\n\n        CGPROGRAM\n        #pragma target 3.0\n        #pragma vertex vert\n        #pragma fragment frag\n\n        // make fog work\n        #pragma multi_compile_fog\n\n        #include "UnityCG.cginc"\n\n        struct appdata\n        {\n            float4 vertex : POSITION;\n            float2 uv : TEXCOORD0;\n        };\n\n        struct v2f\n        {\n            float2 uv : TEXCOORD0;\n            UNITY_FOG_COORDS(1)\n            float4 vertex : SV_POSITION;\n        };\n\n        float4 _Color;\n        sampler2D _MainTex;\n        float4 _MainTex_ST;\n\n        v2f vert(appdata v)\n        {\n            v2f o;\n            o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n            o.uv = TRANSFORM_TEX(v.uv, _MainTex);\n            UNITY_TRANSFER_FOG(o,o.vertex);\n            return o;\n        }\n\n        fixed4 frag(v2f i) : SV_Target\n        {\n            // sample the texture\n            fixed4 col = tex2D(_MainTex, i.uv);\n            // apply fog\n            UNITY_APPLY_FOG(i.fogCoord, col);\n            return col * _Color;\n        }\n        ENDCG\n    }\n\n    } // SurShader\n}\n\nLighting導入\nVertex and Fragment Shader Examplesの後半Calculating Lighting\nを参考にライティングをやってみる。\nforward rendringを使うことで\n\nDirectionalLight\nambient\nlightmap\nreflections\n\nを扱える。\nTags {"LightMode"="ForwardBase"}\n\nを定義することでUnityの組み込み変数を通じて上記のシーンのライティング情報を得ることができるようになる。\n頂点ライティングによるDiffuse &amp; Ambient\n\nDirectionalLightによるDiffuse計算\nappdata_base導入(UnityCG.cgincで定義)\nv2fにdiffuse追加\nvertでdiffuse計算\n\nShader "CustomShader"\n{\n    Properties\n    {\n        _Color("Color", Color) = (1,1,1,1)\n        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}\n    }\n    SubShader\n    {\n        Tags{ "Queue" = "Transparent" }\n        LOD 100\n\n    Pass\n    {\n        Tags{ "LightMode" = "ForwardBase" }\n\n        Blend SrcAlpha OneMinusSrcAlpha\n\n        CGPROGRAM\n        #pragma target 3.0\n        #pragma vertex vert\n        #pragma fragment frag\n\n        // make fog work\n        #pragma multi_compile_fog\n\n        #include "UnityCG.cginc"\n        #include "UnityLightingCommon.cginc" // for _LightColor0\n\n        struct v2f\n        {\n            float2 uv : TEXCOORD0;\n            fixed4 diffuse : COLOR0; // diffuse lighting color\n            float4 vertex : SV_POSITION;\n            UNITY_FOG_COORDS(1)\n        };\n\n        uniform float4 _Color;\n        uniform sampler2D _MainTex;\n        float4 _MainTex_ST;\n\n        v2f vert(appdata_base v)\n        {\n            v2f o;\n            o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n            o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);\n\n            // get vertex normal in world space\n            half3 worldNormal = UnityObjectToWorldNormal(v.normal);\n            // dot product between normal and light direction for\n            // standard diffuse (Lambert) lighting\n            half nl = max(0, dot(worldNormal, _WorldSpaceLightPos0.xyz));\n            // factor in the light color\n            o.diffuse = nl * _LightColor0;\n\n            // the only difference from previous shader:\n            // in addition to the diffuse lighting from the main light,\n            // add illumination from ambient or light probes\n            // ShadeSH9 function from UnityCG.cginc evaluates it,\n            // using world space normal\n            o.diffuse.rgb += ShadeSH9(half4(worldNormal,1));\n\n            UNITY_TRANSFER_FOG(o,o.vertex);\n            return o;\n        }\n\n        fixed4 frag(v2f i) : SV_Target\n        {\n            // sample the texture\n            fixed4 col = tex2D(_MainTex, i.uv) * _Color;\n            // apply fog\n            UNITY_APPLY_FOG(i.fogCoord, col);\n            col.rgb *= i.diffuse;\n            return col;\n        }\n        ENDCG\n    }\n\n    } // SurShader\n}\n\nShadowキャスティング\nShadowMapに深度を描画するPassを追加する。\n簡単なのは下記。\n// pull in shadow caster from VertexLit built-in shader\nUsePass "Legacy Shaders/VertexLit/SHADOWCASTER"\n\n手作りもできる。\n\npragma multi_compile_shadowcasterがポイント\n\n    // shadow caster rendering pass, implemented manually\n    // using macros from UnityCG.cginc\n    Pass\n    {\n        Tags{ "LightMode" = "ShadowCaster" }\n\n        CGPROGRAM\n        #pragma vertex vert\n        #pragma fragment frag\n        #pragma multi_compile_shadowcaster\n        #include "UnityCG.cginc"\n\n        struct v2f {\n            V2F_SHADOW_CASTER;\n        };\n\n        v2f vert(appdata_base v)\n        {\n            v2f o;\n            TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)\n                return o;\n        }\n\n        float4 frag(v2f i) : SV_Target\n        {\n            SHADOW_CASTER_FRAGMENT(i)\n        }\n        ENDCG\n    }\n\nShadowReceiveing\n\npragma multi_compile_fwdbaseがポイント\n\nShader "CustomShader"\n{\n    Properties\n    {\n        _Color("Color", Color) = (1,1,1,1)\n        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}\n    }\n    SubShader\n    {\n    Tags{ "Queue" = "Geometry" }\n    LOD 100\n\n    Pass\n    {\n        Tags{ "LightMode" = "ForwardBase" "IgnoreProjector" = "True" "PerformanceChecks" = "False" }\n        ZWrite On\n        Blend SrcAlpha OneMinusSrcAlpha\n\n        CGPROGRAM\n        #pragma target 3.0\n        #pragma vertex vert\n        #pragma fragment frag\n\n        // make fog work\n        #pragma multi_compile_fog\n\n        #include "UnityCG.cginc"\n        #include "UnityLightingCommon.cginc" // for _LightColor0\n\n        // compile shader into multiple variants, with and without shadows\n        // (we don\'t care about any lightmaps yet, so skip these variants)\n        #pragma multi_compile_fwdbase nolightmap nodirlightmap nodynlightmap novertexlight\n        // shadow helper functions and macros\n        #include "AutoLight.cginc"\n\n        struct v2f\n        {\n            float2 uv : TEXCOORD0;\n            float4 pos : SV_POSITION;\n            fixed4 diff : COLOR0; // diffuse lighting color\n            fixed3 ambient : COLOR1;\n            SHADOW_COORDS(1) // put shadows data into TEXCOORD1\n            UNITY_FOG_COORDS(1)\n        };\n\n        uniform float4 _Color;\n        uniform sampler2D _MainTex;\n        float4 _MainTex_ST;\n\n        v2f vert(appdata_base v)\n        {\n            v2f o;\n            o.pos = mul(UNITY_MATRIX_MVP, v.vertex);\n            o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);\n\n            // get vertex normal in world space\n            half3 worldNormal = UnityObjectToWorldNormal(v.normal);\n            // dot product between normal and light direction for\n            // standard diffuse (Lambert) lighting\n            half nl = max(0, dot(worldNormal, _WorldSpaceLightPos0.xyz));\n            // factor in the light color\n            o.diff = nl * _LightColor0;\n\n            // the only difference from previous shader:\n            // in addition to the diffuse lighting from the main light,\n            // add illumination from ambient or light probes\n            // ShadeSH9 function from UnityCG.cginc evaluates it,\n            // using world space normal\n            o.ambient = ShadeSH9(half4(worldNormal, 1));\n\n            // compute shadows data\n            TRANSFER_SHADOW(o)\n\n            UNITY_TRANSFER_FOG(o,o.vertex);\n            return o;\n        }\n\n        fixed4 frag(v2f i) : SV_Target\n        {\n            // sample the texture\n            fixed4 col = tex2D(_MainTex, i.uv) * _Color;\n\n            fixed shadow = SHADOW_ATTENUATION(i);\n\n            // darken light\'s illumination with shadow, keep ambient intact\n            fixed3 lighting = i.diff * shadow + i.ambient;\n            col.rgb *= lighting;\n\n            // apply fog\n            UNITY_APPLY_FOG(i.fogCoord, col);\n\n            return col;\n        }\n        ENDCG\n    }\n\n    // shadow caster rendering pass, implemented manually\n    // using macros from UnityCG.cginc\n    Pass\n    {\n        Tags{ "LightMode" = "ShadowCaster" }\n\n        CGPROGRAM\n        #pragma vertex vert\n        #pragma fragment frag\n        #pragma multi_compile_shadowcaster\n        #include "UnityCG.cginc"\n\n        struct v2f {\n            V2F_SHADOW_CASTER;\n        };\n\n        v2f vert(appdata_base v)\n        {\n            v2f o;\n            TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)\n                return o;\n        }\n\n        float4 frag(v2f i) : SV_Target\n        {\n            SHADOW_CASTER_FRAGMENT(i)\n        }\n        ENDCG\n    }\n\n    } // SurShader\n\n    Fallback "Transparent/VertexLit"\n}</code></pre></div>'}}))}var i=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?t.createElement(e,n,t.createElement(o,n)):o(n)},l=a(8678),f=a(8838);const d={code:n=>{let{children:e,className:a}=n;return a?t.createElement(f.Z,{className:a},e):t.createElement("code",null,e)}};function s(n){let{data:e,children:a}=n;return t.createElement(l.Z,null,t.createElement("h1",null,e.mdx.frontmatter.title),t.createElement(r.Zo,{components:d},a))}function g(n){return t.createElement(s,n,t.createElement(i,n))}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2016-01-11-unity-write-shader-md-85edb814b160ccfca4c8.js.map