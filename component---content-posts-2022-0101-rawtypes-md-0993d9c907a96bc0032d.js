"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[603],{2494:function(e,n,t){t.r(n);var l=t(1151),c=t(7294);function a(e){const n=Object.assign({h1:"h1",p:"p",code:"code",pre:"pre",ul:"ul",li:"li",h2:"h2"},(0,l.ah)(),e.components);return c.createElement(c.Fragment,null,c.createElement(n.h1,null,"rawtypes 作ってみる"),"\n",c.createElement(n.p,null,c.createElement(n.code,null,"cython")," から ",c.createElement(n.code,null,"pybind11")," に乗り換えを試みたのだが、\n一歩目で躓いた。"),"\n",c.createElement(n.p,null,"不完全型のポインタをそのまま返す方法がわからん。"),"\n",c.createElement(n.pre,null,c.createElement(n.code,{className:"language-c++"},"ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);\n")),"\n",c.createElement(n.p,null,c.createElement(n.code,null,"ImGuiContext")," は前方宣言なのです。"),"\n",c.createElement(n.p,null,"自分でやろうと思った。\n",c.createElement(n.code,null,"ctypes")," と併用することを前提にした省機能のバインダー、名付けて ",c.createElement(n.code,null,"rawtypes")," を作ってみよう。\n",c.createElement(n.code,null,"c++")," の関数呼び出しのちょっとしたコード生成をする。\n基本的に ",c.createElement(n.code,null,"ctypes.c_void_p")," で済ます。\n型の宣言が必要なところは、 ",c.createElement(n.code,null,"ctypes.Structure")," により ",c.createElement(n.code,null,"python")," 側で宣言。\n",c.createElement(n.code,null,"c++")," から返す時には、キャストする。"),"\n",c.createElement(n.pre,null,c.createElement(n.code,{className:"language-python"},"return ctypes.cast(p, ctypes.POINTER(CTYPES_TYPE))[0]\n")),"\n",c.createElement(n.p,null,"object の所有権 はまじめに探求しない。"),"\n",c.createElement(n.ul,null,"\n",c.createElement(n.li,null,"python で作って、python で開放する(cypte.Struct object)"),"\n",c.createElement(n.li,null,"c++ で作ったのを cast して python に渡すが参照のみ(cast された ctypes.Struct)。無効なものにアクセスしないようにプログラマがー注意する"),"\n",c.createElement(n.li,null,"それ以外は値渡し"),"\n"),"\n",c.createElement(n.p,null,"これで十分。\n主要な狙いは、"),"\n",c.createElement(n.ul,null,"\n",c.createElement(n.li,null,"static library のリンク"),"\n",c.createElement(n.li,null,c.createElement(n.code,null,"c++")," 関数の呼び出し"),"\n",c.createElement(n.li,null,"構造体の値渡しを ",c.createElement(n.code,null,"c++")," でラップする"),"\n"),"\n",c.createElement(n.p,null,"で、 ",c.createElement(n.code,null,"ctypes")," の苦手なところだけをやる。\n",c.createElement(n.code,null,"luajit ffi")," に倣ったスタイルでまいる。"),"\n",c.createElement(n.h2,null,"動いた"),"\n",c.createElement(n.p,null,"https://github.com/ousttrue/pydear"),"\n",c.createElement(n.p,null,"ImGui ひととおりできた。\nもうちっとパッケージング(sdist, wheel)を整理したら形が整う。\n",c.createElement(n.code,null,"github action")," で ",c.createElement(n.code,null,"wheel")," をビルドする技もできた(",c.createElement(n.code,null,"windows-64bit + python-3.10")," のみ実験)。"),"\n",c.createElement(n.p,null,c.createElement(n.code,null,"str")," と ",c.createElement(n.code,null,"bytes")," の切りわけも ",c.createElement(n.code,null,"C-API")," で書けたし、慣れれば直接 ",c.createElement(n.code,null,"C-API")," を使った方が便利そう。\n",c.createElement(n.code,null,"Py_INCREF")," ",c.createElement(n.code,null,"Py_DECREF")," による参照管理と、",c.createElement(n.code,null,"PyErr_Clear")," 等のエラーハンドリングなど\nを抑えればよさそう。"),"\n",c.createElement(n.h2,null,"pypi"),"\n",c.createElement(n.p,null,"https://pypi.org/project/pydear/"),"\n",c.createElement(n.p,null,"github actions で wheel をビルドして、 pypi にアップロードするところまでできた。\nあと、 ",c.createElement(n.code,null,"sdist")," も作る。"),"\n",c.createElement(n.p,null,c.createElement(n.code,null,"pip install pydear")," して使えるようになった。\n使いながら整備していこう。"),"\n",c.createElement(n.p,null,c.createElement(n.code,null,"pyi")," が含まれているので、ある程度のインテリセンスが効くところがよい。"),"\n",c.createElement(n.ul,null,"\n",c.createElement(n.li,null,"[ ] rawtypes をライブラリとして分離する"),"\n",c.createElement(n.li,null,"[ ] clang.cindex でコード生成した結果を ",c.createElement(n.code,null,"sdist")," に含める"),"\n"))}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?c.createElement(n,e,c.createElement(a,e)):a(e)}},1151:function(e,n,t){t.d(n,{ah:function(){return a}});var l=t(7294);const c=l.createContext({});function a(e){const n=l.useContext(c);return l.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);
//# sourceMappingURL=component---content-posts-2022-0101-rawtypes-md-0993d9c907a96bc0032d.js.map