"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[314],{8551:function(e,n,a){a.r(n);var t=a(1151),r=a(7294);function s(e){const n=Object.assign({p:"p",pre:"pre",code:"code"},(0,t.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.p,null,"glBufferDataに数字のlistを渡す場合以下のように渡せるがどうゆう実装なのか。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-py"},"vertices=[0, 1, 2] # x, y, z\n\nglBufferData(GL_ARRAY_BUFFER, \n        len(vertices)*4,  # byte size\n        (ctypes.c_float*len(vertices))(*vertices), # 謎のctypes\n        GL_STATIC_DRAW)\n")),"\n",r.createElement(n.p,null,"非常に読み辛かったがVisualStudioでステップ実行して動きを追ってみた。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-py"},'# site-packages/OpenGL/GL/VERSION/GL_1_5.py\n@_lazy( glBufferData )\ndef glBufferData( baseOperation, target, size, data=None, usage=None ):\n    """Copy given data into the currently bound vertex-buffer-data object\n\n    target -- the symbolic constant indicating which buffer type is intended\n    size -- if provided, the count-in-bytes of the array\n    data -- data-pointer to be used, may be None to initialize without\n        copying over a data-set\n    usage -- hint to the driver as to how to set up access to the buffer\n\n    Note: parameter "size" can be omitted, which makes the signature\n        glBufferData( target, data, usage )\n    instead of:\n        glBufferData( target, size, data, usage )\n    """\n    if usage is None:\n        usage = data\n        data = size\n        size = None\n    data = ArrayDatatype.asArray( data ) # <- ここでPythonの型をOpenGLに渡せるように変換\n    if size is None:\n        size = ArrayDatatype.arrayByteCount( data )\n    return baseOperation( target, size, data, usage )\n')),"\n",r.createElement(n.p,null,"難関。デバッガ無しでは追えませんでした。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-py"},'# site-packages/OpenGL/arrays/arraydatatype.py\nclass HandlerRegistry( dict ):\n    def __init__( self, plugin_match ):\n        self.match = plugin_match\n\n    def __call__( self, value ): # 4\n        """Lookup of handler for given value"""\n        try:\n            typ = value.__class__\n        except AttributeError as err:\n            typ = type(value)\n        handler = self.get( typ )\n        if not handler:\n            if hasattr( typ, \'__mro__\' ):\n                for base in typ.__mro__:\n                    handler = self.get( base )\n                    if not handler:\n                        handler = self.match( base ) # 5\n                        if handler:\n                            handler = handler.load()\n                            if handler:\n                                handler = handler()\n                    if handler:\n                        self[ typ ] = handler\n                        if hasattr( handler, \'registerEquivalent\' ):\n                            handler.registerEquivalent( typ, base )\n                        return handler\n            raise TypeError(\n                    """No array-type handler for type %s.%s (value: %s) registered"""%(\n                        typ.__module__, type.__name__, repr(value)[:50]\n                        )\n                    )\n            return handler\n\nGLOBAL_REGISTRY = HandlerRegistry(\n    plugins.FormatHandler.match # 6 -> plugins.pyに進む\n    ) # 3\nclass ArrayDatatype( object ):\n    getHandler = GLOBAL_REGISTRY.__call__ # 2\n    def asArray( cls, value, typeCode=None ): # 0 <- glBufferDataから呼ばれる\n        """Given a value, convert to preferred array representation"""\n        return cls.getHandler(value).asArray( value, typeCode or cls.typeConstant ) # 1\n    asArray = classmethod( logs.logOnFail( asArray, _log ) )\n')),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-py"},'# site-packages/OpenGL/plugins.py\nclass Plugin( object ):\n    """Base class for plugins to be loaded"""\n    loaded = False\n    def __init__( self, name, import_path, check = None, **named ):\n        """Register the plug-in"""\n        self.registry.append( self ) # <-  FormatHandlerのインスタンスが登録される\n\nclass FormatHandler( Plugin ):\n    """Data-type storage-format handler"""\n    registry = [] # <- OpenGL/__init__.pyで初期化される\n    @classmethod\n    def match( cls, value ): # 7\n        """Lookup appropriate handler based on value (a type)"""\n        key = \'%s.%s\'%( value.__module__, value.__name__ )\n        for plugin in cls.registry: # <- ここにハンドラのリストがある\n            set = getattr( plugin, \'check\', ())\n            if set and key in set:\n                return plugin\n        return None\n')),"\n",r.createElement(n.p,null,"これらがimport時にFormatHandlerとして登録される。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-py"},"# site-packages/OpenGL/__init__.py\nFormatHandler( 'none', 'OpenGL.arrays.nones.NoneHandler', [ _bi+'.NoneType'],isOutput=False )\n\nif sys.version_info[0] < 3:\n    FormatHandler( 'str', 'OpenGL.arrays.strings.StringHandler',[_bi+'.str'], isOutput=False )\n    FormatHandler( 'unicode', 'OpenGL.arrays.strings.UnicodeHandler',[_bi+'.unicode'], isOutput=False )\nelse:\n    FormatHandler( 'bytes', 'OpenGL.arrays.strings.StringHandler',[_bi+'.bytes'], isOutput=False )\n    FormatHandler( 'str', 'OpenGL.arrays.strings.UnicodeHandler',[_bi+'.str'], isOutput=False )\n    \nFormatHandler( 'list', 'OpenGL.arrays.lists.ListHandler', [\n    _bi+'.list',\n    _bi+'.tuple',\n], isOutput=False )\nFormatHandler( 'numbers', 'OpenGL.arrays.numbers.NumberHandler', [\n    _bi+'.int',\n    _bi+'.float',\n    _bi+'.long',\n], isOutput=False )\nFormatHandler(\n    'ctypesarrays', 'OpenGL.arrays.ctypesarrays.CtypesArrayHandler',\n    [\n        '_ctypes.ArrayType',\n        '_ctypes.PyCArrayType',\n        '_ctypes.Array',\n        '_ctypes.array.Array',\n    ],\n    isOutput=True,\n)\nFormatHandler(\n    'ctypesparameter',\n    'OpenGL.arrays.ctypesparameters.CtypesParameterHandler',\n    [\n        _bi+'.CArgObject',\n        'ctypes.c_uint',\n        'ctypes.c_int',\n        'ctypes.c_float',\n        'ctypes.c_double',\n        'ctypes.c_ulong',\n        'ctypes.c_long',\n        'ctypes.c_longlong',\n    ],\n    isOutput=True,\n)\nFormatHandler( 'ctypespointer', 'OpenGL.arrays.ctypespointers.CtypesPointerHandler',[\n    'ctypes.c_void_p',\n    '_ctypes._Pointer',\n    'ctypes.c_char_p',\n    '_ctypes.pointer._Pointer',\n],isOutput=False )\nFormatHandler( 'numpy', 'OpenGL.arrays.numpymodule.NumpyHandler', [\n    'numpy.ndarray',\n    'numpy.core.memmap.memmap',\n],isOutput=True )\nFormatHandler( 'buffer', 'OpenGL.arrays.buffers.BufferHandler', [\n    'OpenGL.arrays._buffers.Py_buffer',\n    _bi+'.memoryview',\n    _bi+'.bytearray',\n],isOutput=True )\nFormatHandler( 'vbo', 'OpenGL.arrays.vbo.VBOHandler', ['OpenGL.arrays.vbo.VBO','OpenGL_accelerate.vbo.VBO'],isOutput=False )\nFormatHandler( 'vbooffset', 'OpenGL.arrays.vbo.VBOOffsetHandler', ['OpenGL.arrays.vbo.VBOOffset','OpenGL_accelerate.vbo.VBOOffset'],isOutput=False )\n")),"\n",r.createElement(n.p,null,"numpyとか定義されているね。なるほど。"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"(ctypes.c_float*len(vertices))(*vertices)")," は ",r.createElement(n.code,null,"ctypes.c_float")," にマッチして、",r.createElement(n.code,null,"CtypesArrayHandler")," によって処理される。\n一方、単なるPythonのlistであるverticesは、",r.createElement(n.code,null,"OpenGL.arrays.lists.ListHandler")," によって処理されて ",r.createElement(n.code,null,"NotImplementedError")," に落ちるのであった。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-py"},'class ListHandler( formathandler.FormatHandler ):\n    @classmethod\n    def asArray( cls, value, typeCode=None ):\n        """Convert given value to a ctypes array value of given typeCode\n        \n        This does a *lot* of work just to get the data into the correct\n        format.  It\'s not going to be anywhere near as fast as a numpy\n        or similar approach!\n        """\n        if typeCode is None:\n            raise NotImplementedError( """Haven\'t implemented type-inference for lists yet""" )\n')),"\n",r.createElement(n.p,null,"確かにlistだと中身の型が決められんね。なるほど。"))}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?r.createElement(n,e,r.createElement(s,e)):s(e)}},1151:function(e,n,a){a.d(n,{ah:function(){return s}});var t=a(7294);const r=t.createContext({});function s(e){const n=t.useContext(r);return t.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);
//# sourceMappingURL=component---content-posts-2017-glbufferdata-md-faedcd0b8f27f6ffe6b1.js.map