"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7088],{6212:function(e,n,t){t.r(n);var a=t(1151),l=t(7294);function r(e){const n=Object.assign({p:"p",pre:"pre",code:"code"},(0,a.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.p,null,"lambdaの引数の型を得たい\nmsgpack-rpcの関数登録の都合上、 lambda関数から引数の型を得たい。\n下記のような書き方をしたい。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-c++"},"template \nvoid register_func(const std::stiring &func_name, R(*handler)(A1, A2)) {\n// 関数登録 \n}\n\nint main() { \n    // errorになる \n    register_func(“add”, [](int a, int b)->int{ return a+b; });\n    return 0;\n} \n")),"\n",l.createElement(n.p,null,"上記の書き方では普通の関数ポインタを受けることはできるのだが、"),"\n",l.createElement(n.p,null,"std::functionとlambdaは受けられない。\nstd::functionを受けるには下記のようにすることでできた。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-c++"},"c++ template<typename R, typename A1, typename A2> void register_func(const std::string &func_name, std::function<R(A1, A2) handler) {     // }\n")),"\n",l.createElement(n.p,null,"残り、lambdaを受けられる記述方法を知りたいのだがどうしたらよいものか。\n下記のような手はうまくいかなかった・・・"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-c++"},"c++ template<typename F, typename R, typename A1, typename A2> void add_handler(F handler, const std::string &method) {     std::function<R(A1, A2)> f(handler);     //add_handler }\n")),"\n",l.createElement(n.p,null,"こちらのサイトから\nhttp://d.hatena.ne.jp/osyo-manga/20121205/1354674180\ndecltypeを使ったらなんかできそうな感じがしたので粘っていたのだが、\n目的そのものの記事を発見した。\nhttp://stackoverflow.com/questions/6512019/can-we-get-the-type-of-a-lambda-argument\n微妙にそのままではコンパイルが通らなかったので少し工夫したらうまくいった。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-c++"},"// ret template Ret helper0(Ret (F::*)(Rest…));\ntemplate Ret helper0(Ret (F::*)(Rest…) const);\n// 1 template A1 helper1(Ret (F::*)(A1, Rest…));\ntemplate A1 helper1(Ret (F::*)(A1, Rest…) const);\n// 2 template A2 helper2(Ret (F::*)(A1, A2, Rest…));\ntemplate A2 helper2(Ret (F::*)(A1, A2, Rest…) const);\ntemplate void add_handler(F handler, const std::string &method) {\ntypedef decltype(handler) functor; typedef\ndecltype(helper0(&functor::operator())) R; typedef\ndecltype(helper1(&functor::operator())) A1; typedef\ndecltype(helper2(&functor::operator())) A2;\n// register function...\n} \n")),"\n",l.createElement(n.p,null,"F handlerで関数ポインタ、lambda、std::function等全部受けられるようになったらしくoverloadが不要になった。\ndecltypeなんかすごいな。"))}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?l.createElement(n,e,l.createElement(r,e)):r(e)}},1151:function(e,n,t){t.d(n,{ah:function(){return r}});var a=t(7294);const l=a.createContext({});function r(e){const n=a.useContext(l);return a.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);
//# sourceMappingURL=component---content-posts-2013-05-16-lambda-md-1f2eec24676c4d3f71c6.js.map