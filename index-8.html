<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="ja">
<head>
<meta charset="utf-8">
<meta name="description" content="作業記録">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>三次元日誌 (過去の記事 8ページ目) | 三次元日誌</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ja" href="rss.xml">
<link rel="canonical" href="https://ousttrue.github.io/index-8.html">
<link rel="prev" href="index-9.html" type="text/html">
<link rel="next" href="index-7.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">本文を読み飛ばす</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href=".">

            <span id="blog-title">三次元日誌</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav"></ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="archive.html" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="categories/index.html" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="rss.xml" class="nav-link">RSS feed</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
    
        

    
        
    <div class="postindex">
            <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2017/02/hugo-memo/" class="u-url">Hugoに乗り換え</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2017/02/hugo-memo/" rel="bookmark">
            <time class="published dt-published" datetime="2017-02-17T00:00:00+09:00" itemprop="datePublished" title="2017-02-17 00:00">2017-02-17 00:00</time></a>
            </p>
                        <p class="commentline">
        
    <a href="posts/2017/02/hugo-memo/#disqus_thread" data-disqus-identifier="cache/content/posts/2017/02/hugo-memo.html">コメント</a>


                </p>
</div>
            </header><div class="e-content entry-content">
                    <div>
<p>なんとなくまたサイトシステム更新。</p>
<p>前回はgulpで何もかも自前にしすぎて、めんどくささが上がりすぎてしまった。反省してシンプルなhugoにしてみました。前はgulpで何でもありにしてたのでwebglとかunityとかもできたのだけど、そういうのは動かなくなる。しかしまぁ、そんなにwebやらんよねということで。とりあえず、旧サイトのMarkdownのfrontmatterをpythonで少し手直ししてimportしてみた。hugo軽快な動作でよいね。themeを見繕ってsyntax highlightの入ったよさげな感じになった。</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2016/03/12/ipython/" class="u-url">IPythonことはじめ</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2016/03/12/ipython/" rel="bookmark">
            <time class="published dt-published" datetime="2016-03-12T00:00:00+09:00" itemprop="datePublished" title="2016-03-12 00:00">2016-03-12 00:00</time></a>
            </p>
                        <p class="commentline">
        
    <a href="posts/2016/03/12/ipython/#disqus_thread" data-disqus-identifier="cache/content/posts/2016/03/12/ipython.html">コメント</a>


                </p>
</div>
            </header><div class="e-content entry-content">
                    <div>
<p>「IPythonデーターサイエンスクックブック」を買ってきたのでやってみる。
洋書の原書も買ってたが家で塩漬けになっていたり・・・
インストール
Windowsでやる。
普通のPythonだとnumpy等のライブラリを揃えるのが大変なので、
付属ライブラリが添付されているAnacondaパッケージを使いましょう。
https://www.continuum.io/downloads
python3.5(64bit)を選んでみた。
起動</p>
<blockquote>
<p>mkdir notebook
cd notebook
notebook&gt; C:\Anaconda3\Scripts\ipython.exe notebook</p>
</blockquote>
<p>カレントディレクトリが作業領域になるのでC:\から実行したりすると404って言われる。
実行
右上の[new]を押して、[python3]を選択。
”‘python
print(‘hello’)
```
と入れて[shift+enter]で実行。</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2016/01/27/unity_serializedobject/" class="u-url">UnityのSerializedObject</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2016/01/27/unity_serializedobject/" rel="bookmark">
            <time class="published dt-published" datetime="2016-01-27T00:00:00+09:00" itemprop="datePublished" title="2016-01-27 00:00">2016-01-27 00:00</time></a>
            </p>
                        <p class="commentline">
        
    <a href="posts/2016/01/27/unity_serializedobject/#disqus_thread" data-disqus-identifier="cache/content/posts/2016/01/27/unity_serializedobject.html">コメント</a>


                </p>
</div>
            </header><div class="e-content entry-content">
                    <div>
<p>UnityのSerializedObjectのメモ。</p>
<p>PropertyDrawers have two uses:
- Customize the GUI of every instance of a Serializable class.
- Customize the GUI of script members with custom PropertyAttributes.</p>
<p>できることは２つ。
Serializeable classのPropertyDrawerを定義する。
PropertyAttributeを定義して既存のSerializable classのPropertyDrawerを差し替える。
Not Serializableなclassに対してPropertyDrawerを定義することはできぬ(TimeSpanとかね)。
PropertyDrawerを定義してみる
using UnityEngine;</p>
<h2>if UNITY_EDITOR</h2>
<p>using UnityEditor;</p>
<h2>endif</h2>
<p>public class SampleAttribute : PropertyAttribute
{
}</p>
<h2>if UNITY_EDITOR</h2>
<p>[CustomPropertyDrawer(typeof(SampleAttribute))]
public class SampleDrawer : PropertyDrawer
{
    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        var sampleAttribute = (SampleAttribute)attribute;
        Debug.Log(property);
        EditorGUI.PropertyField(position, property, new GUIContent("Hoge"));
    }
}</p>
<h2>endif</h2>
<p>public class SampleBehaviour : MonoBehaviour
{
    [Sample]
    public int Value;
}</p>
<p>property.Path
(x:14.00, y:154.00, width:266.00, height:16.00) path: Value</p>
<p>OnGUIでデバッグプリント
        Debug.LogFormat("{0} path: {1}", position, property.propertyPath);</p>
<p>なるほど。次のプロパティではどうか。
    [Sample]
    public List<int> ValueArray;</int></p>
<pre class="code literal-block"><span></span><span class="k">[Sample]</span>
<span class="na">public List&lt;int&gt; ValueList;</span>
</pre>

<p>OnGUIが呼ばれぬ。プリミティブ型以外はだめなのか？
かと思いきや中身に対して呼ばれることが分かった。
配列、Listの中身に対してPropertyDrawerが呼ばれる。
(x:14.00, y:208.00, width:258.00, height:16.00) path: ValueArray.Array.data[0]
(x:14.00, y:262.00, width:258.00, height:16.00) path: ValueList.Array.data[0]</p>
<p>Serializable class
public enum IngredientUnit { Spoon, Cup, Bowl, Piece }</p>
<p>// Custom serializable class
[Serializable]
public class Ingredient
{
    [Sample]
    public string name;</p>
<pre class="code literal-block"><span></span><span class="k">[Sample]</span>
<span class="na">public int amount</span> <span class="o">=</span> <span class="s">1;</span>

<span class="k">[Sample]</span>
<span class="na">public IngredientUnit unit;</span>
</pre>

<p>}</p>
<pre class="code literal-block"><span></span>public Ingredient ingredient;

public List&lt;Ingredient&gt; ingredientList;
</pre>

<p>(x:14.00, y:298.00, width:258.00, height:16.00) path: ingredient.name
(x:14.00, y:406.00, width:258.00, height:16.00) path: ingredientList.Array.data[0].name</p>
<p>CustomEditor
デフォルトと同じ挙動。DrawDefaultInspector()の前後にボタンを追加したりできる。
[CustomEditor(typeof(SampleBehaviour))]
public class ObjectGeneratorEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();
    }
}</p>
<p>SerializedObjectのPropertyを列挙してみる
    public override void OnInspectorGUI()
    {
        serializedObject.Update();</p>
<pre class="code literal-block"><span></span>    var it = serializedObject.GetIterator();
    bool hasNext = it.NextVisible(true);
    while(hasNext)
    {
        //Debug.Log(it.propertyPath);
        var expand = EditorGUILayout.PropertyField(it, false);
        hasNext=it.NextVisible(expand);
    }

    serializedObject.ApplyModifiedProperties();
}
</pre>

<p>EditorGUIの関数はpositionが必要
EditorGUILayoutはposition無用。</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2016/01/23/webpack/" class="u-url">WebPackやってみる</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2016/01/23/webpack/" rel="bookmark">
            <time class="published dt-published" datetime="2016-01-23T00:00:00+09:00" itemprop="datePublished" title="2016-01-23 00:00">2016-01-23 00:00</time></a>
            </p>
                        <p class="commentline">
        
    <a href="posts/2016/01/23/webpack/#disqus_thread" data-disqus-identifier="cache/content/posts/2016/01/23/webpack.html">コメント</a>


                </p>
</div>
            </header><div class="e-content entry-content">
                    <div>
<p>gulpだけでいっぱいいっぱいだったので敬遠していたwebpackをやってみる。</p>
<h2>ことはじめ</h2>
<p>http://webpack.github.io/docs/</p>
<p>http://webpack.github.io/docs/tutorials/getting-started/</p>
<p>webpackをインストールして</p>
<blockquote>
<p>npm install webpack -g</p>
</blockquote>
<p>サンプルファイルを用意して
entry.js
document.write("It works.");</p>
<p>webpack実行。</p>
<blockquote>
<p>webpack ./entry.js bundle.js
Hash: ca188ee5789bb780fcec
Version: webpack 1.12.12
Time: 52ms
    Asset     Size  Chunks             Chunk Names
bundle.js  1.42 kB       0  [emitted]  main
   [0] ./entry.js 28 bytes {0} [built]</p>
</blockquote>
<p>entry.jsを入力し、bundle.jsが出力される。
bundle.js
/<strong><em>*</em>*/ (function(modules) { // webpackBootstrap
/</strong><strong><em>*/    // The module cache
/</em></strong>***/    var installedModules = {};</p>
<p>/<strong><em>*</em>*/    // The require function
/</strong>****/    function <strong>webpack_require</strong>(moduleId) {</p>
<p>/<strong><em>*</em>*/        // Check if module is in cache
/</strong><strong><em>*/        if(installedModules[moduleId])
/</em></strong>***/            return installedModules[moduleId].exports;</p>
<p>/<strong><em>*</em>*/        // Create a new module (and put it into the cache)
/</strong><strong><em>*/        var module = installedModules[moduleId] = {
/</em></strong><strong><em>/            exports: {},
/</em></strong><strong><em>/            id: moduleId,
/</em></strong><strong><em>/            loaded: false
/</em></strong>***/        };</p>
<p>/<strong><em>*</em>*/        // Execute the module function
/</strong>****/        modules[moduleId].call(module.exports, module, module.exports, <strong>webpack_require</strong>);</p>
<p>/<strong><em>*</em>*/        // Flag the module as loaded
/</strong>****/        module.loaded = true;</p>
<p>/<strong><em>*</em>*/        // Return the exports of the module
/</strong><strong><em>*/        return module.exports;
/</em></strong>***/    }</p>
<p>/<strong><em>*</em>*/    // expose the modules object (<strong>webpack_modules</strong>)
/</strong>****/    <strong>webpack_require</strong>.m = modules;</p>
<p>/<strong><em>*</em>*/    // expose the module cache
/</strong>****/    <strong>webpack_require</strong>.c = installedModules;</p>
<p>/<strong><em>*</em>*/    // <strong>webpack_public_path</strong>
/</strong>****/    <strong>webpack_require</strong>.p = "";</p>
<p>/<strong><em>*</em>*/    // Load entry module and return exports
/</strong><strong><em>*/    return <strong>webpack_require</strong>(0);
/</em></strong><strong><em>/ })
/</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em>*/
/</strong><strong><em>*/ ([
/</em> 0 */
/</strong>*/ function(module, exports) {</p>
<pre class="code literal-block"><span></span>document.write("It works.");
</pre>

<p>/<strong><em>/ }
/</em></strong>***/ ]);</p>
<p>ユーティリティと合体したコードが出力された。
使う方は、bundle.jsをscriptタグで読み込むと。</p>
<script type="text/javascript" src="posts/2016/01/23/webpack/bundle.js" charset="utf-8"></script><p>複数ファイルのマージとrequire
複数ファイルの参照にrequire関数が導入される。
module.exports = "It works from content.js.";</p>
<p>document.write(require("./content.js"));</p>
<p>webpackする。</p>
<blockquote>
<p>webpack ./entry.js bundle.js
Hash: 71eea1fe067e73397ebe
Version: webpack 1.12.12
Time: 64ms
    Asset     Size  Chunks             Chunk Names
bundle.js  1.55 kB       0  [emitted]  main
   [0] ./entry.js 40 bytes {0} [built]
   [1] ./content.js 45 bytes {0} [built]</p>
</blockquote>
<p>bundle.jsが出力される。
bundle.jsの概要
(function(modules) { // webpackBootstrap</p>
<p>// 省略</p>
<pre class="code literal-block"><span></span>// Load entry module and return exports
return __webpack_require__(0);
</pre>

<p>})
/<strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><em><em>/
( /</em> 無名関数を即実行 </em>/
[
/<em> 0 </em>/
function(module, exports, <strong>webpack_require</strong>) {</p>
<pre class="code literal-block"><span></span>document.write(__webpack_require__(1));
</pre>

<p>},
/<em> 1 </em>/
function(module, exports) {</p>
<pre class="code literal-block"><span></span>// content.jsはここに
module.exports = "It works from content.js.";
</pre>

<p>}
]);</p>
<p>なるほど。自身がmodule[0]になって、requireされたファイルがmodule[1]になるのか。
css対応
WebPackは素ではjavascriptしか対応していない。cssに対応するためにloaderを導入する。</p>
<blockquote>
<p>npm install css-loader style-loader</p>
</blockquote>
<p>cssを追加して、
style.css
body {
    background: yellow;
}</p>
<p>requireする。
loader経由でrequireするには、特殊な記法を用いるらしい。
entry.js
require("!style!css!./style.css");
document.write(require("./content.js"));</p>
<p>webpack実行</p>
<blockquote>
<p>webpack ./entry.js bundle.js
Hash: c8494a414a3a1d5c8c29
Version: webpack 1.12.12
Time: 716ms
    Asset     Size  Chunks             Chunk Names
bundle.js  11.8 kB       0  [emitted]  main
   [0] ./entry.js 76 bytes {0} [built]
   [5] ./content.js 45 bytes {0} [built]
    + 4 hidden modules</p>
</blockquote>
<p>6つモジュールができたと書いてあります。
確かに、最初の無名関数への引数が6要素の配列になっている。
modules[2]にさっきのcssがjavascript化されて入っている。
/<strong><em>/ },
/</em> 2 */
/</strong>*/ function(module, exports, <strong>webpack_require</strong>) {</p>
<pre class="code literal-block"><span></span><span class="nt">exports</span> <span class="o">=</span> <span class="nt">module</span><span class="p">.</span><span class="nc">exports</span> <span class="o">=</span> <span class="nt">__webpack_require__</span><span class="o">(</span><span class="nt">3</span><span class="o">)();</span>
<span class="o">//</span> <span class="nt">imports</span>


<span class="o">//</span> <span class="nt">module</span>
<span class="nt">exports</span><span class="p">.</span><span class="nc">push</span><span class="o">(</span><span class="cp">[</span><span class="nx">module.id</span><span class="p">,</span> <span class="s2">"body {</span><span class="se">\r\n</span><span class="s2">    background: yellow;</span><span class="se">\r\n</span><span class="s2">}"</span><span class="p">,</span> <span class="s2">""</span><span class="cp">]</span><span class="o">);</span>

<span class="o">//</span> <span class="nt">exports</span>
</pre>

<p>/***/ },</p>
<p>webpackは何もかもをjavascript化してrequireするシステムなのか！？
configfile
コマンドライン引数を設定に移動。
webpack.config.js
module.exports = {
    entry: "./entry.js",
    output: {
        path: __dirname,
        filename: "bundle.js"
    },
    module: {
        loaders: [
            { test: /.css$/, loader: "style!css" }
        ]
    }
};</p>
<p>引数無しで実行できる。</p>
<blockquote>
<p>webpack
Hash: 1141db5208a3ce352fb6
Version: webpack 1.12.12
Time: 669ms
    Asset     Size  Chunks             Chunk Names
bundle.js  11.8 kB       0  [emitted]  main
   [0] ./entry.js 67 bytes {0} [built]
   [5] ./content.js 45 bytes {0} [built]
    + 4 hidden modules</p>
</blockquote>
<p>Watchモードとか開発サーバーもあるで
watchモード。</p>
<blockquote>
<p>webpack --progress --colors --watch</p>
</blockquote>
<p>dev-serverをインストール。</p>
<blockquote>
<p>npm install webpack-dev-server -g</p>
<p>webpack-dev-server --progress --colors</p>
</blockquote>
<p>http://localhost:8080 で静的なコンパイル結果を表示
http://localhost:8080/webpack-dev-server/bundle で自動リロード付き</p>
<p>gulpでがんばってwatchからbrowser-syncを構築していたのをさくっとできるね。
これはよさげ。
機能的にはブラウザ側(いわゆるフロントエンド)に特化しているぽいな。
サーバーサイドとの連携方法を探る必要がある。
browsery-syncとnodemonの連携みたいにproxyを駆使するのか。
参考</p>
<p>webpack で Node サーバー用のコードを bundle する
https://webpack.github.io/docs/webpack-dev-server.html#proxy
http://stackoverflow.com/questions/26203725/how-to-allow-for-webpack-dev-server-to-allow-entry-points-from-react-router</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2016/01/12/unity_toon/" class="u-url">UnityでToon</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2016/01/12/unity_toon/" rel="bookmark">
            <time class="published dt-published" datetime="2016-01-12T00:00:00+09:00" itemprop="datePublished" title="2016-01-12 00:00">2016-01-12 00:00</time></a>
            </p>
                        <p class="commentline">
        
    <a href="posts/2016/01/12/unity_toon/#disqus_thread" data-disqus-identifier="cache/content/posts/2016/01/12/unity_toon.html">コメント</a>


                </p>
</div>
            </header><div class="e-content entry-content">
                    <div>
<p>Toonシェーダーをやってみる。</p>
<p>メニューからインポートすると、
Assets &gt; Import Package &gt; Effects</p>
<p>Assetsが現れる。
Standard Assets/Effects/ToonShading</p>
<p>Toon/Lit
Standard Assets/Effects/ToonShadingのshaderを自分のフォルダにコピーして改造する。</p>
<h2>UsePassを展開して改造準備</h2>
<p>Shader "MyToon/Lit Outline" {
    Properties {
        _Color ("Main Color", Color) = (0.5,0.5,0.5,1)
        _OutlineColor ("Outline Color", Color) = (0,0,0,1)
        _Outline ("Outline width", Range (.002, 0.03)) = .005
        _MainTex ("Base (RGB)", 2D) = "white" {}
        _Ramp ("Toon Ramp (RGB)", 2D) = "gray" {} 
    }</p>
<pre class="code literal-block"><span></span>SubShader {
    Tags { "RenderType"="Opaque" }
    UsePass "Toon/Lit/FORWARD"
    UsePass "Toon/Basic Outline/OUTLINE"
}

Fallback "Toon/Lit"
</pre>

<p>}</p>
<p>Toon/Litのinspectorの
Surface shader: Show generated code</p>
<p>から該当するFORWARD Passをコピペし、
Toon/Basic OutlineのOUTLINE Passをコピペする。
適当に整理する。
Shader "MyToon/Custom"
{
    Properties
    {
        _Color("Main Color", Color) = (0.5,0.5,0.5,1)
        _MainTex("Base (RGB)", 2D) = "white" {}
        _Ramp("Toon Ramp (RGB)", 2D) = "gray" {}</p>
<pre class="code literal-block"><span></span>    _OutlineColor("Outline Color", Color) = (0,0,0,1)
    _Outline("Outline width", Range(.002, 0.03)) = .005
}
SubShader
{
    Tags { "RenderType"="Opaque" }
    LOD 100

    // ---- forward rendering base pass:
    Pass{
        Name "FORWARD"
        Tags{ "LightMode" = "ForwardBase" }

        CGPROGRAM
</pre>

<h2>pragma vertex vert_surf</h2>
<h2>pragma fragment frag_surf</h2>
<h2>pragma lighting ToonRamp exclude_path:prepass</h2>
<h2>pragma multi_compile_fog</h2>
<h2>pragma multi_compile_fwdbase</h2>
<h2>include "Custom.cginc"</h2>
<pre class="code literal-block"><span></span>        ENDCG
    }

    // outline
    Pass{
        Name "OUTLINE"
        Tags{ "LightMode" = "Always" }
        Cull Front
        ZWrite On
        ColorMask RGB
        Blend SrcAlpha OneMinusSrcAlpha

        CGPROGRAM
</pre>

<h2>pragma vertex vert</h2>
<h2>pragma fragment frag</h2>
<h2>pragma multi_compile_fog</h2>
<h2>pragma multi_compile_fwdbase</h2>
<h2>include "Custom.cginc"</h2>
<pre class="code literal-block"><span></span>        ENDCG
    }
}

// for shadow etc...
Fallback "Diffuse"
</pre>

<p>}</p>
<p>*.shaderファイルのインデントが扱いずらいのでcgincと分割して手で整形。
気持ちよくindentできるエディタを見繕う必要があるな・・・
Custom.cginc</p>
<h2>include "HLSLSupport.cginc"</h2>
<h2>include "UnityShaderVariables.cginc"</h2>
<p>// Surface shader code generated based on:
// writes to per-pixel normal: no
// writes to emission: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: no
// needs world space view direction for lighting: no
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: no
// reads from normal: no
// 1 texcoords actually used
//   float2 _MainTex</p>
<h2>define UNITY_PASS_FORWARDBASE</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>include "Lighting.cginc"</h2>
<h2>include "AutoLight.cginc"</h2>
<h2>define INTERNAL_DATA</h2>
<h2>define WorldReflectionVector(data,normal) data.worldRefl</h2>
<h2>define WorldNormalVector(data,normal) normal</h2>
<p>// Original surface shader snippet:</p>
<h2>line 10 ""</h2>
<h2>ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING</h2>
<h2>endif</h2>
<p>//#pragma surface surf ToonRamp</p>
<p>sampler2D _Ramp;</p>
<p>// custom lighting function that uses a texture ramp based
// on angle between light direction and normal
//#pragma lighting ToonRamp exclude_path:prepass
inline half4 LightingToonRamp(SurfaceOutput s, half3 lightDir, half atten)
{</p>
<h2>ifndef USING_DIRECTIONAL_LIGHT</h2>
<pre class="code literal-block"><span></span>lightDir = normalize(lightDir);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>half d = dot(s.Normal, lightDir)*0.5 + 0.5;
half3 ramp = tex2D(_Ramp, float2(d, d)).rgb;

half4 c;
c.rgb = s.Albedo * _LightColor0.rgb * ramp * (atten * 2);
c.a = 0;
return c;
</pre>

<p>}</p>
<p>sampler2D _MainTex;
float4 _Color;</p>
<p>struct Input {
    float2 uv_MainTex : TEXCOORD0;
};</p>
<p>void surf(Input IN, inout SurfaceOutput o) {
    half4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
    o.Albedo = c.rgb;
    o.Alpha = c.a;
}</p>
<p>// vertex-to-fragment interpolation data
// no lightmaps:</p>
<h2>ifdef LIGHTMAP_OFF</h2>
<p>struct v2f_surf {
    float4 pos : SV_POSITION;
    float2 pack0 : TEXCOORD0; // _MainTex
    half3 worldNormal : TEXCOORD1;
    fixed3 vlight : TEXCOORD2; // ambient/SH/vertexlights
    SHADOW_COORDS(3)
        UNITY_FOG_COORDS(4)</p>
<h2>if SHADER_TARGET &gt;= 30</h2>
<pre class="code literal-block"><span></span>    float4 lmap : TEXCOORD5;
</pre>

<h2>endif</h2>
<p>};</p>
<h2>endif</h2>
<p>// with lightmaps:</p>
<h2>ifndef LIGHTMAP_OFF</h2>
<p>struct v2f_surf {
    float4 pos : SV_POSITION;
    float2 pack0 : TEXCOORD0; // _MainTex
    half3 worldNormal : TEXCOORD1;
    float4 lmap : TEXCOORD2;
    SHADOW_COORDS(3)
        UNITY_FOG_COORDS(4)</p>
<h2>ifdef DIRLIGHTMAP_COMBINED</h2>
<pre class="code literal-block"><span></span>    fixed3 tSpace0 : TEXCOORD5;
fixed3 tSpace1 : TEXCOORD6;
fixed3 tSpace2 : TEXCOORD7;
</pre>

<h2>endif</h2>
<p>};</p>
<h2>endif</h2>
<p>float4 _MainTex_ST;</p>
<p>// vertex shader
v2f_surf vert_surf(appdata_full v) {
    v2f_surf o;
    UNITY_INITIALIZE_OUTPUT(v2f_surf, o);
    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
    o.pack0.xy = TRANSFORM_TEX(v.texcoord, _MainTex);
    float3 worldPos = mul(_Object2World, v.vertex).xyz;
    fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</p>
<h2>if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)</h2>
<pre class="code literal-block"><span></span>fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
</pre>

<h2>endif</h2>
<h2>if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)</h2>
<pre class="code literal-block"><span></span>o.tSpace0 = fixed3(worldTangent.x, worldBinormal.x, worldNormal.x);
o.tSpace1 = fixed3(worldTangent.y, worldBinormal.y, worldNormal.y);
o.tSpace2 = fixed3(worldTangent.z, worldBinormal.z, worldNormal.z);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>o.worldNormal = worldNormal;
</pre>

<h2>ifndef DYNAMICLIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
</pre>

<h2>endif</h2>
<h2>ifndef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>// SH/ambient and vertex lights
</pre>

<h2>ifdef LIGHTMAP_OFF</h2>
<h2>if UNITY_SHOULD_SAMPLE_SH</h2>
<pre class="code literal-block"><span></span>float3 shlight = ShadeSH9(float4(worldNormal, 1.0));
o.vlight = shlight;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>o.vlight = 0.0;
</pre>

<h2>endif</h2>
<h2>ifdef VERTEXLIGHT_ON</h2>
<pre class="code literal-block"><span></span>o.vlight += Shade4PointLights(
        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
        unity_4LightAtten0, worldPos, worldNormal);
</pre>

<h2>endif // VERTEXLIGHT_ON</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>TRANSFER_SHADOW(o); // pass shadow coordinates to pixel shader
UNITY_TRANSFER_FOG(o, o.pos); // pass fog coordinates to pixel shader
return o;
</pre>

<p>}</p>
<p>// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target{
    // prepare and unpack data
    Input surfIN;
    UNITY_INITIALIZE_OUTPUT(Input,surfIN);
    surfIN.uv_MainTex.x = 1.0;
    surfIN.uv_MainTex = IN.pack0.xy;
    float3 lightDir = _WorldSpaceLightPos0.xyz;</p>
<h2>ifdef UNITY_COMPILER_HLSL</h2>
<pre class="code literal-block"><span></span>SurfaceOutput o = (SurfaceOutput)0;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>SurfaceOutput o;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>o.Albedo = 0.0;
o.Emission = 0.0;
o.Specular = 0.0;
o.Alpha = 0.0;
o.Gloss = 0.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = IN.worldNormal;
normalWorldVertex = IN.worldNormal;

// call surface function
surf(surfIN, o);

// compute lighting &amp; shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
    fixed4 c = 0;
</pre>

<h2>ifdef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>c.rgb += o.Albedo * IN.vlight;
</pre>

<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>// lightmaps
</pre>

<h2>ifndef LIGHTMAP_OFF</h2>
<h2>ifdef DIRLIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>// single lightmap
fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);
fixed3 lm = DecodeLightmap(lmtex);
</pre>

<h2>elif DIRLIGHTMAP_COMBINED</h2>
<pre class="code literal-block"><span></span>// directional lightmaps
fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);
half3 lm = DecodeLightmap(lmtex);
</pre>

<h2>elif DIRLIGHTMAP_SEPARATE</h2>
<pre class="code literal-block"><span></span>// directional with specular - no support
half4 lmtex = 0;
half3 lm = 0;
</pre>

<h2>endif // DIRLIGHTMAP_OFF</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>// realtime lighting: call lighting function
</pre>

<h2>ifdef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>c += LightingToonRamp(o, lightDir, atten);
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>c.a = o.Alpha;
</pre>

<h2>endif</h2>
<h2>ifndef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>// combine lightmaps with realtime shadows
</pre>

<h2>ifdef SHADOWS_SCREEN</h2>
<h2>if defined(UNITY_NO_RGBM)</h2>
<pre class="code literal-block"><span></span>c.rgb += o.Albedo * min(lm, atten * 2);
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>c.rgb += o.Albedo * max(min(lm,(atten * 2)*lmtex.rgb), lm*atten);
</pre>

<h2>endif</h2>
<h2>else // SHADOWS_SCREEN</h2>
<pre class="code literal-block"><span></span>c.rgb += o.Albedo * lm;
</pre>

<h2>endif // SHADOWS_SCREEN</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<h2>ifndef DYNAMICLIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);
c.rgb += o.Albedo * DecodeRealtimeLightmap(dynlmtex);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UNITY_APPLY_FOG(IN.fogCoord, c); // apply fog
UNITY_OPAQUE_ALPHA(c.a);
return c;
</pre>

<p>}</p>
<p>//////////////////////////////////////////////////////////////////////////////
// outline
//////////////////////////////////////////////////////////////////////////////</p>
<h2>include "UnityCG.cginc"</h2>
<p>struct appdata {
    float4 vertex : POSITION;
    float3 normal : NORMAL;
};</p>
<p>struct v2f {
    float4 pos : SV_POSITION;
    UNITY_FOG_COORDS(0)
        fixed4 color : COLOR;
};</p>
<p>uniform float _Outline;
uniform float4 _OutlineColor;</p>
<p>v2f vert(appdata v) {
    v2f o;
    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</p>
<pre class="code literal-block"><span></span>float3 norm = normalize(mul((float3x3)UNITY_MATRIX_IT_MV, v.normal));
float2 offset = TransformViewToProjection(norm.xy);

o.pos.xy += offset * o.pos.z * _Outline;
o.color = _OutlineColor;
UNITY_TRANSFER_FOG(o, o.pos);
return o;
</pre>

<p>}</p>
<p>fixed4 frag(v2f i) : SV_Target
{
    UNITY_APPLY_FOG(i.fogCoord, i.color);
    return i.color;
}</p>
<p>改造準備完了。
改造した</p>
<p>alpha blending
影と陰の合成とRampの適用法を改造</p>
<p>なかなか難しい。
顔は別光源にして影が落ちないようにする必要があるね。
顔にDiffuseは必要ない。</p>
<h2>include "HLSLSupport.cginc"</h2>
<h2>include "UnityShaderVariables.cginc"</h2>
<p>// Surface shader code generated based on:
// writes to per-pixel normal: no
// writes to emission: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: no
// needs world space view direction for lighting: no
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: no
// reads from normal: no
// 1 texcoords actually used
//   float2 _MainTex</p>
<h2>define UNITY_PASS_FORWARDBASE</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>include "Lighting.cginc"</h2>
<h2>include "AutoLight.cginc"</h2>
<h2>define INTERNAL_DATA</h2>
<h2>define WorldReflectionVector(data,normal) data.worldRefl</h2>
<h2>define WorldNormalVector(data,normal) normal</h2>
<p>// Original surface shader snippet:</p>
<h2>line 10 ""</h2>
<h2>ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING</h2>
<h2>endif</h2>
<p>//#pragma surface surf ToonRamp</p>
<p>sampler2D _Ramp;</p>
<p>// custom lighting function that uses a texture ramp based
// on angle between light direction and normal
//#pragma lighting ToonRamp exclude_path:prepass
inline half3 LightingToonRamp(half3 rgb, half diffuse, half atten)
{
    float d = min(diffuse, atten);
    float3 ramp = tex2D(_Ramp, float2(d, d));
    return rgb * ramp;
}</p>
<p>sampler2D _MainTex;
float4 _Color;</p>
<p>struct Input {
    float2 uv_MainTex : TEXCOORD0;
};</p>
<p>void surf(Input IN, inout SurfaceOutput o) {
    half4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
    o.Albedo = c.rgb;
    o.Alpha = c.a;
}</p>
<p>// vertex-to-fragment interpolation data
// no lightmaps:</p>
<h2>ifdef LIGHTMAP_OFF</h2>
<p>struct v2f_surf {
    float4 pos : SV_POSITION;
    float2 pack0 : TEXCOORD0; // _MainTex
    half3 worldNormal : TEXCOORD1;
    fixed3 vlight : TEXCOORD2; // ambient/SH/vertexlights
    SHADOW_COORDS(3)
        UNITY_FOG_COORDS(4)</p>
<h2>if SHADER_TARGET &gt;= 30</h2>
<pre class="code literal-block"><span></span>    float4 lmap : TEXCOORD5;
</pre>

<h2>endif</h2>
<p>};</p>
<h2>endif</h2>
<p>// with lightmaps:</p>
<h2>ifndef LIGHTMAP_OFF</h2>
<p>struct v2f_surf {
    float4 pos : SV_POSITION;
    float2 pack0 : TEXCOORD0; // _MainTex
    half3 worldNormal : TEXCOORD1;
    float4 lmap : TEXCOORD2;
    SHADOW_COORDS(3)
        UNITY_FOG_COORDS(4)</p>
<h2>ifdef DIRLIGHTMAP_COMBINED</h2>
<pre class="code literal-block"><span></span>    fixed3 tSpace0 : TEXCOORD5;
fixed3 tSpace1 : TEXCOORD6;
fixed3 tSpace2 : TEXCOORD7;
</pre>

<h2>endif</h2>
<p>};</p>
<h2>endif</h2>
<p>float4 _MainTex_ST;</p>
<p>// vertex shader
v2f_surf vert_surf(appdata_full v) {
    v2f_surf o;
    UNITY_INITIALIZE_OUTPUT(v2f_surf, o);
    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
    o.pack0.xy = TRANSFORM_TEX(v.texcoord, _MainTex);
    float3 worldPos = mul(_Object2World, v.vertex).xyz;
    fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</p>
<h2>if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)</h2>
<pre class="code literal-block"><span></span>fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
</pre>

<h2>endif</h2>
<h2>if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)</h2>
<pre class="code literal-block"><span></span>o.tSpace0 = fixed3(worldTangent.x, worldBinormal.x, worldNormal.x);
o.tSpace1 = fixed3(worldTangent.y, worldBinormal.y, worldNormal.y);
o.tSpace2 = fixed3(worldTangent.z, worldBinormal.z, worldNormal.z);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>o.worldNormal = worldNormal;
</pre>

<h2>ifndef DYNAMICLIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
</pre>

<h2>endif</h2>
<h2>ifndef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>// SH/ambient and vertex lights
</pre>

<h2>ifdef LIGHTMAP_OFF</h2>
<h2>if UNITY_SHOULD_SAMPLE_SH</h2>
<pre class="code literal-block"><span></span>float3 shlight = ShadeSH9(float4(worldNormal, 1.0));
o.vlight = shlight;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>o.vlight = 0.0;
</pre>

<h2>endif</h2>
<h2>ifdef VERTEXLIGHT_ON</h2>
<pre class="code literal-block"><span></span>o.vlight += Shade4PointLights(
        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
        unity_4LightAtten0, worldPos, worldNormal);
</pre>

<h2>endif // VERTEXLIGHT_ON</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>TRANSFER_SHADOW(o); // pass shadow coordinates to pixel shader
UNITY_TRANSFER_FOG(o, o.pos); // pass fog coordinates to pixel shader
return o;
</pre>

<p>}</p>
<p>// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target{
    // prepare and unpack data
    Input surfIN;
    UNITY_INITIALIZE_OUTPUT(Input,surfIN);
    surfIN.uv_MainTex.x = 1.0;
    surfIN.uv_MainTex = IN.pack0.xy;
    float3 lightDir = _WorldSpaceLightPos0.xyz;</p>
<h2>ifdef UNITY_COMPILER_HLSL</h2>
<pre class="code literal-block"><span></span>SurfaceOutput o = (SurfaceOutput)0;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>SurfaceOutput o;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>o.Albedo = 0.0;
o.Emission = 0.0;
o.Specular = 0.0;
o.Alpha = 0.0;
o.Gloss = 0.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = IN.worldNormal;
normalWorldVertex = IN.worldNormal;

// call surface function
surf(surfIN, o);

// compute lighting &amp; shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
    fixed4 c = 0;
</pre>

<h2>ifdef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>c.rgb += o.Albedo * IN.vlight;
</pre>

<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>// lightmaps
</pre>

<h2>ifndef LIGHTMAP_OFF</h2>
<h2>ifdef DIRLIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>// single lightmap
fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);
fixed3 lm = DecodeLightmap(lmtex);
</pre>

<h2>elif DIRLIGHTMAP_COMBINED</h2>
<pre class="code literal-block"><span></span>// directional lightmaps
fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);
half3 lm = DecodeLightmap(lmtex);
</pre>

<h2>elif DIRLIGHTMAP_SEPARATE</h2>
<pre class="code literal-block"><span></span>// directional with specular - no support
half4 lmtex = 0;
half3 lm = 0;
</pre>

<h2>endif // DIRLIGHTMAP_OFF</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>// realtime lighting: call lighting function
c.a = o.Alpha;
</pre>

<h2>ifdef LIGHTMAP_OFF</h2>
<h2>ifndef USING_DIRECTIONAL_LIGHT</h2>
<pre class="code literal-block"><span></span>lightDir = normalize(lightDir);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>half diffuse = max(0, dot(o.Normal, lightDir));
c.rgb += LightingToonRamp(o.Albedo, diffuse, atten);
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>// combine lightmaps with realtime shadows
</pre>

<h2>ifdef SHADOWS_SCREEN</h2>
<h2>if defined(UNITY_NO_RGBM)</h2>
<pre class="code literal-block"><span></span>c.rgb += o.Albedo * min(lm, atten * 2);
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>c.rgb += o.Albedo * max(min(lm,(atten * 2)*lmtex.rgb), lm*atten);
</pre>

<h2>endif</h2>
<h2>else // SHADOWS_SCREEN</h2>
<pre class="code literal-block"><span></span>c.rgb += o.Albedo * lm;
</pre>

<h2>endif // SHADOWS_SCREEN</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<h2>ifndef DYNAMICLIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);
c.rgb += o.Albedo * DecodeRealtimeLightmap(dynlmtex);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UNITY_APPLY_FOG(IN.fogCoord, c); // apply fog

return c;
</pre>

<p>}</p>
<p>//////////////////////////////////////////////////////////////////////////////
// outline
//////////////////////////////////////////////////////////////////////////////</p>
<h2>include "UnityCG.cginc"</h2>
<p>struct appdata {
    float4 vertex : POSITION;
    float3 normal : NORMAL;
};</p>
<p>struct v2f {
    float4 pos : SV_POSITION;
    UNITY_FOG_COORDS(0)
        fixed4 color : COLOR;
};</p>
<p>uniform float _Outline;
uniform float4 _OutlineColor;</p>
<p>v2f vert(appdata v) {
    v2f o;
    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</p>
<pre class="code literal-block"><span></span>float3 norm = normalize(mul((float3x3)UNITY_MATRIX_IT_MV, v.normal));
float2 offset = TransformViewToProjection(norm.xy);

o.pos.xy += offset * min(1, o.pos.z) * _Outline; // 太さ調整
o.color = _OutlineColor;
UNITY_TRANSFER_FOG(o, o.pos);
return o;
</pre>

<p>}</p>
<p>fixed4 frag(v2f i) : SV_Target
{
    UNITY_APPLY_FOG(i.fogCoord, i.color);
    return i.color;
}</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2016/01/11/unity_write_shader/" class="u-url">UnityのShaderを書いてみる</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2016/01/11/unity_write_shader/" rel="bookmark">
            <time class="published dt-published" datetime="2016-01-11T00:00:00+09:00" itemprop="datePublished" title="2016-01-11 00:00">2016-01-11 00:00</time></a>
            </p>
                        <p class="commentline">
        
    <a href="posts/2016/01/11/unity_write_shader/#disqus_thread" data-disqus-identifier="cache/content/posts/2016/01/11/unity_write_shader.html">コメント</a>


                </p>
</div>
            </header><div class="e-content entry-content">
                    <div>
<p>アルファブレンディング
シャドウキャスター
シャドウレシーバー</p>
<p>なシェーダー。</p>
<p>基本
新規作成
Create -&gt; Shader -&gt; UnLitShader
CustomShader</p>
<p>Shader "CustomShader"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 100</p>
<pre class="code literal-block"><span></span>    <span class="n">Pass</span>
    <span class="p">{</span>
        <span class="n">CGPROGRAM</span>
        <span class="cp">#pragma vertex vert</span>
        <span class="cp">#pragma fragment frag</span>
        <span class="c1">// make fog work</span>
        <span class="cp">#pragma multi_compile_fog</span>

        <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp"></span>

        <span class="k">struct</span> <span class="n">appdata</span>
        <span class="p">{</span>
            <span class="n">float4</span> <span class="nl">vertex</span> <span class="p">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="n">float2</span> <span class="nl">uv</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="n">v2f</span>
        <span class="p">{</span>
            <span class="n">float2</span> <span class="nl">uv</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
            <span class="n">UNITY_FOG_COORDS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">float4</span> <span class="nl">vertex</span> <span class="p">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
        <span class="n">float4</span> <span class="n">_MainTex_ST</span><span class="p">;</span>

        <span class="n">v2f</span> <span class="nf">vert</span> <span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
            <span class="n">o</span><span class="p">.</span><span class="n">vertex</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
            <span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
            <span class="n">UNITY_TRANSFER_FOG</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">o</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">fixed4</span> <span class="nf">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
        <span class="p">{</span>
            <span class="c1">// sample the texture</span>
            <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
            <span class="c1">// apply fog</span>
            <span class="n">UNITY_APPLY_FOG</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">fogCoord</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ENDCG</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>

<p>}</p>
<p>この時点でテクスチャが表示できるけど一度無にしよう
Shader "CustomShader"
{
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 100
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            float4 vert(float4 v:POSITION) : SV_POSITION{
                return mul(UNITY_MATRIX_MVP, v);
            }
            fixed4 frag() : COLOR{
                return fixed4(1.0,0.0,0.0,1.0);
            }
            ENDCG
        }
    }
}</p>
<p>頂点変形だけを適用して赤一色。
Color
べたにマテリアル色が出る。
Shader "CustomShader"
{
    Properties
    {
        _Color("Color", Color) = (1,1,1,1)
    }
    SubShader
    {
    Tags{ "RenderType" = "Opaque" }
    LOD 100</p>
<pre class="code literal-block"><span></span>Pass
{
    CGPROGRAM
</pre>

<h2>pragma target 3.0</h2>
<h2>pragma vertex vert</h2>
<h2>pragma fragment frag</h2>
<pre class="code literal-block"><span></span>    uniform float4 _Color;

    float4 vert(float4 v:POSITION) : SV_POSITION{
        return mul(UNITY_MATRIX_MVP, v);
    }
    fixed4 frag() : COLOR{
        return _Color;
    }
    ENDCG
}

} // SurShader
</pre>

<p>}</p>
<p>_Colorプロパティを定義して、uniform変数_Colorを宣言し使う。
Texture
テクスチャ色を乗算
Shader "CustomShader"
{
    Properties
    {
        _Color("Color", Color) = (1,1,1,1)
        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
    }
    SubShader
    {
    Tags{ "RenderType" = "Opaque" }
    LOD 100</p>
<pre class="code literal-block"><span></span>Pass
{
    CGPROGRAM
</pre>

<h2>pragma target 3.0</h2>
<h2>pragma vertex vert</h2>
<h2>pragma fragment frag</h2>
<pre class="code literal-block"><span></span>    struct appdata
    {
        float4 vertex : POSITION;
        float2 uv : TEXCOORD0;
    };
    struct v2f
    {
        float2 uv : TEXCOORD0;
        float4 vertex : SV_POSITION;
    };

    uniform float4 _Color;
    uniform sampler2D _MainTex;

    v2f vert(appdata v){
        v2f o;
        o.vertex= mul(UNITY_MATRIX_MVP, v.vertex);
        o.uv = v.uv;
        return o;
    }
    fixed4 frag(v2f i) : COLOR{
        fixed4 tex = tex2D(_MainTex, i.uv);
        return _Color * tex;
    }
    ENDCG
}

} // SurShader
</pre>

<p>}</p>
<p>シェーダーの入力に位置とUV、出力に変換済みの位置とUVが必要になったので構造体appdataとv2fを導入
_MainTexプロパティを導入し、サンプラー_MainTexを宣言してtex2D関数で使う</p>
<p>AlphaBlending
追加分
Shader "CustomShader"
{
    SubShader
    {
    // 背景を含む不透明なものの後で描画する
    Tags{ "Queue" = "Transparent" }</p>
<pre class="code literal-block"><span></span>Pass
{
    Blend SrcAlpha OneMinusSrcAlpha
}

} // SurShader
</pre>

<p>}</p>
<p>ここまでで照明の無い基本的なシェーダーができる。
UnityCG.cgincを使う
最初に新規作成したShaderにAplhaBlendingを追加した感じ。
uniform変数のuniformは省略できる。
Shader "CustomShader"
{
    Properties
    {
        _Color("Color", Color) = (1,1,1,1)
        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
    }
    SubShader
    {
        Tags{ "Queue" = "Transparent" }
        LOD 100</p>
<pre class="code literal-block"><span></span><span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>

    <span class="n">CGPROGRAM</span>
    <span class="cp">#pragma target 3.0</span>
    <span class="cp">#pragma vertex vert</span>
    <span class="cp">#pragma fragment frag</span>

    <span class="c1">// make fog work</span>
    <span class="cp">#pragma multi_compile_fog</span>

    <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp"></span>

    <span class="k">struct</span> <span class="n">appdata</span>
    <span class="p">{</span>
        <span class="n">float4</span> <span class="nl">vertex</span> <span class="p">:</span> <span class="n">POSITION</span><span class="p">;</span>
        <span class="n">float2</span> <span class="nl">uv</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="n">v2f</span>
    <span class="p">{</span>
        <span class="n">float2</span> <span class="nl">uv</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
        <span class="n">UNITY_FOG_COORDS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">float4</span> <span class="nl">vertex</span> <span class="p">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">float4</span> <span class="n">_Color</span><span class="p">;</span>
    <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">_MainTex_ST</span><span class="p">;</span>

    <span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
        <span class="n">o</span><span class="p">.</span><span class="n">vertex</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
        <span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
        <span class="n">UNITY_TRANSFER_FOG</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">o</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="c1">// sample the texture</span>
        <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
        <span class="c1">// apply fog</span>
        <span class="n">UNITY_APPLY_FOG</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">fogCoord</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">col</span> <span class="o">*</span> <span class="n">_Color</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// SurShader</span>
</pre>

<p>}</p>
<p>Lighting導入
Vertex and Fragment Shader Examplesの後半Calculating Lighting
を参考にライティングをやってみる。
forward rendringを使うことで</p>
<p>DirectionalLight
ambient
lightmap
reflections</p>
<p>を扱える。
Tags {"LightMode"="ForwardBase"}</p>
<p>を定義することでUnityの組み込み変数を通じて上記のシーンのライティング情報を得ることができるようになる。
頂点ライティングによるDiffuse &amp; Ambient</p>
<p>DirectionalLightによるDiffuse計算
appdata_base導入(UnityCG.cgincで定義)
v2fにdiffuse追加
vertでdiffuse計算</p>
<p>Shader "CustomShader"
{
    Properties
    {
        _Color("Color", Color) = (1,1,1,1)
        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
    }
    SubShader
    {
        Tags{ "Queue" = "Transparent" }
        LOD 100</p>
<pre class="code literal-block"><span></span><span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">Tags</span><span class="p">{</span> <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardBase"</span> <span class="p">}</span>

    <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>

    <span class="n">CGPROGRAM</span>
    <span class="cp">#pragma target 3.0</span>
    <span class="cp">#pragma vertex vert</span>
    <span class="cp">#pragma fragment frag</span>

    <span class="c1">// make fog work</span>
    <span class="cp">#pragma multi_compile_fog</span>

    <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">"UnityLightingCommon.cginc" // for _LightColor0</span><span class="cp"></span>

    <span class="k">struct</span> <span class="n">v2f</span>
    <span class="p">{</span>
        <span class="n">float2</span> <span class="nl">uv</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
        <span class="n">fixed4</span> <span class="nl">diffuse</span> <span class="p">:</span> <span class="n">COLOR0</span><span class="p">;</span> <span class="c1">// diffuse lighting color</span>
        <span class="n">float4</span> <span class="nl">vertex</span> <span class="p">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
        <span class="n">UNITY_FOG_COORDS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="n">uniform</span> <span class="n">float4</span> <span class="n">_Color</span><span class="p">;</span>
    <span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">_MainTex_ST</span><span class="p">;</span>

    <span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata_base</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
        <span class="n">o</span><span class="p">.</span><span class="n">vertex</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
        <span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">texcoord</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>

        <span class="c1">// get vertex normal in world space</span>
        <span class="n">half3</span> <span class="n">worldNormal</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="c1">// dot product between normal and light direction for</span>
        <span class="c1">// standard diffuse (Lambert) lighting</span>
        <span class="n">half</span> <span class="n">nl</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">worldNormal</span><span class="p">,</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>
        <span class="c1">// factor in the light color</span>
        <span class="n">o</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">nl</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">;</span>

        <span class="c1">// the only difference from previous shader:</span>
        <span class="c1">// in addition to the diffuse lighting from the main light,</span>
        <span class="c1">// add illumination from ambient or light probes</span>
        <span class="c1">// ShadeSH9 function from UnityCG.cginc evaluates it,</span>
        <span class="c1">// using world space normal</span>
        <span class="n">o</span><span class="p">.</span><span class="n">diffuse</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="n">half4</span><span class="p">(</span><span class="n">worldNormal</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>

        <span class="n">UNITY_TRANSFER_FOG</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">o</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="c1">// sample the texture</span>
        <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">)</span> <span class="o">*</span> <span class="n">_Color</span><span class="p">;</span>
        <span class="c1">// apply fog</span>
        <span class="n">UNITY_APPLY_FOG</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">fogCoord</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
        <span class="n">col</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*=</span> <span class="n">i</span><span class="p">.</span><span class="n">diffuse</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// SurShader</span>
</pre>

<p>}</p>
<p>Shadowキャスティング
ShadowMapに深度を描画するPassを追加する。
簡単なのは下記。
// pull in shadow caster from VertexLit built-in shader
UsePass "Legacy Shaders/VertexLit/SHADOWCASTER"</p>
<p>手作りもできる。</p>
<p>pragma multi_compile_shadowcasterがポイント</p>
<pre class="code literal-block"><span></span><span class="c1">// shadow caster rendering pass, implemented manually</span>
<span class="c1">// using macros from UnityCG.cginc</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">Tags</span><span class="p">{</span> <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ShadowCaster"</span> <span class="p">}</span>

    <span class="n">CGPROGRAM</span>
    <span class="cp">#pragma vertex vert</span>
    <span class="cp">#pragma fragment frag</span>
    <span class="cp">#pragma multi_compile_shadowcaster</span>
    <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp"></span>

    <span class="k">struct</span> <span class="n">v2f</span> <span class="p">{</span>
        <span class="n">V2F_SHADOW_CASTER</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata_base</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
        <span class="n">TRANSFER_SHADOW_CASTER_NORMALOFFSET</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">float4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="n">SHADOW_CASTER_FRAGMENT</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>
</pre>

<p>ShadowReceiveing</p>
<p>pragma multi_compile_fwdbaseがポイント</p>
<p>Shader "CustomShader"
{
    Properties
    {
        _Color("Color", Color) = (1,1,1,1)
        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
    }
    SubShader
    {
    Tags{ "Queue" = "Geometry" }
    LOD 100</p>
<pre class="code literal-block"><span></span><span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">Tags</span><span class="p">{</span> <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardBase"</span> <span class="s">"IgnoreProjector"</span> <span class="o">=</span> <span class="s">"True"</span> <span class="s">"PerformanceChecks"</span> <span class="o">=</span> <span class="s">"False"</span> <span class="p">}</span>
    <span class="n">ZWrite</span> <span class="n">On</span>
    <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>

    <span class="n">CGPROGRAM</span>
    <span class="cp">#pragma target 3.0</span>
    <span class="cp">#pragma vertex vert</span>
    <span class="cp">#pragma fragment frag</span>

    <span class="c1">// make fog work</span>
    <span class="cp">#pragma multi_compile_fog</span>

    <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">"UnityLightingCommon.cginc" // for _LightColor0</span><span class="cp"></span>

    <span class="c1">// compile shader into multiple variants, with and without shadows</span>
    <span class="c1">// (we don't care about any lightmaps yet, so skip these variants)</span>
    <span class="cp">#pragma multi_compile_fwdbase nolightmap nodirlightmap nodynlightmap novertexlight</span>
    <span class="c1">// shadow helper functions and macros</span>
    <span class="cp">#include</span> <span class="cpf">"AutoLight.cginc"</span><span class="cp"></span>

    <span class="k">struct</span> <span class="n">v2f</span>
    <span class="p">{</span>
        <span class="n">float2</span> <span class="nl">uv</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
        <span class="n">float4</span> <span class="nl">pos</span> <span class="p">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
        <span class="n">fixed4</span> <span class="nl">diff</span> <span class="p">:</span> <span class="n">COLOR0</span><span class="p">;</span> <span class="c1">// diffuse lighting color</span>
        <span class="n">fixed3</span> <span class="nl">ambient</span> <span class="p">:</span> <span class="n">COLOR1</span><span class="p">;</span>
        <span class="n">SHADOW_COORDS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// put shadows data into TEXCOORD1</span>
        <span class="n">UNITY_FOG_COORDS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="n">uniform</span> <span class="n">float4</span> <span class="n">_Color</span><span class="p">;</span>
    <span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">_MainTex_ST</span><span class="p">;</span>

    <span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata_base</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
        <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
        <span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">texcoord</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>

        <span class="c1">// get vertex normal in world space</span>
        <span class="n">half3</span> <span class="n">worldNormal</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
        <span class="c1">// dot product between normal and light direction for</span>
        <span class="c1">// standard diffuse (Lambert) lighting</span>
        <span class="n">half</span> <span class="n">nl</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">worldNormal</span><span class="p">,</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>
        <span class="c1">// factor in the light color</span>
        <span class="n">o</span><span class="p">.</span><span class="n">diff</span> <span class="o">=</span> <span class="n">nl</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">;</span>

        <span class="c1">// the only difference from previous shader:</span>
        <span class="c1">// in addition to the diffuse lighting from the main light,</span>
        <span class="c1">// add illumination from ambient or light probes</span>
        <span class="c1">// ShadeSH9 function from UnityCG.cginc evaluates it,</span>
        <span class="c1">// using world space normal</span>
        <span class="n">o</span><span class="p">.</span><span class="n">ambient</span> <span class="o">=</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="n">half4</span><span class="p">(</span><span class="n">worldNormal</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

        <span class="c1">// compute shadows data</span>
        <span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="n">UNITY_TRANSFER_FOG</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">o</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="c1">// sample the texture</span>
        <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">)</span> <span class="o">*</span> <span class="n">_Color</span><span class="p">;</span>

        <span class="n">fixed</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="c1">// darken light's illumination with shadow, keep ambient intact</span>
        <span class="n">fixed3</span> <span class="n">lighting</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">diff</span> <span class="o">*</span> <span class="n">shadow</span> <span class="o">+</span> <span class="n">i</span><span class="p">.</span><span class="n">ambient</span><span class="p">;</span>
        <span class="n">col</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*=</span> <span class="n">lighting</span><span class="p">;</span>

        <span class="c1">// apply fog</span>
        <span class="n">UNITY_APPLY_FOG</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">fogCoord</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>

<span class="c1">// shadow caster rendering pass, implemented manually</span>
<span class="c1">// using macros from UnityCG.cginc</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">Tags</span><span class="p">{</span> <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ShadowCaster"</span> <span class="p">}</span>

    <span class="n">CGPROGRAM</span>
    <span class="cp">#pragma vertex vert</span>
    <span class="cp">#pragma fragment frag</span>
    <span class="cp">#pragma multi_compile_shadowcaster</span>
    <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp"></span>

    <span class="k">struct</span> <span class="n">v2f</span> <span class="p">{</span>
        <span class="n">V2F_SHADOW_CASTER</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata_base</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
        <span class="n">TRANSFER_SHADOW_CASTER_NORMALOFFSET</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">float4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="n">SHADOW_CASTER_FRAGMENT</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// SurShader</span>

<span class="n">Fallback</span> <span class="s">"Transparent/VertexLit"</span>
</pre>

<p>}</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2016/01/10/unity_shader/" class="u-url">UnityのUsePassを追う</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2016/01/10/unity_shader/" rel="bookmark">
            <time class="published dt-published" datetime="2016-01-10T00:00:00+09:00" itemprop="datePublished" title="2016-01-10 00:00">2016-01-10 00:00</time></a>
            </p>
                        <p class="commentline">
        
    <a href="posts/2016/01/10/unity_shader/#disqus_thread" data-disqus-identifier="cache/content/posts/2016/01/10/unity_shader.html">コメント</a>


                </p>
</div>
            </header><div class="e-content entry-content">
                    <div>
<p>下記のUnityの半透明シェーダーがいったいどういうメカニズムなのかを調べる。
Shaderの元ネタはこちら</p>
<p>Unity で Transparent/Diffuse で描画順が崩れてしまう際の対処法</p>
<p>Shader "Transparent/Diffuse ZWrite" {
    Properties{
        _Color("Main Color", Color) = (1,1,1,1)
        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
    }</p>
<pre class="code literal-block"><span></span>SubShader{
    Tags{ "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" }
    LOD 200

    // extra pass that renders to depth buffer only
    Pass{
        ZWrite On
        ColorMask 0
    }

    // paste in forward rendering passes from Transparent/Diffuse
    UsePass "Transparent/Diffuse/FORWARD"
}

Fallback "Transparent/VertexLit"
</pre>

<p>}</p>
<p>２パス描画になる。
パス1: 深度バッファのみの描画
Pass{
    ZWrite On
    ColorMask 0
}</p>
<p>これは、ShaderLab ：旧ライティングというものらしく
Fixed function
という機能らしい。
レガシーとか旧呼ばわりされているけどサンプルコードにしれっと出てくるので知っている必要がある。
次のようなコードが生成されていた。
ShaderのInspector: Fixed function. Show generated codeの該当部分
 Pass {
  Tags { "QUEUE"="Transparent" "IGNOREPROJECTOR"="true" "RenderType"="Transparent" }
  ColorMask 0
CGPROGRAM</p>
<h2>pragma vertex vert</h2>
<h2>pragma fragment frag</h2>
<h2>include "UnityShaderVariables.cginc"</h2>
<h2>pragma multi_compile_fog</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>define USING_FOG (defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2))</h2>
<p>// uniforms</p>
<p>// vertex shader input data
struct appdata {
  float3 pos : POSITION;
  half4 color : COLOR;
};</p>
<p>// vertex-to-fragment interpolators
struct v2f {
  fixed4 color : COLOR0;
  #if USING_FOG
    fixed fog : TEXCOORD0;
  #endif
  float4 pos : SV_POSITION;
};</p>
<p>// vertex shader
v2f vert (appdata IN) {
  v2f o;
  half4 color = IN.color;
  float3 eyePos = mul (UNITY_MATRIX_MV, float4(IN.pos,1)).xyz;
  half3 viewDir = 0.0;
  o.color = saturate(color);
  // compute texture coordinates
  // fog
  #if USING_FOG
    float fogCoord = length(eyePos.xyz); // radial fog distance
    UNITY_CALC_FOG_FACTOR(fogCoord);
    o.fog = saturate(unityFogFactor);
  #endif
  // transform position
  o.pos = mul(UNITY_MATRIX_MVP, float4(IN.pos,1));
  return o;
}</p>
<p>// fragment shader
fixed4 frag (v2f IN) : SV_Target {
  fixed4 col;
  col = IN.color;
  // fog
  #if USING_FOG
    col.rgb = lerp (unity_FogColor.rgb, col.rgb, IN.fog);
  #endif
  return col;
}
ENDCG
 }</p>
<p>単に頂点カラーをそのまま描画しているようだが、ColorMaskが0なので色は変わらずということらしい。
パス2: カラーバッファ
Transparent/Diffuse
UsePass "Transparent/Diffuse/FORWARD"</p>
<p>は何なのか。
https://unity3d.com/jp/get-unity/download/archive
からビルトインシェーダーをDownloadして観察してみる。
探してみると”Transparent/Diffuse”という名のシェーダーは無くて、
“Legacy Shaders/Transparent/Diffuse”が見つかる。
DefaultResourceExtra/Alpha-Diffuse.shader
Shader "Legacy Shaders/Transparent/Diffuse" {
Properties {
    _Color ("Main Color", Color) = (1,1,1,1)
    _MainTex ("Base (RGB) Trans (A)", 2D) = "white" {}
}</p>
<p>SubShader {
    Tags {"Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent"}
    LOD 200</p>
<p>CGPROGRAM</p>
<h2>pragma surface surf Lambert alpha:fade</h2>
<p>sampler2D _MainTex;
fixed4 _Color;</p>
<p>struct Input {
    float2 uv_MainTex;
};</p>
<p>void surf (Input IN, inout SurfaceOutput o) {
    fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
    o.Albedo = c.rgb;
    o.Alpha = c.a;
}
ENDCG
}</p>
<p>Fallback "Legacy Shaders/Transparent/VertexLit"
}</p>
<p>surfaceシェーダーらしい。
surfaceシェーダーが如何なるPassに展開されるのかがまったくわからないが(LightMode等が関係ある？)
FORWARDパスはどこで定義されているのか。
Transparent/Diffuse/FORWARD
DefaultResourcesExtra/Standard.shader
    SubShader
    {
        Tags { "RenderType"="Opaque" "PerformanceChecks"="False" }
        LOD 300</p>
<pre class="code literal-block"><span></span>    <span class="c1">// ------------------------------------------------------------------</span>
    <span class="c1">//  Base forward pass (directional light, emission, lightmaps, ...)</span>
    <span class="n">Pass</span>
    <span class="p">{</span>
        <span class="n">Name</span> <span class="s">"FORWARD"</span> 
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardBase"</span> <span class="p">}</span>

        <span class="n">Blend</span> <span class="p">[</span><span class="n">_SrcBlend</span><span class="p">]</span> <span class="p">[</span><span class="n">_DstBlend</span><span class="p">]</span>
        <span class="n">ZWrite</span> <span class="p">[</span><span class="n">_ZWrite</span><span class="p">]</span>

        <span class="n">CGPROGRAM</span>
        <span class="cp">#pragma target 3.0</span>
        <span class="c1">// TEMPORARY: GLES2.0 temporarily disabled to prevent errors spam on devices without textureCubeLodEXT</span>
        <span class="cp">#pragma exclude_renderers gles</span>

        <span class="c1">// -------------------------------------</span>

        <span class="cp">#pragma shader_feature _NORMALMAP</span>
        <span class="cp">#pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON</span>
        <span class="cp">#pragma shader_feature _EMISSION</span>
        <span class="cp">#pragma shader_feature _METALLICGLOSSMAP </span>
        <span class="cp">#pragma shader_feature ___ _DETAIL_MULX2</span>
        <span class="cp">#pragma shader_feature _PARALLAXMAP</span>

        <span class="cp">#pragma multi_compile_fwdbase</span>
        <span class="cp">#pragma multi_compile_fog</span>

        <span class="cp">#pragma vertex vertBase</span>
        <span class="cp">#pragma fragment fragBase</span>
        <span class="cp">#include</span> <span class="cpf">"UnityStandardCoreForward.cginc"</span><span class="cp"></span>

        <span class="n">ENDCG</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>

<p>vertBaseとfragBaseという関数に辿り着く。
vertBaseとfragBase
CGIncludes/UnityStandardCoreForward.cginc</p>
<h2>ifndef UNITY_STANDARD_CORE_FORWARD_INCLUDED</h2>
<h2>define UNITY_STANDARD_CORE_FORWARD_INCLUDED</h2>
<h2>if defined(UNITY_NO_FULL_STANDARD_SHADER)</h2>
<h2>define UNITY_STANDARD_SIMPLE 1</h2>
<h2>endif</h2>
<h2>include "UnityStandardConfig.cginc"</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span><span class="cp">#include</span> <span class="cpf">"UnityStandardCoreForwardSimple.cginc"</span><span class="cp"></span>
<span class="n">VertexOutputBaseSimple</span> <span class="nf">vertBase</span> <span class="p">(</span><span class="n">VertexInput</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vertForwardBaseSimple</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span>
<span class="n">VertexOutputForwardAddSimple</span> <span class="nf">vertAdd</span> <span class="p">(</span><span class="n">VertexInput</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vertForwardAddSimple</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span>
<span class="n">half4</span> <span class="nf">fragBase</span> <span class="p">(</span><span class="n">VertexOutputBaseSimple</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fragForwardBaseSimpleInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
<span class="n">half4</span> <span class="nf">fragAdd</span> <span class="p">(</span><span class="n">VertexOutputForwardAddSimple</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fragForwardAddSimpleInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span><span class="cp">#include</span> <span class="cpf">"UnityStandardCore.cginc"</span><span class="cp"></span>
<span class="n">VertexOutputForwardBase</span> <span class="nf">vertBase</span> <span class="p">(</span><span class="n">VertexInput</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vertForwardBase</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span>
<span class="n">VertexOutputForwardAdd</span> <span class="nf">vertAdd</span> <span class="p">(</span><span class="n">VertexInput</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vertForwardAdd</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span>
<span class="n">half4</span> <span class="nf">fragBase</span> <span class="p">(</span><span class="n">VertexOutputForwardBase</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fragForwardBaseInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
<span class="n">half4</span> <span class="nf">fragAdd</span> <span class="p">(</span><span class="n">VertexOutputForwardAdd</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fragForwardAddInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
</pre>

<h2>endif</h2>
<h2>endif // UNITY_STANDARD_CORE_FORWARD_INCLUDED</h2>
<p>シンプルとノットシンプルの振り分けをしている。
vertBase
    VertexOutputForwardBase vertBase (VertexInput v) { return vertForwardBase(v); }</p>
<p>CGInlucdes/UnityStandardCore.cginc
VertexOutputForwardBase vertForwardBase (VertexInput v)
{
    VertexOutputForwardBase o;
    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</p>
<pre class="code literal-block"><span></span><span class="n">float4</span> <span class="n">posWorld</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">_Object2World</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
<span class="cp">#if UNITY_SPECCUBE_BOX_PROJECTION</span>
    <span class="n">o</span><span class="p">.</span><span class="n">posWorld</span> <span class="o">=</span> <span class="n">posWorld</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
<span class="n">o</span><span class="p">.</span><span class="n">tex</span> <span class="o">=</span> <span class="n">TexCoords</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="n">o</span><span class="p">.</span><span class="n">eyeVec</span> <span class="o">=</span> <span class="n">NormalizePerVertexNormal</span><span class="p">(</span><span class="n">posWorld</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">_WorldSpaceCameraPos</span><span class="p">);</span>
<span class="n">float3</span> <span class="n">normalWorld</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
<span class="cp">#ifdef _TANGENT_TO_WORLD</span>
    <span class="n">float4</span> <span class="n">tangentWorld</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">UnityObjectToWorldDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">),</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>

    <span class="n">float3x3</span> <span class="n">tangentToWorld</span> <span class="o">=</span> <span class="n">CreateTangentToWorldPerVertex</span><span class="p">(</span><span class="n">normalWorld</span><span class="p">,</span> <span class="n">tangentWorld</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">tangentWorld</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">tangentToWorld</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">tangentToWorld</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">tangentToWorld</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="cp">#else</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">normalWorld</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="c1">//We need this for shadow receving</span>
<span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>

<span class="n">o</span><span class="p">.</span><span class="n">ambientOrLightmapUV</span> <span class="o">=</span> <span class="n">VertexGIForward</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">posWorld</span><span class="p">,</span> <span class="n">normalWorld</span><span class="p">);</span>

<span class="cp">#ifdef _PARALLAXMAP</span>
    <span class="n">TANGENT_SPACE_ROTATION</span><span class="p">;</span>
    <span class="n">half3</span> <span class="n">viewDirForParallax</span> <span class="o">=</span> <span class="n">mul</span> <span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">ObjSpaceViewDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">));</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">viewDirForParallax</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">viewDirForParallax</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">viewDirForParallax</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#if UNITY_OPTIMIZE_TEXCUBELOD</span>
    <span class="n">o</span><span class="p">.</span><span class="n">reflUVW</span>         <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">eyeVec</span><span class="p">,</span> <span class="n">normalWorld</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="n">UNITY_TRANSFER_FOG</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">o</span><span class="p">.</span><span class="n">pos</span><span class="p">);</span>
<span class="k">return</span> <span class="n">o</span><span class="p">;</span>
</pre>

<p>}</p>
<p>普通に頂点シェーダー。たぶん
fragBase
    half4 fragBase (VertexOutputForwardBase i) : SV_Target { return fragForwardBaseInternal(i); }</p>
<p>CGInlucdes/UnityStandardCore.cginc
#define FRAGMENT_SETUP(x) FragmentCommonData x = \
    FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</p>
<p>struct FragmentCommonData
{
    half3 diffColor, specColor;
    // Note: oneMinusRoughness &amp; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.
    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.
    half oneMinusReflectivity, oneMinusRoughness;
    half3 normalWorld, eyeVec, posWorld;
    half alpha;</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 reflUVW;
</pre>

<h2>endif</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 tangentSpaceNormal;
</pre>

<h2>endif</h2>
<p>};</p>
<p>half4 OutputForward (half4 output, half alphaFromSurface)
{
    #if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON)
        output.a = alphaFromSurface;
    #else
        UNITY_OPAQUE_ALPHA(output.a);
    #endif
    return output;
}</p>
<p>half4 fragForwardBaseInternal (VertexOutputForwardBase i)
{
    FRAGMENT_SETUP(s)</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<pre class="code literal-block"><span></span>s.reflUVW        = i.reflUVW;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UnityLight mainLight = MainLight (s.normalWorld);
half atten = SHADOW_ATTENUATION(i);


half occlusion = Occlusion(i.tex.xy);
UnityGI gi = FragmentGI (s, occlusion, i.ambientOrLightmapUV, atten, mainLight);

half4 c = UNITY_BRDF_PBS (s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, gi.light, gi.indirect);
c.rgb += UNITY_BRDF_GI (s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, occlusion, gi);
c.rgb += Emission(i.tex.xy);

UNITY_APPLY_FOG(i.fogCoord, c.rgb);
return OutputForward (c, s.alpha);
</pre>

<p>}</p>
<p>普通にピクセルシェーダーで便利関数がいっぱい定義済みという感じか。
しかし、#ifの類がたくさんありどのルートが使われるか不明瞭。
includeを展開してみる
UsePassの代わりに自前のファイルにシェーダーのコードをコピーしてそっちを使ってみる。
DefaultResourcesExtra/Standard.shaderから切り張り
        Pass{
            Name "FORWARD"
            Tags{ "LightMode" = "ForwardBase" }</p>
<pre class="code literal-block"><span></span>        <span class="n">ZWrite</span> <span class="n">Off</span>
        <span class="n">ColorMask</span> <span class="n">RGB</span>
        <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>

        <span class="n">CGPROGRAM</span>
        <span class="cp">#pragma target 2.0</span>

        <span class="cp">#pragma shader_feature _NORMALMAP</span>
        <span class="cp">#pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON</span>
        <span class="cp">#pragma shader_feature _EMISSION </span>
        <span class="cp">#pragma shader_feature _METALLICGLOSSMAP </span>
        <span class="cp">#pragma shader_feature ___ _DETAIL_MULX2</span>
        <span class="c1">// SM2.0: NOT SUPPORTED shader_feature _PARALLAXMAP</span>

        <span class="cp">#pragma skip_variants SHADOWS_SOFT DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE</span>

        <span class="cp">#pragma multi_compile_fwdbase</span>
        <span class="cp">#pragma multi_compile_fog</span>

        <span class="cp">#pragma vertex vertBase</span>
        <span class="cp">#pragma fragment fragBase</span>

        <span class="cp">#include</span> <span class="cpf">"TransparentDiffuseWithZwrite_FORWARD.cginc"</span><span class="cp"></span>
        <span class="n">ENDCG</span>
    <span class="p">}</span>
</pre>

<p>UnityStandardCore.cgincから使うところだけ収集。
TransparentDiffuseWithZwrite_FORWARD.cginc</p>
<h2>include "UnityStandardConfig.cginc"</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>include "UnityStandardInput.cginc"</h2>
<h2>include "AutoLight.cginc"</h2>
<p>struct VertexOutputForwardBase
{
    float4 pos                            : SV_POSITION;
    float4 tex                            : TEXCOORD0;
    half3 eyeVec                         : TEXCOORD1;
    half4 tangentToWorldAndParallax[3]    : TEXCOORD2;    // [3x3:tangentToWorld | 1x3:viewDirForParallax]
    half4 ambientOrLightmapUV            : TEXCOORD5;    // SH or Lightmap UV
    SHADOW_COORDS(6)
        UNITY_FOG_COORDS(7)</p>
<pre class="code literal-block"><span></span>    // next ones would not fit into SM2.0 limits, but they are always for SM3.0+
</pre>

<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<pre class="code literal-block"><span></span>    float3 posWorld                    : TEXCOORD8;
</pre>

<h2>endif</h2>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<pre class="code literal-block"><span></span>half3 reflUVW                : TEXCOORD9;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>half3 reflUVW                : TEXCOORD8;
</pre>

<h2>endif</h2>
<h2>endif</h2>
<p>};</p>
<p>half3 NormalizePerVertexNormal(half3 n)
{</p>
<h2>if (SHADER_TARGET &lt; 30) || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>return normalize(n);
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>return n; // will normalize per-pixel instead
</pre>

<h2>endif</h2>
<p>}</p>
<p>half3 NormalizePerPixelNormal(half3 n)
{</p>
<h2>if (SHADER_TARGET &lt; 30) || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>return n;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>return normalize(n);
</pre>

<h2>endif</h2>
<p>}</p>
<p>UnityLight MainLight(half3 normalWorld)
{
    UnityLight l;</p>
<h2>ifdef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>l.color = _LightColor0.rgb;
l.dir = _WorldSpaceLightPos0.xyz;
l.ndotl = LambertTerm(normalWorld, l.dir);
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>// no light specified by the engine
// analytical light might be extracted from Lightmap data later on in the shader depending on the Lightmap type
l.color = half3(0.f, 0.f, 0.f);
l.ndotl = 0.f;
l.dir = half3(0.f, 0.f, 0.f);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return l;
</pre>

<p>}</p>
<p>inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)
{
    half4 ambientOrLightmapUV = 0;
    // Static lightmaps</p>
<h2>ifndef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
ambientOrLightmapUV.zw = 0;
// Sample light probe for Dynamic objects only (no static or dynamic lightmaps)
</pre>

<h2>elif UNITY_SHOULD_SAMPLE_SH</h2>
<h2>ifdef VERTEXLIGHT_ON</h2>
<pre class="code literal-block"><span></span>// Approximated illumination from non-important point lights
ambientOrLightmapUV.rgb = Shade4PointLights(
        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
        unity_4LightAtten0, posWorld, normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.rgb = ShadeSHPerVertex(normalWorld, ambientOrLightmapUV.rgb);
</pre>

<h2>endif</h2>
<h2>ifdef DYNAMICLIGHTMAP_ON</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return ambientOrLightmapUV;
</pre>

<p>}</p>
<p>VertexOutputForwardBase vertForwardBase(VertexInput v)
{
    VertexOutputForwardBase o;
    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</p>
<pre class="code literal-block"><span></span>float4 posWorld = mul(_Object2World, v.vertex);
</pre>

<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<pre class="code literal-block"><span></span>o.posWorld = posWorld.xyz;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
o.tex = TexCoords(v);
o.eyeVec = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);
float3 normalWorld = UnityObjectToWorldNormal(v.normal);
</pre>

<h2>ifdef _TANGENT_TO_WORLD</h2>
<pre class="code literal-block"><span></span>float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);

float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);
o.tangentToWorldAndParallax[0].xyz = tangentToWorld[0];
o.tangentToWorldAndParallax[1].xyz = tangentToWorld[1];
o.tangentToWorldAndParallax[2].xyz = tangentToWorld[2];
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>o.tangentToWorldAndParallax[0].xyz = 0;
o.tangentToWorldAndParallax[1].xyz = 0;
o.tangentToWorldAndParallax[2].xyz = normalWorld;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>//We need this for shadow receving
TRANSFER_SHADOW(o);

o.ambientOrLightmapUV = VertexGIForward(v, posWorld, normalWorld);
</pre>

<h2>ifdef _PARALLAXMAP</h2>
<pre class="code literal-block"><span></span>TANGENT_SPACE_ROTATION;
half3 viewDirForParallax = mul(rotation, ObjSpaceViewDir(v.vertex));
o.tangentToWorldAndParallax[0].w = viewDirForParallax.x;
o.tangentToWorldAndParallax[1].w = viewDirForParallax.y;
o.tangentToWorldAndParallax[2].w = viewDirForParallax.z;
</pre>

<h2>endif</h2>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<pre class="code literal-block"><span></span>o.reflUVW = reflect(o.eyeVec, normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UNITY_TRANSFER_FOG(o,o.pos);
return o;
</pre>

<p>}</p>
<p>VertexOutputForwardBase vertBase(VertexInput v) { return vertForwardBase(v); }
//VertexOutputForwardAdd vertAdd(VertexInput v) { return vertForwardAdd(v); }</p>
<h2>ifdef _PARALLAXMAP</h2>
<h2>define IN_VIEWDIR4PARALLAX(i) NormalizePerPixelNormal(half3(i.tangentToWorldAndParallax[0].w,i.tangentToWorldAndParallax[1].w,i.tangentToWorldAndParallax[2].w))</h2>
<h2>define IN_VIEWDIR4PARALLAX_FWDADD(i) NormalizePerPixelNormal(i.viewDirForParallax.xyz)</h2>
<h2>else</h2>
<h2>define IN_VIEWDIR4PARALLAX(i) half3(0,0,0)</h2>
<h2>define IN_VIEWDIR4PARALLAX_FWDADD(i) half3(0,0,0)</h2>
<h2>endif</h2>
<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<h2>define IN_WORLDPOS(i) i.posWorld</h2>
<h2>else</h2>
<h2>define IN_WORLDPOS(i) half3(0,0,0)</h2>
<h2>endif</h2>
<p>struct FragmentCommonData
{
    half3 diffColor, specColor;
    // Note: oneMinusRoughness &amp; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.
    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.
    half oneMinusReflectivity, oneMinusRoughness;
    half3 normalWorld, eyeVec, posWorld;
    half alpha;</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 reflUVW;
</pre>

<h2>endif</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 tangentSpaceNormal;
</pre>

<h2>endif</h2>
<p>};</p>
<p>inline FragmentCommonData MetallicSetup(float4 i_tex)
{
    half2 metallicGloss = MetallicGloss(i_tex.xy);
    half metallic = metallicGloss.x;
    half oneMinusRoughness = metallicGloss.y;        // this is 1 minus the square root of real roughness m.</p>
<pre class="code literal-block"><span></span>half oneMinusReflectivity;
half3 specColor;
half3 diffColor = DiffuseAndSpecularFromMetallic(Albedo(i_tex), metallic, /*out*/ specColor, /*out*/ oneMinusReflectivity);

FragmentCommonData o = (FragmentCommonData)0;
o.diffColor = diffColor;
o.specColor = specColor;
o.oneMinusReflectivity = oneMinusReflectivity;
o.oneMinusRoughness = oneMinusRoughness;
return o;
</pre>

<p>}</p>
<h2>ifndef UNITY_SETUP_BRDF_INPUT</h2>
<h2>define UNITY_SETUP_BRDF_INPUT SpecularSetup</h2>
<h2>endif</h2>
<p>inline FragmentCommonData SpecularSetup(float4 i_tex)
{
    half4 specGloss = SpecularGloss(i_tex.xy);
    half3 specColor = specGloss.rgb;
    half oneMinusRoughness = specGloss.a;</p>
<pre class="code literal-block"><span></span>half oneMinusReflectivity;
half3 diffColor = EnergyConservationBetweenDiffuseAndSpecular(Albedo(i_tex), specColor, /*out*/ oneMinusReflectivity);

FragmentCommonData o = (FragmentCommonData)0;
o.diffColor = diffColor;
o.specColor = specColor;
o.oneMinusReflectivity = oneMinusReflectivity;
o.oneMinusRoughness = oneMinusRoughness;
return o;
</pre>

<p>}</p>
<p>half3 PerPixelWorldNormal(float4 i_tex, half4 tangentToWorld[3])
{</p>
<h2>ifdef _NORMALMAP</h2>
<pre class="code literal-block"><span></span>half3 tangent = tangentToWorld[0].xyz;
half3 binormal = tangentToWorld[1].xyz;
half3 normal = tangentToWorld[2].xyz;
</pre>

<h2>if UNITY_TANGENT_ORTHONORMALIZE</h2>
<pre class="code literal-block"><span></span>normal = NormalizePerPixelNormal(normal);

// ortho-normalize Tangent
tangent = normalize(tangent - normal * dot(tangent, normal));

// recalculate Binormal
half3 newB = cross(normal, tangent);
binormal = newB * sign(dot(newB, binormal));
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>half3 normalTangent = NormalInTangentSpace(i_tex);
half3 normalWorld = NormalizePerPixelNormal(tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z); // @TODO: see if we can squeeze this normalize on SM2.0 as well
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>half3 normalWorld = normalize(tangentToWorld[2].xyz);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return normalWorld;
</pre>

<p>}</p>
<p>#define FRAGMENT_SETUP(x) FragmentCommonData x = \
                                                 FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</p>
<p>inline FragmentCommonData FragmentSetup(float4 i_tex, half3 i_eyeVec, half3 i_viewDirForParallax, half4 tangentToWorld[3], half3 i_posWorld)
{
    i_tex = Parallax(i_tex, i_viewDirForParallax);</p>
<pre class="code literal-block"><span></span>half alpha = Alpha(i_tex.xy);
</pre>

<h2>if defined(_ALPHATEST_ON)</h2>
<pre class="code literal-block"><span></span>clip(alpha - _Cutoff);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>FragmentCommonData o = UNITY_SETUP_BRDF_INPUT(i_tex);
o.normalWorld = PerPixelWorldNormal(i_tex, tangentToWorld);
o.eyeVec = NormalizePerPixelNormal(i_eyeVec);
o.posWorld = i_posWorld;

// NOTE: shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)
o.diffColor = PreMultiplyAlpha(o.diffColor, alpha, o.oneMinusReflectivity, /*out*/ o.alpha);
return o;
</pre>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light, bool reflections)
{
    UnityGIInput d;
    d.light = light;
    d.worldPos = s.posWorld;
    d.worldViewDir = -s.eyeVec;
    d.atten = atten;</p>
<h2>if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)</h2>
<pre class="code literal-block"><span></span>d.ambient = 0;
d.lightmapUV = i_ambientOrLightmapUV;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>d.ambient = i_ambientOrLightmapUV.rgb;
d.lightmapUV = 0;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>d.boxMax[0] = unity_SpecCube0_BoxMax;
d.boxMin[0] = unity_SpecCube0_BoxMin;
d.probePosition[0] = unity_SpecCube0_ProbePosition;
d.probeHDR[0] = unity_SpecCube0_HDR;

d.boxMax[1] = unity_SpecCube1_BoxMax;
d.boxMin[1] = unity_SpecCube1_BoxMin;
d.probePosition[1] = unity_SpecCube1_ProbePosition;
d.probeHDR[1] = unity_SpecCube1_HDR;

if (reflections)
{
    Unity_GlossyEnvironmentData g;
    g.roughness = 1 - s.oneMinusRoughness;
</pre>

<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>    g.reflUVW = s.reflUVW;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>    g.reflUVW = reflect(s.eyeVec, s.normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>    return UnityGlobalIllumination(d, occlusion, s.normalWorld, g);
}
else
{
    return UnityGlobalIllumination(d, occlusion, s.normalWorld);
}
</pre>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light)
{
    return FragmentGI(s, occlusion, i_ambientOrLightmapUV, atten, light, true);
}</p>
<p>half4 OutputForward(half4 output, half alphaFromSurface)
{</p>
<h2>if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON)</h2>
<pre class="code literal-block"><span></span>output.a = alphaFromSurface;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>UNITY_OPAQUE_ALPHA(output.a);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return output;
</pre>

<p>}</p>
<p>half4 fragForwardBaseInternal(VertexOutputForwardBase i)
{
    FRAGMENT_SETUP(s)</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<pre class="code literal-block"><span></span>    s.reflUVW = i.reflUVW;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UnityLight mainLight = MainLight(s.normalWorld);
half atten = SHADOW_ATTENUATION(i);


half occlusion = Occlusion(i.tex.xy);
UnityGI gi = FragmentGI(s, occlusion, i.ambientOrLightmapUV, atten, mainLight);

half4 c = UNITY_BRDF_PBS(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, gi.light, gi.indirect);
c.rgb += UNITY_BRDF_GI(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, occlusion, gi);
c.rgb += Emission(i.tex.xy);

UNITY_APPLY_FOG(i.fogCoord, c.rgb);
return OutputForward(c, s.alpha);
</pre>

<p>}</p>
<p>half4 fragBase(VertexOutputForwardBase i) : SV_Target{ return fragForwardBaseInternal(i); }
//half4 fragAdd(VertexOutputForwardAdd i) : SV_Target{ return fragForwardAddInternal(i); }</p>
<p>ある程度#includeを除いてシンプル化した。しかし、アルファブレンディングがなかなか有効にならずに悩んだ。
原因は、</p>
<h2>pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON</h2>
<p>で、このShaderキーワードの_ALPHABLEND_ONをEnableにしてやる必要があった。
material.EnableKeyword("_ALPHABLEND_ON");</p>
<p>ビルトインシェーダーでは何故自動で”_ALPHABLEND_ON”になるのか
DefaultResourcesExtra/Standard.shaderの末尾
    CustomEditor "StandardShaderGUI"</p>
<p>でカスタムエディタが指定してありこれを経由してマテリアルに介入してたのであった・・・。わかりにくいw
shader_featureとmulti_compileを剥がす
少しコード整理。
shader_featureとmulti_compileを剥がした。
ピクセルシェーダーは、GIとか書いてあってわりと複雑なのでその辺には手を触れず。</p>
<h2>include "UnityStandardConfig.cginc"</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>include "UnityStandardInput.cginc"</h2>
<h2>include "AutoLight.cginc"</h2>
<p>//////////////////////////////////////////////////////////////////////////////
// vertBase
//////////////////////////////////////////////////////////////////////////////
struct VertexOutputForwardBase
{
    float4 pos                            : SV_POSITION;
    float4 tex                            : TEXCOORD0;
    half3 eyeVec                         : TEXCOORD1;
    half4 tangentToWorldAndParallax[3]    : TEXCOORD2;    // [3x3:tangentToWorld | 1x3:viewDirForParallax]
    half4 ambientOrLightmapUV            : TEXCOORD5;    // SH or Lightmap UV
    SHADOW_COORDS(6)
    UNITY_FOG_COORDS(7)
};</p>
<p>inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)
{
    half4 ambientOrLightmapUV = 0;
    // Static lightmaps</p>
<h2>ifndef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
ambientOrLightmapUV.zw = 0;
// Sample light probe for Dynamic objects only (no static or dynamic lightmaps)
</pre>

<h2>elif UNITY_SHOULD_SAMPLE_SH</h2>
<h2>ifdef VERTEXLIGHT_ON</h2>
<pre class="code literal-block"><span></span>// Approximated illumination from non-important point lights
ambientOrLightmapUV.rgb = Shade4PointLights(
        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
        unity_4LightAtten0, posWorld, normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.rgb = ShadeSHPerVertex(normalWorld, ambientOrLightmapUV.rgb);
</pre>

<h2>endif</h2>
<h2>ifdef DYNAMICLIGHTMAP_ON</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return ambientOrLightmapUV;
</pre>

<p>}</p>
<p>half3 NormalizePerVertexNormal(half3 n)
{
    return normalize(n);
}</p>
<p>VertexOutputForwardBase vertForwardBase(VertexInput v)
{
    VertexOutputForwardBase o;
    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</p>
<pre class="code literal-block"><span></span>float4 posWorld = mul(_Object2World, v.vertex);
</pre>

<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<pre class="code literal-block"><span></span>o.posWorld = posWorld.xyz;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
o.tex = TexCoords(v);
o.eyeVec = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);
float3 normalWorld = UnityObjectToWorldNormal(v.normal);
</pre>

<h2>ifdef _TANGENT_TO_WORLD</h2>
<pre class="code literal-block"><span></span>float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);

float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);
o.tangentToWorldAndParallax[0].xyz = tangentToWorld[0];
o.tangentToWorldAndParallax[1].xyz = tangentToWorld[1];
o.tangentToWorldAndParallax[2].xyz = tangentToWorld[2];
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>o.tangentToWorldAndParallax[0].xyz = 0;
o.tangentToWorldAndParallax[1].xyz = 0;
o.tangentToWorldAndParallax[2].xyz = normalWorld;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>//We need this for shadow receving
TRANSFER_SHADOW(o);

o.ambientOrLightmapUV = VertexGIForward(v, posWorld, normalWorld);
</pre>

<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<pre class="code literal-block"><span></span>o.reflUVW = reflect(o.eyeVec, normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UNITY_TRANSFER_FOG(o,o.pos);
return o;
</pre>

<p>}</p>
<p>VertexOutputForwardBase vertBase(VertexInput v) { return vertForwardBase(v); }</p>
<p>//////////////////////////////////////////////////////////////////////////////
// fragBase
//////////////////////////////////////////////////////////////////////////////</p>
<h2>define IN_VIEWDIR4PARALLAX(i) half3(0,0,0)</h2>
<h2>define IN_VIEWDIR4PARALLAX_FWDADD(i) half3(0,0,0)</h2>
<h2>define IN_WORLDPOS(i) half3(0,0,0)</h2>
<p>struct FragmentCommonData
{
    half3 diffColor, specColor;
    // Note: oneMinusRoughness &amp; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.
    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.
    half oneMinusReflectivity, oneMinusRoughness;
    half3 normalWorld, eyeVec, posWorld;
    half alpha;</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 reflUVW;
</pre>

<h2>endif</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 tangentSpaceNormal;
</pre>

<h2>endif</h2>
<p>};</p>
<h2>ifndef UNITY_SETUP_BRDF_INPUT</h2>
<h2>define UNITY_SETUP_BRDF_INPUT SpecularSetup</h2>
<h2>endif</h2>
<p>inline FragmentCommonData SpecularSetup(float4 i_tex)
{
    half4 specGloss = SpecularGloss(i_tex.xy);
    half3 specColor = specGloss.rgb;
    half oneMinusRoughness = specGloss.a;</p>
<pre class="code literal-block"><span></span>half oneMinusReflectivity;
half3 diffColor = EnergyConservationBetweenDiffuseAndSpecular(Albedo(i_tex), specColor, /*out*/ oneMinusReflectivity);

FragmentCommonData o = (FragmentCommonData)0;
o.diffColor = diffColor;
o.specColor = specColor;
o.oneMinusReflectivity = oneMinusReflectivity;
o.oneMinusRoughness = oneMinusRoughness;
return o;
</pre>

<p>}</p>
<p>half3 PerPixelWorldNormal(float4 i_tex, half4 tangentToWorld[3])
{
    half3 normalWorld = normalize(tangentToWorld[2].xyz);
    return normalWorld;
}</p>
<p>#define FRAGMENT_SETUP(x) FragmentCommonData x = \
                                                 FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</p>
<p>inline FragmentCommonData FragmentSetup(float4 i_tex, half3 i_eyeVec, half3 i_viewDirForParallax, half4 tangentToWorld[3], half3 i_posWorld)
{
    i_tex = Parallax(i_tex, i_viewDirForParallax);</p>
<pre class="code literal-block"><span></span>half alpha = Alpha(i_tex.xy);

FragmentCommonData o = UNITY_SETUP_BRDF_INPUT(i_tex);
o.normalWorld = PerPixelWorldNormal(i_tex, tangentToWorld);
o.eyeVec = i_eyeVec;
o.posWorld = i_posWorld;

// NOTE: shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)
o.diffColor = PreMultiplyAlpha(o.diffColor, alpha, o.oneMinusReflectivity, /*out*/ o.alpha);
return o;
</pre>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light, bool reflections)
{
    UnityGIInput d;
    d.light = light;
    d.worldPos = s.posWorld;
    d.worldViewDir = -s.eyeVec;
    d.atten = atten;</p>
<h2>if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)</h2>
<pre class="code literal-block"><span></span>d.ambient = 0;
d.lightmapUV = i_ambientOrLightmapUV;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>d.ambient = i_ambientOrLightmapUV.rgb;
d.lightmapUV = 0;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>d.boxMax[0] = unity_SpecCube0_BoxMax;
d.boxMin[0] = unity_SpecCube0_BoxMin;
d.probePosition[0] = unity_SpecCube0_ProbePosition;
d.probeHDR[0] = unity_SpecCube0_HDR;

d.boxMax[1] = unity_SpecCube1_BoxMax;
d.boxMin[1] = unity_SpecCube1_BoxMin;
d.probePosition[1] = unity_SpecCube1_ProbePosition;
d.probeHDR[1] = unity_SpecCube1_HDR;

if (reflections)
{
    Unity_GlossyEnvironmentData g;
    g.roughness = 1 - s.oneMinusRoughness;
</pre>

<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>    g.reflUVW = s.reflUVW;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>    g.reflUVW = reflect(s.eyeVec, s.normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>    return UnityGlobalIllumination(d, occlusion, s.normalWorld, g);
}
else
{
    return UnityGlobalIllumination(d, occlusion, s.normalWorld);
}
</pre>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light)
{
    return FragmentGI(s, occlusion, i_ambientOrLightmapUV, atten, light, true);
}</p>
<p>UnityLight MainLight(half3 normalWorld)
{
    UnityLight l;</p>
<h2>ifdef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>l.color = _LightColor0.rgb;
l.dir = _WorldSpaceLightPos0.xyz;
l.ndotl = LambertTerm(normalWorld, l.dir);
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>// no light specified by the engine
// analytical light might be extracted from Lightmap data later on in the shader depending on the Lightmap type
l.color = half3(0.f, 0.f, 0.f);
l.ndotl = 0.f;
l.dir = half3(0.f, 0.f, 0.f);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return l;
</pre>

<p>}</p>
<p>half4 fragForwardBaseInternal(VertexOutputForwardBase i)
{
    FRAGMENT_SETUP(s)</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<pre class="code literal-block"><span></span>    s.reflUVW = i.reflUVW;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UnityLight mainLight = MainLight(s.normalWorld);
half atten = SHADOW_ATTENUATION(i);

half occlusion = Occlusion(i.tex.xy);
UnityGI gi = FragmentGI(s, occlusion, i.ambientOrLightmapUV, atten, mainLight);

half4 c = UNITY_BRDF_PBS(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, gi.light, gi.indirect);
c.rgb += UNITY_BRDF_GI(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, occlusion, gi);
c.rgb += Emission(i.tex.xy);

UNITY_APPLY_FOG(i.fogCoord, c.rgb);
c.a = s.alpha;
return c;
</pre>

<p>}</p>
<p>half4 fragBase(VertexOutputForwardBase i) : SV_Target{ return fragForwardBaseInternal(i); }</p>
<p>1パスでいいんじゃないの？
UsePassを展開したことによってZWrite Onできるようになったw。Oh…
Shader "Transparent/Diffuse ZWrite" {
    Properties{
        _Color("Main Color", Color) = (1,1,1,1)
        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
    }</p>
<pre class="code literal-block"><span></span><span class="n">SubShader</span><span class="p">{</span>

    <span class="n">Tags</span><span class="p">{</span> <span class="s">"Queue"</span> <span class="o">=</span> <span class="s">"Transparent"</span> <span class="s">"IgnoreProjector"</span> <span class="o">=</span> <span class="s">"True"</span> <span class="s">"RenderType"</span> <span class="o">=</span> <span class="s">"Transparent"</span> <span class="p">}</span>
    <span class="n">LOD</span> <span class="mi">200</span>

    <span class="c1">// paste in forward rendering passes from Transparent/Diffuse</span>
    <span class="c1">//UsePass "Legacy Shaders/Transparent/Diffuse/FORWARD"</span>

    <span class="n">Pass</span><span class="p">{</span>
        <span class="n">Name</span> <span class="s">"FORWARD"</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardBase"</span> <span class="p">}</span>

        <span class="n">ZWrite</span> <span class="n">On</span>
        <span class="n">ColorMask</span> <span class="n">RGB</span>
        <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>

        <span class="n">CGPROGRAM</span>
        <span class="cp">#pragma target 2.0</span>

        <span class="cp">#pragma skip_variants SHADOWS_SOFT DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE</span>

        <span class="c1">// これは要るっぽい</span>
        <span class="cp">#pragma multi_compile_fwdbase</span>
        <span class="cp">#pragma multi_compile_fog</span>

        <span class="cp">#pragma vertex vertBase</span>
        <span class="cp">#pragma fragment fragBase</span>

        <span class="cp">#include</span> <span class="cpf">"TransparentDiffuseWithZwrite_FORWARD.cginc"</span><span class="cp"></span>
        <span class="n">ENDCG</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// SubShader</span>

<span class="c1">//Fallback "Transparent/VertexLit"</span>
</pre>

<p>}</p>
<p>よし、スクラッチでシェーダーを書こうw
multi_compile_fwdbase
FrameDebuggerで見たところシェーダーのdefineがまとめて変わっていた。LIGHTMAP_OFF等に依存していると影響がある。
まとめてmulti_compileを定義しているだけっぽい。
まとめ</p>
<p>surfaceシェーダーでは無い(shaderのinspectorにも書いてあった)
UsePassでsurfaceシェーダーのPASSを指定することもできる
それ故大変分かりにくい(可読性とコード量とのトレードオフが大きい)
surfaceシェーダーも何らかの形でvertexとfragmentを含むPassの集合に展開されている(どう展開されるのか知りたいんだけど)</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2015/12/30/unity_webgl/" class="u-url">Unity5.3でWebGL</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2015/12/30/unity_webgl/" rel="bookmark">
            <time class="published dt-published" datetime="2015-12-30T00:00:00+09:00" itemprop="datePublished" title="2015-12-30 00:00">2015-12-30 00:00</time></a>
            </p>
                        <p class="commentline">
        
    <a href="posts/2015/12/30/unity_webgl/#disqus_thread" data-disqus-identifier="cache/content/posts/2015/12/30/unity_webgl.html">コメント</a>


                </p>
</div>
            </header><div class="e-content entry-content">
                    <div>
<p>var Module = {
    TOTAL_MEMORY: 268435456,
    errorhandler: null,         // arguments: err, url, line. This function must return 'true' if the error is handled, otherwise 'false'
    compatibilitycheck: null,
    dataUrl: "Release/WebGL.data",
    codeUrl: "Release/WebGL.js",
    memUrl: "Release/WebGL.mem",
  };</p>
<p>こっちが未加工のindex.html。
Unity5.3のWebGLを試してみる。</p>
<p>http://blogs.unity3d.com/jp/2015/12/07/unity-5-3-webgl-updates/
http://docs.unity3d.com/530/Documentation/Manual/webgl-gettingstarted.html</p>
<p>とりあえずbuildして動かしてみた。
下記のようなディレクトリ構造で出力されていた。
│  index.html
│
├─Release
│      .htaccess
│      UnityLoader.js
│      WebGL.datagz
│      WebGL.jsgz
│      WebGL.memgz
│
└─TemplateData
        favicon.ico
        fullbar.png
        fullscreen.png
        loadingbar.png
        logo.png
        progresslogo.png
        style.css
        UnityProgress.js</p>
<p>index.htmlは下記の通り。
index.html</p>

<p>
  </p>
    <meta charset="utf-8">
<title>Unity WebGL Player | UnityProject</title>
<link rel="stylesheet" href="posts/2015/12/30/unity_webgl/TemplateData/style.css">
<link rel="shortcut icon" href="posts/2015/12/30/unity_webgl/TemplateData/favicon.ico">
<script src="posts/2015/12/30/unity_webgl/TemplateData/UnityProgress.js"></script><br><p class="header"><span>Unity WebGL Player | </span>UnityProject</p>
    <div class="template-wrap clear">
      <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" height="600px" width="960px"></canvas><br><div class="logo"></div>
      <div class="fullscreen"><img src="posts/2015/12/30/unity_webgl/TemplateData/fullscreen.png" width="38" height="38" alt="Fullscreen" title="Fullscreen" onclick="SetFullscreen(1);"></div>
      <div class="title">UnityProject</div>
    </div>
    <p class="footer">« created with <a href="http://unity3d.com/" title="Go to unity3d.com">Unity</a> »</p>
    <script type="text/javascript">
  var Module = {
    TOTAL_MEMORY: 268435456,
    errorhandler: null,         // arguments: err, url, line. This function must return 'true' if the error is handled, otherwise 'false'
    compatibilitycheck: null,
    dataUrl: "Release/WebGL.data",
    codeUrl: "Release/WebGL.js",
    memUrl: "Release/WebGL.mem",
  };
</script><script src="posts/2015/12/30/unity_webgl/Release/UnityLoader.js"></script><p></p>
<p>上記から適当にhtmlを切り出して埋め込んでみた。特に問題なく動作。
ちなみに、コンパイル時間は非常に長い。
IL2CPPでC#をc++化して、emscriptenでC++をJavascript(asm.js)化するそうだ。
シーンだけじゃなくてシステムもすべて都度ビルドしてそうな感じなので今回のような微小なシーンしか含んでいなくてもコンパイルが結構長い。
うちのマシンではパワー不足。
あと、githubにこのページをpushする時に容量制限にひっかかってしまった。
一回のコミットが大きすぎるという件。
ファイル容量をチェックした結果WebGL.jsgzが3Mあるのでこれだ。
WebGL.jsgzとそれ以外にコミットを分けたらpushはできた。
現状、以下の2点がネック。</p>
<p>コンパイルが長い
githubでホストする場合容量制限にひっかっかってpushできない可能性がある</p>
<p>そのうちこの辺りは改善されるだろうけど。
three.jsのサンプルを乗っける手軽さというわけにはいかない。
わりとポテンシャルを感じるので、サイトに埋め込んで遊べる方法を模索したいところ。</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2015/12/24/heroku_sokcetio/" class="u-url">Node.jsでSocket.IOなアプリをHerokuにデプロイ</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2015/12/24/heroku_sokcetio/" rel="bookmark">
            <time class="published dt-published" datetime="2015-12-24T00:00:00+09:00" itemprop="datePublished" title="2015-12-24 00:00">2015-12-24 00:00</time></a>
            </p>
                        <p class="commentline">
        
    <a href="posts/2015/12/24/heroku_sokcetio/#disqus_thread" data-disqus-identifier="cache/content/posts/2015/12/24/heroku_sokcetio.html">コメント</a>


                </p>
</div>
            </header><div class="e-content entry-content">
                    <div>
<p>Socket.IOサーバーとしてHerokuを使ってみよう。
実験中
https://shielded-caverns-4913.herokuapp.com/
Heroku練習
以前作ったユーザーが生きていたので改めてチュートリアルを実践。</p>
<p>Getting Started with Node.js on Heroku</p>
<p>gulpでexpressなサーバを作る
普通にnpmなプロジェクトを作る。</p>
<blockquote>
<p>mkdir bvh_sio
cd bvh_sio
npm init
mkdir src
mkidr src/server
mkdir src/client
cd src
tsd init
tsd query node -rosa install
tsd query express -rosa install
tsd query serve-static -rosa install
tsd query socket.io -rosa install</p>
</blockquote>
<p>Herokuにデプロイする場合はでdevDependenciesじゃなくてdependenciesに書くらしいのでそのようにした。
package.json
{
  "name": "bvh_sio",
  "version": "1.0.0",
  "description": "",
  "main": "build/app.js",
  "scripts": {
    "start": "node build/app.js"
  },
  "author": "ousttrue",
  "license": "ISC",
  "dependencies": {
    "express": "^4.13.3",
    "gulp": "^3.9.0",
    "gulp-if": "^2.0.0",
    "gulp-load-plugins": "^1.1.0",
    "gulp-run-sequence": "^0.3.2",
    "gulp-typescript": "^2.10.0",
    "serve-static": "^1.10.0",
    "socket.io": "^1.3.7",
    "tsd": "^0.6.5"
  }
}</p>
<p>serve-staticで静的なファイルをホストするexpress。後でsocket.ioを追加する。
src/server/app.ts
/// <reference path="../typings/tsd.d.ts"></reference></p>
<p>import http = require('http');
import express = require('express');
const port = process.env.PORT || 3000; // &lt;- Herokuで必要!
const app = express();
const server = http.createServer(app);
const servestatic = require('serve-static');
const serve_dir = __dirname + '/public';
console.log('serve %s', serve_dir);
app
    .use(servestatic(serve_dir))
;</p>
<p>// start
server.listen(port);
console.log('start port: %d...', port);</p>
<p>こいつをtypescriptでコンパイルしてbuildディレクトリに展開したい。
gulpfile.js
'use strict';</p>
<p>const path = require('path');
const execSync = require('child_process').execSync;
const gulp = require('gulp');
const $ = require('gulp-load-plugins')();</p>
<p>const config = {
    server_src: './src/server/<em><em>/</em>.</em>',
    server_dst: './build',</p>
<pre class="code literal-block"><span></span>client_src: './src/client/**/*.*',
client_dst: './build/public'
</pre>

<p>};
const tsconfig = require('./tsconfig.json');</p>
<p>function pushd(dst, callback) {
    const cwd = process.cwd();
    process.chdir(dst);
    callback();
    process.chdir(cwd);
}</p>
<p>gulp.task('tsd:install', () =&gt; {
    pushd('./src', ()=&gt;execSync('tsd install'));
});</p>
<p>gulp.task('server', () =&gt; {
    gulp.src(config.server_src)
        .pipe($.if((file) =&gt; path.extname(file.path).toLowerCase() === '.ts'
            , $.typescript(tsconfig.compilerOptions)))
        .pipe(gulp.dest(config.server_dst))
    ;
});</p>
<p>gulp.task('client', () =&gt; {
    gulp.src(config.client_src)
        .pipe($.if((file) =&gt; path.extname(file.path).toLowerCase() === '.ts'
            , $.typescript(tsconfig.compilerOptions)))
        .pipe(gulp.dest(config.client_dst))
    ;
});</p>
<p>gulp.task('build', ['server', 'client']);</p>
<p>gulp.task('install', (cb) =&gt; {
    $.runSequence('tsd:install', 'build', cb);
});</p>
<p>gulp.task('default', ['build']);</p>
<p>tsconfig.json
{
    "compilerOptions": {
        "module": "commonjs",
        "target": "es5",
        "noImplicitAny": true,
        "outDir": ".",
        "rootDir": ".",
        "sourceMap": false,
        "removeComments": true
    },
    "exclude": [
        "node_modules"
    ]
}</p>
<p>jsconfig.json
{
    "compilerOptions": {
        "module": "commonjs",
        "target": "es6"
    }
}</p>
<p>src/client/index.html</p>

<p>
</p>
    <meta charset="UTF-8">
<title>Document</title>
<h2>Hello</h2>

<p></p>
<p>プロジェクトをHeroku化してデプロイ
Herokuでビルドしたりbuild結果だけをpushするなどの方式があるようだが、Heroku上でgulpする方式にしてみた(git苦手w)。
git push時に実行するコマンドをpackage.jsonに記述できる。
package.json
  "scripts": {
    "postinstall": "gulp install", // &lt;- 追加する
    "start": "node build/app.js"
  },</p>
<p>サーバー実行コマンド。
Procfile
web: node build/app.js</p>
<p>herokuにデプロイ。</p>
<h2>一回だけ実行する</h2>
<blockquote>
<p>heroku create</p>
</blockquote>
<h2>herokuを更新</h2>
<blockquote>
<p>git push heroku master</p>
</blockquote>
<h2>エラーが出たら直す。npm installなど</h2>
<h2>herokuサイトをブラウザで開く</h2>
<blockquote>
<p>heroku open</p>
</blockquote>
<h2>エラーが出たら直す。npm installなど</h2>
<p>heroku側でgulp-typescriptするように作ってみたけどうまくいった。
socket.ioを追加
websocketじゃなくてajax pollingらしいけどSocket.IOがよきに計らってくれる。
src/server/app.tsに追加
// socket.io
import socketio = require('socket.io');
const io = socketio(server);
io.on('connection', (socket) =&gt; {
    var clientAddress = socket.client.conn.remoteAddress;
    console.log('connected: %s from %s', socket.id, clientAddress);</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">recTimer</span><span class="p">(</span><span class="nx">interval</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">callback</span>: <span class="kt">Function</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="nx">recTimer</span><span class="p">(</span><span class="nx">interval</span><span class="p">,</span> <span class="nx">callback</span><span class="p">),</span> <span class="nx">interval</span><span class="p">);</span>
    <span class="nx">callback</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">recTimer</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="p">()</span><span class="o">=&gt;</span><span class="nx">socket</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'time'</span><span class="p">,</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()));</span>
</pre>

<p>});</p>
<p>src/client/index.html</p>

<p>
</p>
    <meta charset="UTF-8">
<title>Document</title>
<script src="socket.io/socket.io.js"></script><script src="posts/2015/12/24/heroku_sokcetio/index.js"></script><h2>Hello</h2>

    <div id="content"></div>

<p></p>
<p>src/client/index.ts
/// <reference path="../typings/tsd.d.ts"></reference></p>
<p>declare module io {
    export function connect(): SocketIO.Socket;
}</p>
<p>window.onload = () =&gt; {
    const socket = io.connect();</p>
<pre class="code literal-block"><span></span>const content=document.getElementById('content');

socket.on('connect', ()=&gt;{
    content.innerHTML='connected!';
});

socket.on('time', (message: any)=&gt;{
    content.innerHTML+='&lt;br&gt;'+message;
});
</pre>

<p>}</p>
<p>bvh
準備が整ったので、node.js側でパースしたbvhを適当にjson化してsocket.ioにemitするサーバーを作る。</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2015/12/23/bvh/" class="u-url">Three.jsでbvh</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2015/12/23/bvh/" rel="bookmark">
            <time class="published dt-published" datetime="2015-12-23T00:00:00+09:00" itemprop="datePublished" title="2015-12-23 00:00">2015-12-23 00:00</time></a>
            </p>
                        <p class="commentline">
        
    <a href="posts/2015/12/23/bvh/#disqus_thread" data-disqus-identifier="cache/content/posts/2015/12/23/bvh.html">コメント</a>


                </p>
</div>
            </header><div class="e-content entry-content">
                    <div>
<p>/</p>
<p>BVH labsを参考にやってみる。
モーションは
続 BVHファイルを探してみたで紹介されていた
https://sites.google.com/a/cgspeed.com/cgspeed/motion-capture
から拝借。
上記のサイトのコードをtypescript化しながら解読中。
THREE.Skeletonというクラスがボーンアニメーションをしているらしい。
Sliderつけてみた</p>
<p>https://refreshless.com/nouislider/</p>
</div>
                </div>
            </article>
</div>
    
        <ul class="pager postindexpager clearfix">
<li class="previous"><a href="index-9.html" rel="prev">新しい記事</a></li>
            <li class="next"><a href="index-7.html" rel="next">過去の記事</a></li>
        </ul>
<script>var disqus_shortname="nikolademo";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><!--End of body content--><footer id="footer">
            Contents © 2021         <a href="mailto:ousttrue@gmail.com">ousttrue</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
