"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4092],{8858:function(n,e,o){o.r(e),o.d(e,{default:function(){return s}});var t=o(1151),a=o(7294);function i(n){const e=Object.assign({p:"p",span:"span"},(0,t.ah)(),n.components);return a.createElement(a.Fragment,null,a.createElement(e.p,null,"Toon シェーダーをやってみる。"),"\n",a.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">メニューからインポートすると、\nAssets > Import Package > Effects\n\nAssetsが現れる。\nStandard Assets/Effects/ToonShading\n\nToon/Lit\nStandard Assets/Effects/ToonShadingのshaderを自分のフォルダにコピーして改造する。\n#UsePassを展開して改造準備\nShader "MyToon/Lit Outline" {\n    Properties {\n        _Color ("Main Color", Color) = (0.5,0.5,0.5,1)\n        _OutlineColor ("Outline Color", Color) = (0,0,0,1)\n        _Outline ("Outline width", Range (.002, 0.03)) = .005\n        _MainTex ("Base (RGB)", 2D) = "white" {}\n        _Ramp ("Toon Ramp (RGB)", 2D) = "gray" {}\n    }\n\n    SubShader {\n        Tags { "RenderType"="Opaque" }\n        UsePass "Toon/Lit/FORWARD"\n        UsePass "Toon/Basic Outline/OUTLINE"\n    }\n\n    Fallback "Toon/Lit"\n}\n\nToon/Litのinspectorの\nSurface shader: Show generated code\n\nから該当するFORWARD Passをコピペし、\nToon/Basic OutlineのOUTLINE Passをコピペする。\n適当に整理する。\nShader "MyToon/Custom"\n{\n    Properties\n    {\n        _Color("Main Color", Color) = (0.5,0.5,0.5,1)\n        _MainTex("Base (RGB)", 2D) = "white" {}\n        _Ramp("Toon Ramp (RGB)", 2D) = "gray" {}\n\n        _OutlineColor("Outline Color", Color) = (0,0,0,1)\n        _Outline("Outline width", Range(.002, 0.03)) = .005\n    }\n    SubShader\n    {\n        Tags { "RenderType"="Opaque" }\n        LOD 100\n\n        // ---- forward rendering base pass:\n        Pass{\n            Name "FORWARD"\n            Tags{ "LightMode" = "ForwardBase" }\n\n            CGPROGRAM\n#pragma vertex vert_surf\n#pragma fragment frag_surf\n#pragma lighting ToonRamp exclude_path:prepass\n#pragma multi_compile_fog\n#pragma multi_compile_fwdbase\n#include "Custom.cginc"\n            ENDCG\n        }\n\n        // outline\n        Pass{\n            Name "OUTLINE"\n            Tags{ "LightMode" = "Always" }\n            Cull Front\n            ZWrite On\n            ColorMask RGB\n            Blend SrcAlpha OneMinusSrcAlpha\n\n            CGPROGRAM\n#pragma vertex vert\n#pragma fragment frag\n#pragma multi_compile_fog\n#pragma multi_compile_fwdbase\n#include "Custom.cginc"\n            ENDCG\n        }\n    }\n\n    // for shadow etc...\n    Fallback "Diffuse"\n}\n\n*.shaderファイルのインデントが扱いずらいのでcgincと分割して手で整形。\n気持ちよくindentできるエディタを見繕う必要があるな・・・\nCustom.cginc\n#include "HLSLSupport.cginc"\n#include "UnityShaderVariables.cginc"\n// Surface shader code generated based on:\n// writes to per-pixel normal: no\n// writes to emission: no\n// needs world space reflection vector: no\n// needs world space normal vector: no\n// needs screen space position: no\n// needs world space position: no\n// needs view direction: no\n// needs world space view direction: no\n// needs world space position for lighting: no\n// needs world space view direction for lighting: no\n// needs world space view direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from normal: no\n// 1 texcoords actually used\n//   float2 _MainTex\n#define UNITY_PASS_FORWARDBASE\n#include "UnityCG.cginc"\n#include "Lighting.cginc"\n#include "AutoLight.cginc"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line 10 ""\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//#pragma surface surf ToonRamp\n\nsampler2D _Ramp;\n\n// custom lighting function that uses a texture ramp based\n// on angle between light direction and normal\n//#pragma lighting ToonRamp exclude_path:prepass\ninline half4 LightingToonRamp(SurfaceOutput s, half3 lightDir, half atten)\n{\n#ifndef USING_DIRECTIONAL_LIGHT\n    lightDir = normalize(lightDir);\n#endif\n\n    half d = dot(s.Normal, lightDir)*0.5 + 0.5;\n    half3 ramp = tex2D(_Ramp, float2(d, d)).rgb;\n\n    half4 c;\n    c.rgb = s.Albedo * _LightColor0.rgb * ramp * (atten * 2);\n    c.a = 0;\n    return c;\n}\n\n\nsampler2D _MainTex;\nfloat4 _Color;\n\nstruct Input {\n    float2 uv_MainTex : TEXCOORD0;\n};\n\nvoid surf(Input IN, inout SurfaceOutput o) {\n    half4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;\n    o.Albedo = c.rgb;\n    o.Alpha = c.a;\n}\n\n\n// vertex-to-fragment interpolation data\n// no lightmaps:\n#ifdef LIGHTMAP_OFF\nstruct v2f_surf {\n    float4 pos : SV_POSITION;\n    float2 pack0 : TEXCOORD0; // _MainTex\n    half3 worldNormal : TEXCOORD1;\n    fixed3 vlight : TEXCOORD2; // ambient/SH/vertexlights\n    SHADOW_COORDS(3)\n        UNITY_FOG_COORDS(4)\n#if SHADER_TARGET >= 30\n        float4 lmap : TEXCOORD5;\n#endif\n};\n#endif\n// with lightmaps:\n#ifndef LIGHTMAP_OFF\nstruct v2f_surf {\n    float4 pos : SV_POSITION;\n    float2 pack0 : TEXCOORD0; // _MainTex\n    half3 worldNormal : TEXCOORD1;\n    float4 lmap : TEXCOORD2;\n    SHADOW_COORDS(3)\n        UNITY_FOG_COORDS(4)\n#ifdef DIRLIGHTMAP_COMBINED\n        fixed3 tSpace0 : TEXCOORD5;\n    fixed3 tSpace1 : TEXCOORD6;\n    fixed3 tSpace2 : TEXCOORD7;\n#endif\n};\n#endif\nfloat4 _MainTex_ST;\n\n// vertex shader\nv2f_surf vert_surf(appdata_full v) {\n    v2f_surf o;\n    UNITY_INITIALIZE_OUTPUT(v2f_surf, o);\n    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);\n    o.pack0.xy = TRANSFORM_TEX(v.texcoord, _MainTex);\n    float3 worldPos = mul(_Object2World, v.vertex).xyz;\n    fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);\n#if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)\n    fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n    fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n    fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n#endif\n#if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)\n    o.tSpace0 = fixed3(worldTangent.x, worldBinormal.x, worldNormal.x);\n    o.tSpace1 = fixed3(worldTangent.y, worldBinormal.y, worldNormal.y);\n    o.tSpace2 = fixed3(worldTangent.z, worldBinormal.z, worldNormal.z);\n#endif\n    o.worldNormal = worldNormal;\n#ifndef DYNAMICLIGHTMAP_OFF\n    o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#endif\n#ifndef LIGHTMAP_OFF\n    o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n#endif\n\n    // SH/ambient and vertex lights\n#ifdef LIGHTMAP_OFF\n#if UNITY_SHOULD_SAMPLE_SH\n    float3 shlight = ShadeSH9(float4(worldNormal, 1.0));\n    o.vlight = shlight;\n#else\n    o.vlight = 0.0;\n#endif\n#ifdef VERTEXLIGHT_ON\n    o.vlight += Shade4PointLights(\n            unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n            unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n            unity_4LightAtten0, worldPos, worldNormal);\n#endif // VERTEXLIGHT_ON\n#endif // LIGHTMAP_OFF\n\n    TRANSFER_SHADOW(o); // pass shadow coordinates to pixel shader\n    UNITY_TRANSFER_FOG(o, o.pos); // pass fog coordinates to pixel shader\n    return o;\n}\n\n// fragment shader\nfixed4 frag_surf(v2f_surf IN) : SV_Target{\n    // prepare and unpack data\n    Input surfIN;\n    UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n    surfIN.uv_MainTex.x = 1.0;\n    surfIN.uv_MainTex = IN.pack0.xy;\n    float3 lightDir = _WorldSpaceLightPos0.xyz;\n#ifdef UNITY_COMPILER_HLSL\n    SurfaceOutput o = (SurfaceOutput)0;\n#else\n    SurfaceOutput o;\n#endif\n    o.Albedo = 0.0;\n    o.Emission = 0.0;\n    o.Specular = 0.0;\n    o.Alpha = 0.0;\n    o.Gloss = 0.0;\n    fixed3 normalWorldVertex = fixed3(0,0,1);\n    o.Normal = IN.worldNormal;\n    normalWorldVertex = IN.worldNormal;\n\n    // call surface function\n    surf(surfIN, o);\n\n    // compute lighting &amp; shadowing factor\n    UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n        fixed4 c = 0;\n#ifdef LIGHTMAP_OFF\n    c.rgb += o.Albedo * IN.vlight;\n#endif // LIGHTMAP_OFF\n\n    // lightmaps\n#ifndef LIGHTMAP_OFF\n#ifdef DIRLIGHTMAP_OFF\n    // single lightmap\n    fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n    fixed3 lm = DecodeLightmap(lmtex);\n#elif DIRLIGHTMAP_COMBINED\n    // directional lightmaps\n    fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n    half3 lm = DecodeLightmap(lmtex);\n#elif DIRLIGHTMAP_SEPARATE\n    // directional with specular - no support\n    half4 lmtex = 0;\n    half3 lm = 0;\n#endif // DIRLIGHTMAP_OFF\n\n#endif // LIGHTMAP_OFF\n\n\n    // realtime lighting: call lighting function\n#ifdef LIGHTMAP_OFF\n    c += LightingToonRamp(o, lightDir, atten);\n#else\n    c.a = o.Alpha;\n#endif\n\n#ifndef LIGHTMAP_OFF\n    // combine lightmaps with realtime shadows\n#ifdef SHADOWS_SCREEN\n#if defined(UNITY_NO_RGBM)\n    c.rgb += o.Albedo * min(lm, atten * 2);\n#else\n    c.rgb += o.Albedo * max(min(lm,(atten * 2)*lmtex.rgb), lm*atten);\n#endif\n#else // SHADOWS_SCREEN\n    c.rgb += o.Albedo * lm;\n#endif // SHADOWS_SCREEN\n#endif // LIGHTMAP_OFF\n\n#ifndef DYNAMICLIGHTMAP_OFF\n    fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n    c.rgb += o.Albedo * DecodeRealtimeLightmap(dynlmtex);\n#endif\n\n    UNITY_APPLY_FOG(IN.fogCoord, c); // apply fog\n    UNITY_OPAQUE_ALPHA(c.a);\n    return c;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// outline\n//////////////////////////////////////////////////////////////////////////////\n#include "UnityCG.cginc"\n\nstruct appdata {\n    float4 vertex : POSITION;\n    float3 normal : NORMAL;\n};\n\nstruct v2f {\n    float4 pos : SV_POSITION;\n    UNITY_FOG_COORDS(0)\n        fixed4 color : COLOR;\n};\n\nuniform float _Outline;\nuniform float4 _OutlineColor;\n\nv2f vert(appdata v) {\n    v2f o;\n    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);\n\n    float3 norm = normalize(mul((float3x3)UNITY_MATRIX_IT_MV, v.normal));\n    float2 offset = TransformViewToProjection(norm.xy);\n\n    o.pos.xy += offset * o.pos.z * _Outline;\n    o.color = _OutlineColor;\n    UNITY_TRANSFER_FOG(o, o.pos);\n    return o;\n}\n\nfixed4 frag(v2f i) : SV_Target\n{\n    UNITY_APPLY_FOG(i.fogCoord, i.color);\n    return i.color;\n}\n\n改造準備完了。\n改造した\n\nalpha blending\n影と陰の合成とRampの適用法を改造\n\nなかなか難しい。\n顔は別光源にして影が落ちないようにする必要があるね。\n顔にDiffuseは必要ない。\n#include "HLSLSupport.cginc"\n#include "UnityShaderVariables.cginc"\n// Surface shader code generated based on:\n// writes to per-pixel normal: no\n// writes to emission: no\n// needs world space reflection vector: no\n// needs world space normal vector: no\n// needs screen space position: no\n// needs world space position: no\n// needs view direction: no\n// needs world space view direction: no\n// needs world space position for lighting: no\n// needs world space view direction for lighting: no\n// needs world space view direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from normal: no\n// 1 texcoords actually used\n//   float2 _MainTex\n#define UNITY_PASS_FORWARDBASE\n#include "UnityCG.cginc"\n#include "Lighting.cginc"\n#include "AutoLight.cginc"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line 10 ""\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//#pragma surface surf ToonRamp\n\nsampler2D _Ramp;\n\n// custom lighting function that uses a texture ramp based\n// on angle between light direction and normal\n//#pragma lighting ToonRamp exclude_path:prepass\ninline half3 LightingToonRamp(half3 rgb, half diffuse, half atten)\n{\n    float d = min(diffuse, atten);\n    float3 ramp = tex2D(_Ramp, float2(d, d));\n    return rgb * ramp;\n}\n\nsampler2D _MainTex;\nfloat4 _Color;\n\nstruct Input {\n    float2 uv_MainTex : TEXCOORD0;\n};\n\nvoid surf(Input IN, inout SurfaceOutput o) {\n    half4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;\n    o.Albedo = c.rgb;\n    o.Alpha = c.a;\n}\n\n\n// vertex-to-fragment interpolation data\n// no lightmaps:\n#ifdef LIGHTMAP_OFF\nstruct v2f_surf {\n    float4 pos : SV_POSITION;\n    float2 pack0 : TEXCOORD0; // _MainTex\n    half3 worldNormal : TEXCOORD1;\n    fixed3 vlight : TEXCOORD2; // ambient/SH/vertexlights\n    SHADOW_COORDS(3)\n        UNITY_FOG_COORDS(4)\n#if SHADER_TARGET >= 30\n        float4 lmap : TEXCOORD5;\n#endif\n};\n#endif\n// with lightmaps:\n#ifndef LIGHTMAP_OFF\nstruct v2f_surf {\n    float4 pos : SV_POSITION;\n    float2 pack0 : TEXCOORD0; // _MainTex\n    half3 worldNormal : TEXCOORD1;\n    float4 lmap : TEXCOORD2;\n    SHADOW_COORDS(3)\n        UNITY_FOG_COORDS(4)\n#ifdef DIRLIGHTMAP_COMBINED\n        fixed3 tSpace0 : TEXCOORD5;\n    fixed3 tSpace1 : TEXCOORD6;\n    fixed3 tSpace2 : TEXCOORD7;\n#endif\n};\n#endif\nfloat4 _MainTex_ST;\n\n// vertex shader\nv2f_surf vert_surf(appdata_full v) {\n    v2f_surf o;\n    UNITY_INITIALIZE_OUTPUT(v2f_surf, o);\n    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);\n    o.pack0.xy = TRANSFORM_TEX(v.texcoord, _MainTex);\n    float3 worldPos = mul(_Object2World, v.vertex).xyz;\n    fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);\n#if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)\n    fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n    fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n    fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n#endif\n#if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)\n    o.tSpace0 = fixed3(worldTangent.x, worldBinormal.x, worldNormal.x);\n    o.tSpace1 = fixed3(worldTangent.y, worldBinormal.y, worldNormal.y);\n    o.tSpace2 = fixed3(worldTangent.z, worldBinormal.z, worldNormal.z);\n#endif\n    o.worldNormal = worldNormal;\n#ifndef DYNAMICLIGHTMAP_OFF\n    o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#endif\n#ifndef LIGHTMAP_OFF\n    o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n#endif\n\n    // SH/ambient and vertex lights\n#ifdef LIGHTMAP_OFF\n#if UNITY_SHOULD_SAMPLE_SH\n    float3 shlight = ShadeSH9(float4(worldNormal, 1.0));\n    o.vlight = shlight;\n#else\n    o.vlight = 0.0;\n#endif\n#ifdef VERTEXLIGHT_ON\n    o.vlight += Shade4PointLights(\n            unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n            unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n            unity_4LightAtten0, worldPos, worldNormal);\n#endif // VERTEXLIGHT_ON\n#endif // LIGHTMAP_OFF\n\n    TRANSFER_SHADOW(o); // pass shadow coordinates to pixel shader\n    UNITY_TRANSFER_FOG(o, o.pos); // pass fog coordinates to pixel shader\n    return o;\n}\n\n// fragment shader\nfixed4 frag_surf(v2f_surf IN) : SV_Target{\n    // prepare and unpack data\n    Input surfIN;\n    UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n    surfIN.uv_MainTex.x = 1.0;\n    surfIN.uv_MainTex = IN.pack0.xy;\n    float3 lightDir = _WorldSpaceLightPos0.xyz;\n#ifdef UNITY_COMPILER_HLSL\n    SurfaceOutput o = (SurfaceOutput)0;\n#else\n    SurfaceOutput o;\n#endif\n    o.Albedo = 0.0;\n    o.Emission = 0.0;\n    o.Specular = 0.0;\n    o.Alpha = 0.0;\n    o.Gloss = 0.0;\n    fixed3 normalWorldVertex = fixed3(0,0,1);\n    o.Normal = IN.worldNormal;\n    normalWorldVertex = IN.worldNormal;\n\n    // call surface function\n    surf(surfIN, o);\n\n    // compute lighting &amp; shadowing factor\n    UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n        fixed4 c = 0;\n#ifdef LIGHTMAP_OFF\n    c.rgb += o.Albedo * IN.vlight;\n#endif // LIGHTMAP_OFF\n\n    // lightmaps\n#ifndef LIGHTMAP_OFF\n#ifdef DIRLIGHTMAP_OFF\n    // single lightmap\n    fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n    fixed3 lm = DecodeLightmap(lmtex);\n#elif DIRLIGHTMAP_COMBINED\n    // directional lightmaps\n    fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n    half3 lm = DecodeLightmap(lmtex);\n#elif DIRLIGHTMAP_SEPARATE\n    // directional with specular - no support\n    half4 lmtex = 0;\n    half3 lm = 0;\n#endif // DIRLIGHTMAP_OFF\n\n#endif // LIGHTMAP_OFF\n\n\n    // realtime lighting: call lighting function\n    c.a = o.Alpha;\n#ifdef LIGHTMAP_OFF\n#ifndef USING_DIRECTIONAL_LIGHT\n    lightDir = normalize(lightDir);\n#endif\n    half diffuse = max(0, dot(o.Normal, lightDir));\n    c.rgb += LightingToonRamp(o.Albedo, diffuse, atten);\n#else\n\n    // combine lightmaps with realtime shadows\n#ifdef SHADOWS_SCREEN\n#if defined(UNITY_NO_RGBM)\n    c.rgb += o.Albedo * min(lm, atten * 2);\n#else\n    c.rgb += o.Albedo * max(min(lm,(atten * 2)*lmtex.rgb), lm*atten);\n#endif\n#else // SHADOWS_SCREEN\n    c.rgb += o.Albedo * lm;\n#endif // SHADOWS_SCREEN\n#endif // LIGHTMAP_OFF\n\n#ifndef DYNAMICLIGHTMAP_OFF\n    fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n    c.rgb += o.Albedo * DecodeRealtimeLightmap(dynlmtex);\n#endif\n\n    UNITY_APPLY_FOG(IN.fogCoord, c); // apply fog\n\n    return c;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// outline\n//////////////////////////////////////////////////////////////////////////////\n#include "UnityCG.cginc"\n\nstruct appdata {\n    float4 vertex : POSITION;\n    float3 normal : NORMAL;\n};\n\nstruct v2f {\n    float4 pos : SV_POSITION;\n    UNITY_FOG_COORDS(0)\n        fixed4 color : COLOR;\n};\n\nuniform float _Outline;\nuniform float4 _OutlineColor;\n\nv2f vert(appdata v) {\n    v2f o;\n    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);\n\n    float3 norm = normalize(mul((float3x3)UNITY_MATRIX_IT_MV, v.normal));\n    float2 offset = TransformViewToProjection(norm.xy);\n\n    o.pos.xy += offset * min(1, o.pos.z) * _Outline; // 太さ調整\n    o.color = _OutlineColor;\n    UNITY_TRANSFER_FOG(o, o.pos);\n    return o;\n}\n\nfixed4 frag(v2f i) : SV_Target\n{\n    UNITY_APPLY_FOG(i.fogCoord, i.color);\n    return i.color;\n}\n</code></pre></div>'}}))}var r=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?a.createElement(e,n,a.createElement(i,n)):i(n)},l=(o(8678),o(8838));const d={code:n=>{let{children:e,className:o}=n;return o?a.createElement(l.Z,{className:o},e):a.createElement("code",null,e)}};function f(n){let{data:e,children:o}=n;return a.createElement(a.Fragment,null,a.createElement("h1",null,e.mdx.frontmatter.title),a.createElement(t.Zo,{components:d},o))}function s(n){return a.createElement(f,n,a.createElement(r,n))}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2016-01-12-unity-toon-md-444d4ed257070a291936.js.map