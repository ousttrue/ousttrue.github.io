"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[130],{634:function(n,e,o){o.r(e);var a=o(1151),i=o(7294);function t(n){const e=Object.assign({p:"p",pre:"pre",code:"code"},(0,a.ah)(),n.components);return i.createElement(i.Fragment,null,i.createElement(e.p,null,"謎のクラッシュ(FFI でネイティブプラグインがアクセス違反で死ぬ)を追跡するため、\nVC のデバッガをアタッチするべく自前ビルドする。\nnode-v5.3.0.tar.xz"),"\n",i.createElement(e.pre,null,i.createElement(e.code,null,"7zipで解凍。\npython2系にpathを通してvcbuild.batをたたく。\n> vcbuild.bat\n\nv8もlibuvも全部入りらしくあっさりとほぼビルドできた。\nSignTool Error: No certificates were found that met all the given criteria.\nFailed to sign exe\n\ndocument\nhttps://github.com/nodejs/node-v0.x-archive/wiki/Installation#building-on-windows\ndebugビルドの作り方はこう。\n> vcbuild.bat nosign debug\n\nnodeをデバッグ実行\n\nnode-v5.3.0にnode.slnができているのでこれをVisualStudio2015で開く。\nnodeをスタートアッププロジェクトに指定\nnodeの設定のdebugタブで、カレントディレクトリとコマンドライン引数を指定\nf5\n\n例外が再現した\nvoid CallbackInfo::DispatchToV8(callback_info *info, void *retval, void **parameters, bool dispatched) {\n  Nan::HandleScope scope;\n\n  static const char* errorMessage = \"ffi fatal: callback has been garbage collected!\";\n\n  if (info->function == NULL) {\n    // throw an error instead of segfaulting.\n    // see: https://github.com/rbranson/node-ffi/issues/72\n    if (dispatched) {\n        Local<Value> errorFunctionArgv[1];\n        errorFunctionArgv[0] = Nan::New<String>(errorMessage).ToLocalChecked();\n        info->errorFunction->Call(1, errorFunctionArgv);\n    }\n    else {\n      Nan::ThrowError(errorMessage);\n    }\n  } else {\n    // invoke the registered callback function\n    Local<Value> functionArgv[2];\n    functionArgv[0] = WrapPointer((char *)retval, info->resultSize);\n    functionArgv[1] = WrapPointer((char *)parameters, sizeof(char *) * info->argc);\n    Local<Value> e = info->function->Call(2, functionArgv); // <-- ここ。functionがnullptrになってるよ!\n    if (!e->IsUndefined()) {\n      if (dispatched) {\n        Local<Value> errorFunctionArgv[1];\n        errorFunctionArgv[0] = e;\n        info->errorFunction->Call(1, errorFunctionArgv);\n      } else {\n        Nan::ThrowError(e);\n      }\n    }\n  }\n}\n\nううむ。if文でnullチェックしてるのにelse側に落ちてるな。矢張りスレッドとかGCが絡んでいそうな気がするぞ。\nちょうどnode-ffiでjavascriptのコールバックを呼び出しているところなのではないか。\nコールスタック\n>   ffi_bindings.node!CallbackInfo::DispatchToV8(_callback_info * info, void * retval, void * * parameters, bool dispatched) 行 73   C++\n    ffi_bindings.node!CallbackInfo::WatcherCallback(uv_async_s * w, int revents) 行 94   C++\n    node.exe!uv_process_async_wakeup_req(uv_loop_s * loop, uv_async_s * handle, uv_req_s * req) 行 97    C\n\nよく見るとまさにffi_bindings.node(node-ffiのネイティブプラグイン)内で問題が発生している。\n呼び出しスレッドはメインスレッドか・・・。\n何回も試してみると例外がむしろdllのスレッド側で起こることの方が多い。\n他にWaitSingleObjectがstdcallの関数をスレッド実行しているものが４本。\nひょっとして、コールバックの頻度が高すぎなんじゃないのか・・・。\ncallback_infoはffiの構造体。こいつのデストラクタが呼ばれているのが確認できれば手がかりになるな。\nで、callback_info->functionを解放する下記の部分がメインスレッドから呼ばれて、その後に\nスレッドからのコールバック呼び出しがクラッシュしているらしいことを発見。\nnode_modules/ffi/src/callback_info.cc\n/*\n * Called when the `ffi_closure *` pointer (actually the \"code\" pointer) get's\n * GC'd on the JavaScript side. In this case we have to unwrap the\n * `callback_info *` struct, dispose of the JS function Persistent reference,\n * then finally free the struct.\n */\n\nvoid closure_pointer_cb(char *data, void *hint) {\n  callback_info *info = reinterpret_cast<callback_info *>(hint);\n  // dispose of the Persistent function reference\n  delete info->function;\n  info->function = NULL;\n  // now we can free the closure data\n  ffi_closure_free(info);\n}\n\nコールスタック\n>   ffi_bindings.node!closure_pointer_cb(char * data, void * hint) 行 42 C++\n    node.exe!node::Buffer::CallbackInfo::WeakCallback(v8::Isolate * isolate, v8::Local<v8::Object> object) 行 159    C++\n\n     省略\n\n    node.exe!v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace space, const char * gc_reason, const v8::GCCallbackFlags callbackFlags) 行 556 C++\n\n     省略\n\n    node.exe!node::Buffer::New(v8::Isolate * isolate, char * data, unsigned int length, void (char *, void *) * callback, void * hint) 行 347    C++\n    binding.node!`anonymous namespace'::WrapPointer(char * ptr, unsigned int length) 行 147  C++\n    binding.node!`anonymous namespace'::ReadPointer(const Nan::FunctionCallbackInfo<v8::Value> & info) 行 261    C++\n    binding.node!Nan::imp::FunctionCallbackWrapper(const v8::FunctionCallbackInfo<v8::Value> & info) 行 174  C++\n\nなんか、GCが発動して回収されちゃっているぽい？\n2015/09/20\n* Nodejs GC is crashing when a C function is returning NULL\nむしろこっちか\n2015/11/05\n* Node.js v5.0.0でnode-ffiやNodObjCが動かない\nしかし、うちのnode.jsは\n> node --version\nv5.3.0\n\nうむ。\nむしろこっちか\n2015/09/15\n* ffi.Function underlying Callback is garbage collected\n死ななくなった。これっぽいな。\n64bit版で試してみる\nこれはこれで死ぬ。\nまとめ\n\nnode-ffiのFunctionでGCに回収されてしまう書き方のところがある(FFI.Function内)\n32bit版のnode-ffiではSTDCALLを指定できる(ABI=2)\n64bit版のnode-ffiではIA64にされるのでSTDCALLは動かぬ\n\ngypでのIA64とX64の扱いの違いがわかったら修正できるかな。\nX86_WIN32の時にFFI_STDCALLを定義する修正をプルリクしてみよう。\n")))}e.default=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,a.ah)(),n.components);return e?i.createElement(e,n,i.createElement(t,n)):t(n)}},1151:function(n,e,o){o.d(e,{ah:function(){return t}});var a=o(7294);const i=a.createContext({});function t(n){const e=a.useContext(i);return a.useMemo((()=>"function"==typeof n?n(e):{...e,...n}),[e,n])}}}]);
//# sourceMappingURL=component---content-posts-2015-12-21-node-self-build-md-486dc9b3fe3d25c61b4e.js.map