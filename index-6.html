<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="ja">
<head>
<meta charset="utf-8">
<meta name="description" content="作業記録">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>三次元日誌 (過去の記事 6ページ目) | 三次元日誌</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ja" href="rss.xml">
<link rel="canonical" href="https://ousttrue.github.io/index-6.html">
<link rel="prev" href="index-7.html" type="text/html">
<link rel="next" href="index-5.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">本文を読み飛ばす</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href=".">

            <span id="blog-title">三次元日誌</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav"></ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="books" class="nav-link">MemoBooks</a>
                </li>
<li class="nav-item">
<a href="archive.html" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="categories/index.html" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="rss.xml" class="nav-link">RSS feed</a>
                </li>
<li class="nav-item">
<a href="about" class="nav-link">About</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
    
        

    
        
    <div class="postindex">
            <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2013/10/29/variant/" class="u-url">wafでdebugとreleaseの設定を記述する(variant)</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2013/10/29/variant/" rel="bookmark">
            <time class="published dt-published" datetime="2013-10-29T00:00:00+09:00" itemprop="datePublished" title="2013-10-29 00:00">2013-10-29 00:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <div>
<p>wafでdebugとreleaseの設定を記述する(variant)
wafでdebug版とrelease版の出力を分けるにはvariantなる機能を使う。
+hello
  +hello.cpp
  +waf
  +wscript</p>
<p>と前回と同様のプロジェクト。 wscriptを以下のように記述する。</p>
<h2>coding: utf-8</h2>
<p>APPNAME='hello'
VERSION='1.0.0'</p>
<p>def configure(conf):
    # config 'debug'を作る
    conf.setenv('debug')
    # debugの設定
    conf.env['MSVC_TARGETS'] = ['x86']
    conf.load('msvc')
    conf.env.CXXFLAGS = ['/nologo', '/EHsc']
    # PDBやNDEBUG等の設定をきっちり書く必要がある</p>
<pre class="code literal-block"><span></span># config 'release'を作る。debugの設定は引き継がない
conf.setenv('release')
# releaseの設定
conf.env['MSVC_TARGETS'] = ['x86']
conf.load('msvc')
conf.env.CXXFLAGS = ['/nologo', '/EHsc']
</pre>

<h2>BuildContextの設定</h2>
<p>def build(bld):
    bld.program(
            source='hello.cpp',
            target=APPNAME
            )</p>
<p>from waflib.Build import BuildContext</p>
<h2>BuildContextを使うコマンド</h2>
<p>class BuildDebug(BuildContext):
    # config 'debug' を使うvariant
    # 出力ディレクトリがbuild/debugに変わる
    variant = "debug"
    # 呼び出しコマンドはbuild_debug
    cmd = "build_debug"</p>
<h2>BuildContextを使うコマンド</h2>
<p>class BuildRelease(BuildContext):
    # config 'release' を使うvariant
    # 出力ディレクトリがbuild/releaseに変わる
    variant = "release"
    # 呼び出しコマンドはbuild_release
    cmd = "build_release"</p>
<p>variantという概念を使う。
http://docs.waf.googlecode.com/git/book_17/single.html の 6.2.2.
Changing the output directory Configuration sets for variants
に記述がある。
使う</p>
<blockquote>
<p>python waf --help
waf [commands] [options]</p>
</blockquote>
<p>Main commands (example: ./waf build -j4)
  build        : executes the build
  build_debug  :
  build_release:
:
:
省略</p>
<p>という感じでbuild_debug, build_releaseが増える。</p>
<blockquote>
<p>python waf build_debug
Waf: Entering directory <code>C:\work\_waf\debug_release\build\debug'
[1/2] cxx: hello.cpp -&gt; build\debug\hello.cpp.1.o
hello.cpp
[2/2] cxxprogram: build\debug\hello.cpp.1.o -&gt; build\debug\hello.exe build\debug\hello.exe.manifest
Waf: Leaving directory</code>C:\work_waf\debug_release\build\debug'
'build_debug' finished successfully (0.487s)</p>
</blockquote>
<p>素のビルドはエラーになった。たぶん対象になる名無しのconfigが存在しないため。</p>
<blockquote>
<p>python waf build
Waf: Entering directory <code>C:\work\_waf\debug_release\build'
[1/2] cxx: hello.cpp -&gt; build\hello.cpp.1.o
Waf: Leaving directory</code>C:\work_waf\debug_release\build'
Build failed
:
:
省略</p>
</blockquote>
<p>ということで素のビルドの時にメッセージを表示して止めるようにする。
buildメソッドの先頭にwaf book通りの記述を入れる。</p>
<h2>BuildContextの設定</h2>
<p>def build(bld):
    if not bld.variant:
         bld.fatal('call "waf build_debug" or "waf build_release", and try "waf --help"')
    bld.program(
            source='hello.cpp',
            target=APPNAME
            )</p>
<blockquote>
<p>python waf build
Waf: Entering directory `C:\work_waf\debug_release\build'
call "waf build_debug" or "waf build_release", and try "waf --help"
python waf clean
call "waf build_debug" or "waf build_release", and try "waf --help"</p>
</blockquote>
<p>build以外にもbuildメソッド(BuildContext)を使うコマンドがあって、
http://docs.waf.googlecode.com/git/book_17/single.html の 12.1.2.
Context classes のクラス図によると ListContext, CleanContext,
StepContext, InstallContext, UninstallContext
がBuildContextを継承しているのでこれに対応するコマンド
それぞれにdebug版、release版を定義してやる必要がある。
waf bookに書いてあるようにコマンドclassの記述を変える。
from waflib.Build import BuildContext, ListContext, CleanContext, StepContext, InstallContext, UninstallContext</p>
<p>CONTEXTS=[BuildContext, ListContext, CleanContext, StepContext, InstallContext, UninstallContext]
VARIANTS=['debug', 'release']</p>
<p>for context in CONTEXTS:
    for variant_name in VARIANTS:
        name = context.<strong>name</strong>.replace('Context','').lower()
        class tmp(context):
            cmd = name + '_' + variant_name
            variant = variant_name</p>
<p>helpを見ると大量に定義したコマンドが増える。</p>
<blockquote>
<p>python waf --help
waf [commands] [options]</p>
</blockquote>
<p>Main commands (example: ./waf build -j4)
  build            : executes the build
  build_debug      :
  build_release    :
  clean            : cleans the project
  clean_debug      :
  clean_release    :
  configure        : configures the project
  dist             : makes a tarball for redistributing the sources
  distcheck        : checks if the project compiles (tarball from 'dist')
  distclean        : removes the build directory
  install          : installs the targets on the system
  install_debug    :
  install_release  :
  list             : lists the targets to execute
  list_debug       :
  list_release     :
  step             : executes tasks in a step-by-step fashion, for debugging
  step_debug       :
  step_release     :
  uninstall        : removes the targets installed
  uninstall_debug  :
  uninstall_release:
  update           : updates the plugins from the <em>waflib/extras</em> directory
:
:
省略</p>
<blockquote>
<p>python waf clean_debug build_debug
'clean_debug' finished successfully (0.087s)
Waf: Entering directory <code>C:\work\_waf\debug_release\build\debug'
[1/2] cxx: hello.cpp -&gt; build\debug\hello.cpp.1.o
hello.cpp
[2/2] cxxprogram: build\debug\hello.cpp.1.o -&gt; build\debug\hello.exe build\debug\hello.exe.manifest
Waf: Leaving directory</code>C:\work_waf\debug_release\build\debug'
'build_debug' finished successfully (0.451s)</p>
</blockquote>
<p>これでdebug, releaseの使い分けはできるようになった。
variantを追加する
64bitビルドや、gccのvariantを追加してみた。</p>
<h2>coding: utf-8</h2>
<p>APPNAME='hello'
VERSION='1.0.0'</p>
<p>VARIANTS=[
'vc_debug', 'vc_release', 'vc64_debug', 'vc64_release',
'gcc_debug', 'gcc_release',
]</p>
<p>def configure(conf):
    # config 'debug'を作る
    conf.setenv('debug')
    # debugの設定
    conf.env['MSVC_VERSIONS'] = ['msvc 10.0']
    conf.env['MSVC_TARGETS'] = ['x86']
    conf.load('msvc')
    conf.env.CXXFLAGS = ['/nologo', '/EHsc']
    # PDBやNDEBUG等の設定をきっちり書く必要がある</p>
<pre class="code literal-block"><span></span># config 'release'を作る。debugの設定は引き継がない
conf.setenv('release')
# releaseの設定
conf.env['MSVC_VERSIONS'] = ['msvc 10.0']
conf.env['MSVC_TARGETS'] = ['x86']
conf.load('msvc')
conf.env.CXXFLAGS = ['/nologo', '/EHsc']

# config 'debug'を作る
conf.setenv('vc64_debug')
# debugの設定
conf.env['MSVC_VERSIONS'] = ['msvc 10.0']
conf.env['MSVC_TARGETS'] = ['x64']
conf.load('msvc')
conf.env.CXXFLAGS = ['/nologo', '/EHsc']
# PDBやNDEBUG等の設定をきっちり書く必要がある

# config 'release'を作る。debugの設定は引き継がない
conf.setenv('vc64_release')
# releaseの設定
conf.env['MSVC_VERSIONS'] = ['msvc 10.0']
conf.env['MSVC_TARGETS'] = ['x64']
conf.load('msvc')
conf.env.CXXFLAGS = ['/nologo', '/EHsc']

# config 'debug'を作る
conf.setenv('gcc_debug')
# debugの設定
conf.load('gxx')
conf.env.CXXFLAGS = ['-g']
conf.env.LINKFLAGS = ['-g']

# config 'release'を作る。debugの設定は引き継がない
conf.setenv('gcc_release')
# releaseの設定
conf.load('gxx')
conf.env.CXXFLAGS = ['-O2']
</pre>

<h2>BuildContextの設定</h2>
<p>def build(bld):
    if not bld.variant:
         bld.fatal('call "waf build_debug" or "waf build_release", and try "waf --help"')
    bld.program(
            source='hello.cpp',
            target=APPNAME
            )</p>
<p>from waflib.Build import BuildContext, ListContext, CleanContext, StepContext, InstallContext, UninstallContext</p>
<p>CONTEXTS=[BuildContext, ListContext, CleanContext, StepContext, InstallContext, UninstallContext]</p>
<p>for context in CONTEXTS:
    for variant_name in VARIANTS:
        name = context.<strong>name</strong>.replace('Context','').lower()
        class tmp(context):
            cmd = name + '_' + variant_name
            variant = variant_name</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2013/10/27/rightvalue/" class="u-url">右辺値の理解</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2013/10/27/rightvalue/" rel="bookmark">
            <time class="published dt-published" datetime="2013-10-27T00:00:00+09:00" itemprop="datePublished" title="2013-10-27 00:00">2013-10-27 00:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <div>
<p>右辺値の理解
そろそろ右辺値を抑えておきたい気がしたのでテストコードを書きながら実験してみた(VC2010
Express Edition)。
http://msdn.microsoft.com/ja-jp/library/vstudio/dd293665.aspx
を参考に右辺値実験クラスRightKunを書いた。
コピーコンストラクタと同じくシグニチャは決まったものがあって
右辺値代入演算のオーバーロードとペアになるらしい。
各関数の呼び出しでメッセージを表示するように仕込んだ。
https://gist.github.com/ousttrue/7178535</p>
<h2>include <memory></memory>
</h2>
<h2>include <iostream></iostream>
</h2>
<p>class RightKun
{
public:
    RightKun()
    {
        std::cout &lt;&lt; this &lt;&lt; ":default constructor" &lt;&lt; std::endl;
    };</p>
<pre class="code literal-block"><span></span><span class="o">~</span><span class="nt">RightKun</span><span class="o">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">this</span> <span class="o">&lt;&lt;</span> <span class="s2">":destructor"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="nt">左辺値によるコピーコンストラクタ</span>
<span class="nt">RightKun</span><span class="o">(</span><span class="nt">const</span> <span class="nt">RightKun</span> <span class="o">&amp;</span><span class="nt">src</span><span class="o">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">this</span> <span class="o">&lt;&lt;</span> <span class="s2">":copy constructor: "</span><span class="p">;</span>
    <span class="err">*this=src</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">RightKun</span> <span class="o">&amp;</span><span class="nt">operator</span><span class="o">=(</span><span class="nt">const</span> <span class="nt">RightKun</span> <span class="o">&amp;</span><span class="nt">src</span><span class="o">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">"left value operator= "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">src</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="err">return</span> <span class="err">*this</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="nt">右辺値によるムーブコンストラクタ</span>
<span class="nt">RightKun</span><span class="o">(</span><span class="nt">RightKun</span> <span class="o">&amp;&amp;</span><span class="nt">src</span><span class="o">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">this</span> <span class="o">&lt;&lt;</span> <span class="s2">":move constructor: "</span><span class="p">;</span>
    <span class="err">*this=</span><span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="nf">move</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
<span class="p">}</span>

<span class="nt">RightKun</span> <span class="o">&amp;</span><span class="nt">operator</span><span class="o">=(</span><span class="nt">RightKun</span> <span class="o">&amp;&amp;</span><span class="nt">src</span><span class="o">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="p">:</span><span class="o">:</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">"right value operator= "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">src</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="err">return</span> <span class="err">*this</span><span class="p">;</span>
<span class="p">}</span>
</pre>

<p>};</p>
<p>とりあえず使ってみる
{
    // default
    RightKun r1;</p>
<pre class="code literal-block"><span></span>// copy
RightKun r2=r1;
</pre>

<p>}</p>
<p>結果
0025FE33:default constructor
0025FE32:copy constructor: left value operator= 0025FE33
0025FE32:destructor
0025FE33:destructor </p>
<p>問題ない。
通常の値返しの呼び出し
RightKun create()
{
    return RightKun();
}</p>
<p>使う
{
    RightKun r=create();
}</p>
<p>結果
0025FE2E:default constructor
0025FE2E:destructor</p>
<p>おや、コピーコンストラクタが呼ばれない。
RVO
調べてみたらこれはコンパイラのRVO(Return Value Optimization)という機能で
返り値が変数に代入されていない場合(いわゆる右辺値)に代入を無しにできるというものらしい。
なるほど。
よくある
vec3 cross(const vec3 &amp;lhs, const vec3 &amp;rhs)
{
  // x, y, z...
  return vec3(x, y, z);
}</p>
<p>vec3 out=cross(v1, v2);</p>
<p>的なものを
void cross(vec3 <em>out, const vec3 </em>lhs, const vec3 *rhs)
{
  // x, y, z...
  out-&gt;x=x;
  out-&gt;y=y;
  out-&gt;z=z;
}</p>
<p>vec3 out;
cross(&amp;out, &amp;v1, &amp;v2);</p>
<p>と書いても別にパフォーマンスが変わらんと言うことですな。
最近のコンパイラなら大丈夫というのは、RVOがたぶん効くということか。
むしろ適切なコンストラクタで初期化できるので前者の方がよろしいな。
後者だとデフォルトコンストラクタが0で初期化しないようにしたくなるし、
いろいろよろしくない。
RVOできないようにする
先ほどの関数をRVOが無効になるように改造してみる。
RightKun createNoRVO()
{
    RightKun r;
    return r;
}</p>
<p>使う
{
    RightKun r=createNoRVO();
}</p>
<p>結果
0025FDFB:default constructor
0025FE31:move constructor: right value operator= 0025FDFB
0025FDFB:destructor
0025FE31:destructor</p>
<p>期せずしてムーブコンストラクタ呼び出しが発生した。
どういう条件で切り替わるんだこれは。
調べてみるとムーブコンストラクタはRVOが効かない時に使われる、という記述を見つけた。
http://msdn.microsoft.com/ja-jp/library/vstudio/dd293668.aspx</p>
<p>コンパイラが戻り値の最適化 (RVO) または名前付き戻り値の最適化 (NRVO)
を使用できない場合に、移動セマンティクスが役立ちます。
このような場合、型が移動コンストラクターを定義していれば、コンパイラはその移動コンストラクターを呼び出します</p>
<p>ほぅ。
NRVOというのはRVOの進化型で戻り値が変数に代入(名前付き)されていても有効になるものらしい。上記の例だと単純なのでNRVOできそうな気もするがコンパイルオプションとかですかね。
コンパイラが代入の右側を破棄してもよいと判断した場合にムーブコンストラクタが定義されていれば自動的にそっちを使うという暗黙的な仕組みのようだ。
g++(4.6)ではNRVOされた
右側を破棄できないようにしてみよう
RightKun createCanNotMove(const RightKun &amp;src, bool hoge)
{
    if(hoge){
        return src;
    }
    return RightKun();
}</p>
<p>使う
{
    RightKun r=createCanNotMove(RightKun(), true);
}</p>
<p>結果
0025FE2C:default constructor
0025FE30:copy constructor: left value operator= 0025FE2C
0025FE2C:destructor
0025FE30:destructor</p>
<p>予定通りコピーコンストラクタ呼び出し。問題ない。
引数をRightKun&amp;&amp;にしてみる
ここでsrcの型をRightKun&amp;&amp;にすればムーブコンストラクタ呼び出しできるのではないか。
static RightKun rightValueArg(RightKun &amp;&amp;src, bool hoge)
{
    if(hoge){
        return src;
    }
    return RightKun();
}</p>
<p>使う
{
    RightKun r=rightValueArg(RightKun(), true);
}</p>
<p>結果
0025FE2C:default constructor
0025FE30:copy constructor: left value operator= 0025FE2C
0025FE2C:destructor
0025FE30:destructor</p>
<p>ところがぎっちょん、コピーの方。何故かというとrightValueArg内ではsrcはただの変数、左辺値として
扱われるのだ。RightKun&amp;&amp;は実引数の制限だ。
試しに以下のように呼び出すとエラーになる。
{
  RightKun leftvalue;
  RightKun r=rightValueArg(leftvalue, true);
}</p>
<p>エラー
error C2664: 'rightValueArg' : 1 番目の引数を 'RightKun' から 'RightKun &amp;&amp;' に変換できません。</p>
<p>srcが右辺値であることを明示する
プログラマはsrcが右辺値であることを明示できる。
static RightKun moveExplicit(RightKun &amp;&amp;src, bool hoge)
{
    if(hoge){
        return static_cast<rightkun>(src);
    }
    return RightKun();
}</rightkun></p>
<p>使う
{
    RightKun r=moveExplicit(RightKun(), true);
}</p>
<p>結果
0025FE2B:default constructor
0025FE2F:move constructor: right value operator= 0025FE2B
0025FE2B:destructor
0025FE2F:destructor</p>
<p>意図通りにムーブコンストラクタが呼ばれた。
で、このキャストをラップするのがstd::moveですよと。
ただし、std::moveした変数をその後で使わないのはプログラマの責任と。
ということで右辺値とムーブコンストラクタのなんたるかがなんとなく分かった。
ムーブコンストラクタを呼ぶかどうかはコンパイラが判断するので
使うほうは気にしなくても、知らないうちにムーブコンストラクタが呼ばれてパフォーマンス上の恩恵を受けることができるということですな。
知っていればstd::moveによりムーブコンストラクタの呼び出しを増やせるかもしれない。
unique_ptrでstd::moveを要求されるのはコピーコンストラクタを無効にしつつ、
ムーブコンストラクタを定義している故と類推できた。
だいたい分かった結果、
自分でムーブコンストラクタを定義するクラスを書くことはあまり無さそうな気がした。
だめな書き方
最後に右辺値を返す関数を書こうとして最初にはまった、だめなバージョンを書いておく
RightKun &amp;&amp;moveFail()
{
    return RightKun();
}</p>
<p>使う
{
    RightKun r=moveFail();
}</p>
<p>結果
0025FE07:default constructor
0025FE07:destructor
0025FE2D:move constructor: right value operator= 0025FE07
0025FE2D:destructor</p>
<p>destructorが動いた後のポインタで、ムーブコンストラクタが呼び出される
大変危険なコードになった。 なんじゃこりゃー。
gccでやってみたらわかりやすいエラーメッセージが出た。
警告: 一時オブジェクトへの参照を返そうとしています [デフォルトで有効]</p>
<p>関数返り値の宣言に&amp;&amp;を使ってはいけないということか</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2013/10/21/tinkerer/" class="u-url">Tinkererに引越し</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2013/10/21/tinkerer/" rel="bookmark">
            <time class="published dt-published" datetime="2013-10-21T00:00:00+09:00" itemprop="datePublished" title="2013-10-21 00:00">2013-10-21 00:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <div>
<p>Tinkererに引越し
Octpressが手に負えなくなってきたので手軽に使えそうな
tinkererに引越しというかシステムを変更することにした。</p>
<p>http://tinkerer.me/index.html</p>
<p>以下作業手順メモ。
tinkererインストール</p>
<blockquote>
<p>python --version
Python 3.3.0
easy_install tinkerer</p>
</blockquote>
<p>サイト生成</p>
<blockquote>
<p>mkdir pages_src
pages_src&gt; tinkerer --setup
pages_src&gt; gvim conf.py</p>
</blockquote>
<p>記事生成
pages_src&gt; tinkerer --post "tinkerer"</p>
<p>2013/10/21/tinkerer.rstが生成されるとともにmaster.rstのtoctreeに記事が追加される。
categoriesとtagsの違いが良くわからん。
pages_src&gt; gvim 2013/10/21/tinkerer.rst</p>
<p>html生成
pages_src&gt; tinkerer --build</p>
<p>github転送
既存のgithub-pages(user)があるのでそこれに送ってみる。</p>
<blockquote>
<p>mkdir pages_dst
cd pages_dst
pages_dst&gt; git init
pages_dst&gt; git remote add origin url
pages_dst&gt; cp -r ../pages_src/blog/html/* .
pages_dst&gt; echo "" &gt; .nogekyll
pages_dst&gt; git add .
pages_dst&gt; git commit -m init</p>
</blockquote>
<p>上書き。
pages_dst&gt; git push origin master --force</p>
<p>_ではじまるパスが見えない件
最初sphinxtogithubというので修正したのだけど、
よく見たらtinkerのサイトに書いてあった。
http://tinkerer.me/exts/withgithub.html
extensions = [
'tinkerer.ext.blog', 'tinkerer.ext.disqus', 'withgithub',
]</p>
<p>しかし404になるな・・・
https://help.github.com/articles/files-that-start-with-an-underscore-are-missing
.nogekyllがtypoしとった。-&gt; .nojekyll
生成したファイルをローカルで開くとやたら時間がかかる件</p>
<p>C:/Python33/Lib/site-packages/tinkerer-1.2.1-py3.3.egg/tinkerer/themes/boilerplate/layout.html</p>
<p>の
”//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js” を
“http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js“
に変えた。
smb://ajax.googleapis.comとかにアクセスしてるような気がするw
Octpressの記事を移植する
pythonでpandocを呼び出して<em>.markdownから</em>.rstに変換した。
完了
とりあえず移行作業完了。
なんだかんだでoctopressはブラックボックスだったので、
sphinxベースのtinkererの方がわかる(sphinxの方が慣れている)。
octopressではjekyllを良く知らずに使っていたのと、pushするときのタスクがgitをごにょごにょやっているのがよくわからんかった。
いずれにしろ、hatenaの時が日記を一番よく書いていたので自前システムはメンテナンスコストが馬鹿にならんと思った。
中身に入る前にシステムのメンテナンスで力尽きる。</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="github/hidloop/" class="u-url">hidloop</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="github/hidloop/" rel="bookmark">
            <time class="published dt-published" datetime="2013-07-04T00:22:36Z" itemprop="datePublished" title="2013-07-04 00:22">2013-07-04 00:22</time><span class="updated"> (更新日時
                    <time class="dt-updated" datetime="2013-07-16T23:21:34Z" itemprop="dateUpdated" title="2013-07-16 23:21">2013-07-16 23:21</time>)</span>
            </a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <div>
<p><a href="https://github.com/ousttrue/hidloop">https://github.com/ousttrue/hidloop</a></p>
<p>HID utility for Windows</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2013/06/29/mingw/" class="u-url">MinGW環境</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2013/06/29/mingw/" rel="bookmark">
            <time class="published dt-published" datetime="2013-06-29T00:00:00+09:00" itemprop="datePublished" title="2013-06-29 00:00">2013-06-29 00:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <div>
<p>MinGW環境
Irrlichtで開発を進めるにあたって開発環境をVC2010ExpressEditionからMinGWに乗り換えることにした。
後々Linux上でもコンパイルが通るようにしておきたいのでこちらの方が都合がよい。
基本的にはVCでもビルドできる状態を維持する方針ではある。
toolチェイン入手
MinGW本家ではなくTDM-GCCからgcc一式を入手する。
とりあえず32bit版を手に入れた。
bin/mingw32-make.exeをbin/make.exeにコピーしておいた。
cui整備
cygwinから使うとcygwinのincludeやlibを使われてややこしいのでDos窓ベースで開発する。
環境変数等をきっちり設定すればcygwin上でもできるのだけどやり方を忘れてしまったのでとりあえず。</p>
<p>http://www.nyaos.org/ Dos窓でcontrol-P,
control-Nによる履歴検索やパスのデリミタに”/“を使えるようになって快適になる。</p>
<p>プロジェクト構成やソースの修正
スタティックリンクの順番の調整と、一部templateの仕様が違ってコンパイルが通らないところ、
boostのpragmaで自動リンクになっていたところを明示的に記述するなどを
地道に修正した。あとboostのMinGWビルドの生成。
gccの方がVCより制約が厳しい感触だった。typenameが必要な箇所とか、staticメンバ関数のラムダ内での呼び出しで
thisキャプチャが無いエラーが出るなど。
逆に、何故VCでコンパイルが通っていたのか判らないところもあったがとりあえず作業完了。
ついでに、msgpack-rpc-asioの修正部分を更新。
あとでlibOVRのgcc作業をやる。
参考</p>
<p>http://anengineer.tumblr.com/post/13196592706/nyaos-bash-lua</p>
<p><em>nya “’ option histfilesize 3000 option savehistfile
%USERPROFILE%/.history bindkey CTRL</em>P vzlike-previous-history bindkey
CTRL_N vzlike-next-history “’</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2013/06/28/irrlicht-scale/" class="u-url">大きさ基準が必要だ</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2013/06/28/irrlicht-scale/" rel="bookmark">
            <time class="published dt-published" datetime="2013-06-28T00:00:00+09:00" itemprop="datePublished" title="2013-06-28 00:00">2013-06-28 00:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <div>
<p>大きさ基準が必要だ
pmdの読み込み時スケーリングを実装した。
とりあえずドワーフと同じくらいの大きさになるように2.5倍という適当な数値を選択したが、
mmdモデルを一切スケーリングしない(Mikuが20高さ)か実世界のメートル/cm等の単位系になっているかのどちらかにしたい。
現状だと立った状態のカメラの高さが50くらいという謎の単位系であり、
Irrlichtのmediaディレクトリ内のファイル群と大きさがだいたい合うこと以外にメリットが無い。
Oculus使っているので実単位に合わせた方がよいな。cm単位系がよさげな気がする。
しかし、bullet的には9.8Gの方が98Gよりわかりやすような気がする。
bullet界はメートル系でレンダリングはcm系にするという手もあるがはまりそうではある。</p>
<p>シェーダーに梃入れしてもっとMMD風味のトゥーンレンダリングにしよう。</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2013/06/26/oculus-fps/" class="u-url">FPSカメラにOculus回転を仕込んだ</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2013/06/26/oculus-fps/" rel="bookmark">
            <time class="published dt-published" datetime="2013-06-26T00:00:00+09:00" itemprop="datePublished" title="2013-06-26 00:00">2013-06-26 00:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <div>
<p>FPSカメラにOculus回転を仕込んだ
IrrlichtのCSceneNodeAnimatorCameraFPSにOculusを合体した。
Irrlichtのカメラが思ったよりいろいろやっていたのと
ビュー行列を直接扱っていないのに手間取ったがとりあえず当初の目的を達成。
どうにも都合が悪かったので本体をちょっと拡張した。
class CSCameraSceneNode
{
    core::marix4 LeftAffector;
};</p>
<p>レンダリング直前にビュー行列に乗算する行列をセットできるのだが
これが右からの乗算なので、
左からの乗算を追加してこれにOculusの回転を表す行列をセットできるようにした。
これを踏まえてCSceneNodeAnimatorCameraFPSをコピーしてCSceneNodeAnimatorCameraOculusOnFPSを作った。
こいつはFPSカメラのマウスの上下移動を無視するのとlibOVRからの回転値取得と左行列を追加する機能をもつ。
コードはこれなのだけど
https://github.com/ousttrue/onibi/blob/master/irrlicht/examples/HMDIrrlicht/CSceneNodeAnimatorCameraOculusOnFPS.cpp
日記に全部書くには長いし、サンプルが改造版のIrrlichtに依存するので紹介し辛い感じだなぁ。
オフスクリーンレンダリングとシェーダーをサポートした今風のglutみたいなフレームワークがあるとよいのだけど。
今度はmmd表示周りに着手して表示途中までできた。
しかしIrrlicht界のスケーリングの基準がよくわからず。cmのような気もするがなんかもっと適当な値のような気もする。
画像右側の身切れているのはIrrlichtサイズのDwarfである。
mmd界はミクさんの身長20を基準とする統一単位なのだが何かしら基準を決めねばならぬ。
物理の挙動の都合上スケーリングしたくないなーという事情がありどうしたものか。</p>
<p>スカイボックスもOculusで見ると見違えるものがあるなー。
テクスチャとライティングを解決する。 あとpmx。</p>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2013/06/24/oculus-kita/" class="u-url">Oculus来たー</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2013/06/24/oculus-kita/" rel="bookmark">
            <time class="published dt-published" datetime="2013-06-24T00:00:00+09:00" itemprop="datePublished" title="2013-06-24 00:00">2013-06-24 00:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <p>Oculus来たー
6月10くらいにぽちってから２週間くらいで到着。いいタイミングに発注したらしい
Oculusことはじめ
oculus sdk downloadあたりで検索すると見つかるのでいただいてくる。
特にログインとかアカウントとかは必要ない。
SDKにはlibSDKとそれを使ったサンプルがvcプロジェクトで入っている。
oculusの組み込みには２段階あって、ひとつは両目向けに違うレンダリングをする作業、
２つめはOculusのジャイロセンサの値を受け取ってカメラの方向を対応させる作業となっている。
ひとつめのステレオレンダリングに関しては、左目用と右目用にオフスクリーンレンダリングして
それを表示するときにシェーダーで歪ませるというものになる。 歪ませ方は、
RenderTiny_D3D1X_Device.cpp や Oculus_SDK_Overview.pdfに書いてある。
OpenCVとかのカメラ係数に似ているような気もするが同じものかは確認していない。
ふたつめの方は、LibOVRに任せると簡単でusbのHIDデバイスから値を随時取得して
カメラ姿勢に適用するだけ。
LibOVRはこのジャイロの値取得とDXUT的な3Dフレームワークが混合しているので
ジャイロの方だけを抽出して最小限にしたい。
あと自分のコードに混ぜて公開していいのかライセンス的によくわからん。
とりあえずglut化してみよう
はじめに軽くTinyRoomをglutに移植しようと思ったらdxutみたいのがくっついていて途中で投げ出したｗ。
手持ちで、OpenGLシェーダーとかオフスクリーンレンダリングを扱うシステムが無いので
そこから作るのが少し時間がかかるので後回しに。
IrrlichtのカメラをOculus化
方向転換して、ベースにlibOVRを合体した。
githubのものはoculusのステレオレンダリングは実装済みなのでgyroを合成する件のみ。
Irrlichtのカメラ行列の制御がよくわからぬが一応表示。
あとでICameraSceneNodeを継承して作り直そう。
mikuさんprprな感じになるにはもう少しかかるな・・・</p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2013/06/22/irrlicht-vrpn/" class="u-url">IrrlichtにVRPNを合体する</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2013/06/22/irrlicht-vrpn/" rel="bookmark">
            <time class="published dt-published" datetime="2013-06-22T00:00:00+09:00" itemprop="datePublished" title="2013-06-22 00:00">2013-06-22 00:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <div>
<p>IrrlichtにVRPNを合体する
遂にOculusが発送されたらしくHongKong
Postから国内に入ったらしい。今日明日には来るで。
vrpnを仕込む
Oculusが来たら遊ぶべくIrrlichにさらにvrpnを仕込むことにした。
外部入力はこれで一括して捌こうと構想している。
さしあたってはOculusの傾き情報(Quaternion)、マウス、コントローラの入力をvrpn経由にしようかと。
さらには、
Oculusは位置情報が無いのでKinectからスケルトン情報を受けて移動できるようにしたりWiiコン入力をとったりしたい。
WiiMote
plusの内臓ジャイロの値を取れるソースも発見したのでキネクトで手の位置を取ってWiiコンの傾きと合体すればいい感じになるのではないかと妄想(hydraみたいに手が出てくるとこまでいけるのではないか)。
ゆくゆくはARToolKitやOpenCVのマーカー式やつもvrpn経由で合体しやすくなる。</p>
<pre>
         oculus  kinect wiimote 
          A |        |     |
rendering | | sensor |     |
          | V        |     |
      irrlicht 

<p>ということでvrpn作業開始。</p></pre>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/2013/06/17/irrlicht_msgpackrpc/" class="u-url">IrrlichtにMsgPackRPCを仕込む</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        ousttrue
                    </span></p>
            <p class="dateline">
            <a href="posts/2013/06/17/irrlicht_msgpackrpc/" rel="bookmark">
            <time class="published dt-published" datetime="2013-06-17T00:00:00+09:00" itemprop="datePublished" title="2013-06-17 00:00">2013-06-17 00:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <div>
<p>IrrlichtにMsgPackRPCを仕込む
Oculusの通販ステータスが早くもProcessingに変わって届くのが楽しみな今日この頃。
レンダリングエンジンにはIrrlichtを選択したのであるが、
そのままだとシーンを構築するとか諸々の作業がC++直叩きになる。
これだとさすがに大変なのでMsgPackRPCでラップして外部のツールから
操作しようと構想しておったのだが始めてみると早速問題に突き当たった。
オブジェクトを生成してそのメソッドをコールするのにどうすればいいのか。
こういう場合だ。
IMesh *mesh=CreateMesh("miku.pmd");
mesh-&gt;SetPosition(0, 0, 5);</p>
<p>MsgPackRPC経由だと以下のような感じか。</p>
<h2>pythonとかそういうの</h2>
<p>client=msgpac.rpc.client()
mesh=client.call("CreateMesh", "miku.pmd")
client.call("Mesh_SetPosition", mesh, 0, 0, 5)</p>
<p>1つめのCreateMeshはグローバル関数かシングルトン的オブジェクトのメソッド呼び出しになるので特に問題は無い。
2つめはSetPositionのthisとしてmeshを送ってやる必要がある。
ここでmsgpack的にはIMesh<em>をシリアライズ/デシリアライズすることが必要になる。
案１ ポインタを整数値としてキャストすればいいじゃない
template <typename stream>
inline packer<stream>&amp; operator&lt;&lt; (packer<stream>&amp; o, IMesh </stream></stream></typename></em>v)
{
    // ポインタをintにキャスト
    o.pack((int)v);
    return o;
}</p>
<p>inline IMesh <em>v operator&gt;&gt; (object o, IMesh</em> v)
{
    unsigned int p;
    o.convert(&amp;p):</p>
<pre class="code literal-block"><span></span>// intをポインタにキャスト
v=(IMesh*)p;

return v;
</pre>

<p>}</p>
<p>さすがにワイルドすぎる。というかポインタが既に開放されている場合になすすべが無いので没
案２ 適当にユニークなIDを振る
template <typename stream>
inline packer<stream>&amp; operator&lt;&lt; (packer<stream>&amp; o, IMesh *v)
{
    // ポインタのuid値
    o.pack(v-&gt;uid());
    return o;
}</stream></stream></typename></p>
<p>inline IMesh <em>v operator&gt;&gt; (object o, IMesh</em> v)
{
    unsigned int uid;
    o.convert(&amp;uid):</p>
<pre class="code literal-block"><span></span><span class="o">//</span> <span class="nt">uid値からポインタを得る</span>
<span class="nt">v</span><span class="o">=</span><span class="nt">IMesh</span><span class="p">::</span><span class="nd">get_from_uid</span><span class="o">(</span><span class="nt">uid</span><span class="o">);</span>

<span class="nt">return</span> <span class="nt">v</span><span class="o">;</span>
</pre>

<p>}</p>
<p>Irrlichtだと本体側に改造が要るけどこれでいってみるか。
template<typename t>
class IDGenerator
{
    unsigned int m_uid;</typename></p>
<p>public:
    IDGenerator():m_uid(generate_uid())
    {
        m_uid_map.insert(std::make_pair(m_uid, this));
    }</p>
<pre class="code literal-block"><span></span>unsigned int uid()const 
{
    return m_uid;
}
</pre>

<p>////////////////////
// static
////////////////////
private:
    static unsigned int m_next_uid=1;
    static std::hash_map<unsigned int t> m_uid_map;
public:
    static unsigned int generate_uid(){ 
        return m_next_uid++; 
    }</unsigned></p>
<pre class="code literal-block"><span></span>statc T* get_from_uid(unsigned int uid){
    auto found=m_uid_map.find(uid);
    if(found==m_uid_map.end()){
        return 0;
    }
    return found-&gt;second;
}
</pre>

<p>};</p>
<p>// 継承階層のIReferenceCountedの下あたりにこんな感じで介入する予定
class IMesh : public virtual IReferenceCounted, public IDGenerator<imesh>
{
};</imesh></p>
<p>うまくいくかやってみるとしよう。
書いてみた
自由に書いてみたらこうなった。templateクラスのスタティックメンバ変数の書き方を学んだ。
http://d.hatena.ne.jp/higepon/20100803/1280834422
template<typename t>
class IDGenerator
{
    struct Deleter{
        unsigned int m_uid;</typename></p>
<pre class="code literal-block"><span></span>    Deleter(unsigned int uid): m_uid(uid){}
    ~Deleter(){ remove_from_map(m_uid); }
};
Deleter m_deleter;
unsigned int m_uid;
</pre>

<p>public:
    IDGenerator():m_uid(generate_uid()), m_deleter(m_uid)
    {
        s_uid_map[m_uid]=this;
    }</p>
<pre class="code literal-block"><span></span>unsigned int uid()const 
{
    return m_uid;
}

////////////////////
// static
////////////////////
</pre>

<p>private:
    static core::map<unsigned int idgenerator> s_uid_map;
public:
    static unsigned int generate_uid(){ 
        static unsigned int next_uid=1;
        return next_uid++; 
    }</unsigned></p>
<pre class="code literal-block"><span></span>static T* get_from_uid(unsigned int uid){
    return s_uid_map.find(uid);
}

static void remove_from_map(unsigned int uid){
    s_uid_map.remove(uid);
}
</pre>

<p>};
template <typename t> core::map<unsigned int idgenerator>*&gt; IDGenerator<t>::s_uid_map;</t></unsigned></typename></p>
<p>しかし、この設計だとstaticメンバがdll境界を越えて２つ存在してうまくいかない罠があった。没
案3 適当にユニークなIDを振る(非テンプレート)
irr::IReferenceCountedを改造する。
小賢しいtemplateをやめてべたにグローバル変数を隠蔽する方式を導入した。
class IReferenceCounted
{
public:</p>
<pre class="code literal-block"><span></span>//! Constructor.
IReferenceCounted()
    : DebugName(0), ReferenceCounter(1), UID(get_uid())
{
    register_uid(UID, this);
}

u32 uid(){ return UID; }

//! Destructor.
virtual ~IReferenceCounted()
{
    unregister_uid(UID);
}
</pre>

<p>// 省略</p>
<p>};</p>
<h2>include "IDGenerator.h"</h2>
<h2>include "IReferenceCounted.h"</h2>
<h2>include "irrMap.h"</h2>
<p>namespace irr {</p>
<pre class="code literal-block"><span></span><span class="nt">extern</span> <span class="s2">"C"</span> <span class="nt">IRRLICHT_API</span> <span class="nt">u32</span> <span class="nt">get_uid</span><span class="o">()</span>
<span class="p">{</span>
    <span class="err">static</span> <span class="err">u32</span> <span class="err">uid=1</span><span class="p">;</span>
    <span class="err">return</span> <span class="err">uid++</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">static</span> <span class="nt">core</span><span class="p">::</span><span class="nd">map</span><span class="o">&lt;</span><span class="nt">u32</span><span class="o">,</span> <span class="nt">IReferenceCounted</span><span class="o">*&gt;</span> <span class="nt">g_map</span><span class="o">;</span>

<span class="nt">extern</span> <span class="s2">"C"</span> <span class="nt">IRRLICHT_API</span> <span class="nt">void</span> <span class="nt">register_uid</span><span class="o">(</span><span class="nt">u32</span> <span class="nt">uid</span><span class="o">,</span> <span class="nt">IReferenceCounted</span> <span class="o">*</span><span class="nt">p</span><span class="o">)</span>
<span class="p">{</span>
    <span class="err">g_map.set(uid,</span> <span class="err">p)</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">extern</span> <span class="s2">"C"</span> <span class="nt">IRRLICHT_API</span> <span class="nt">void</span> <span class="nt">unregister_uid</span><span class="o">(</span><span class="nt">u32</span> <span class="nt">uid</span><span class="o">)</span>
<span class="p">{</span>
    <span class="err">auto</span> <span class="err">found=g_map.remove(uid)</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">extern</span> <span class="s2">"C"</span> <span class="nt">IRRLICHT_API</span> <span class="nt">IReferenceCounted</span><span class="o">*</span> <span class="nt">get_from_uid</span><span class="o">(</span><span class="nt">u32</span> <span class="nt">uid</span><span class="o">)</span>
<span class="p">{</span>
    <span class="err">auto</span> <span class="err">found=g_map.find(uid)</span><span class="p">;</span>
    <span class="err">if(!found){</span>
        <span class="err">return</span> <span class="err">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nt">return</span> <span class="nt">found-</span><span class="o">&gt;</span><span class="nt">getValue</span><span class="o">();</span>
<span class="err">}</span>
</pre>

<p>}</p>
<p>動作確認できた。
ここまでの作業でMsgPackRPCを使ったIrrlichtエクスポートについて見通しを得ることができた。
PythonやLuaから使えるようにするのと同じような作業でリモートから関数をコールできるようになるのでいい感じだ。
呼び出し側にPythonのMsgPackRPCを使えば違う言語からでも呼び出せるので一石二鳥というもの。
ということで引き続き作業を進める。
MsgPackRPCのリモート呼び出しを利用したシーンエディタを作りながら表示できるものを増やしていく。</p>
</div>
                </div>
            </article>
</div>
    
        <ul class="pager postindexpager clearfix">
<li class="previous"><a href="index-7.html" rel="prev">新しい記事</a></li>
            <li class="next"><a href="index-5.html" rel="next">過去の記事</a></li>
        </ul>
<!--End of body content--><footer id="footer">
            Contents © 2021         <a href="mailto:ousttrue@gmail.com">ousttrue</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
