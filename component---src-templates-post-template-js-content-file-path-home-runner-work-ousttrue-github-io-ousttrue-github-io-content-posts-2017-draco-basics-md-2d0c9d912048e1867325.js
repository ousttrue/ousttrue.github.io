"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[742],{9962:function(e,t,n){n.r(t),n.d(t,{default:function(){return i}});var o=n(1151),r=n(7294);function a(e){const t=Object.assign({p:"p",span:"span",ul:"ul",li:"li"},(0,o.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.p,null,"Googleのメッシュ圧縮ライブラリDracoの使い方を調査中。"),"\n",r.createElement(t.p,null,"https://github.com/google/draco"),"\n",r.createElement(t.p,null,"コマンドラインツールから ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">obj</code>'}})," と ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ply</code>'}})," 形式の読み書きができるのでそこから解読する。\nポイントクラウドの読み書き\n点群を表す ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">draco::PointCloud</code>'}})," 型があって、それを継承して面を追加した ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">draco::Mesh</code>'}})," 型がある。\nまずは、基本となる ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">PointCloud</code>'}})," の読み書き。"),"\n",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">#include &quot;draco/point_cloud/point_cloud.h&quot;\n#include &quot;draco/point_cloud/point_cloud_builder.h&quot;\n#include &quot;draco/compression/encode.h&quot;\n#include &quot;draco/compression/decode.h&quot;\n\n\nstruct Vector3\n{\n    float x;\n    float y;\n    float z;\n};\n\n/*\nstatic int AddPositionAttribute(draco::PointCloud *pc, int vertexCount)\n{\n    draco::GeometryAttribute va;\n    va.Init(draco::GeometryAttribute::POSITION, nullptr, 3, draco::DT_FLOAT32, false, \n        sizeof(float) * 3, 0);\n    return pc-&gt;AddAttribute(va, false, vertexCount);\n}\nstatic int AddTexCoordAttribute(draco::PointCloud *pc, int vertexCount)\n{\n    draco::GeometryAttribute va;\n    va.Init(draco::GeometryAttribute::TEX_COORD, nullptr, 2, draco::DT_FLOAT32, false,\n        sizeof(float) * 2, 0);\n    return pc-&gt;AddAttribute(va, false, vertexCount);\n}\nstatic int AddNormaldAttribute(draco::PointCloud *pc, int vertexCount)\n{\n    draco::GeometryAttribute va;\n    va.Init(draco::GeometryAttribute::NORMAL, nullptr, 3, draco::DT_FLOAT32, false,\n        sizeof(float) * 3, 0);\n    return pc-&gt;AddAttribute(va, false, vertexCount);\n}\n*/\n\nint main(int argc, char **argv)\n{\n    Vector3 vertices[] =\n    {\n        {-1, -1, -1},\n        { -1, 1, -1 },\n        { 1, 1, -1 },\n        { 1, -1, -1 },\n    };\n\n    // setup point cloud\n    /*\n    draco::PointCloud pc;\n    pc.set_num_points(_countof(vertices));\n\n    {\n        auto pos_att_id = AddPositionAttribute(&amp;pc, _countof(vertices));\n        auto attr = pc.attribute(pos_att_id);\n        auto size = attr-&gt;size();\n        attr-&gt;SetAttributeValue(draco::AttributeValueIndex(0), vertices);\n    }\n    */\n    draco::PointCloudBuilder builder;\n    builder.Start(_countof(vertices));\n    auto pos_att_id = builder.AddAttribute(draco::GeometryAttribute::POSITION, 3, draco::DT_FLOAT32);\n    for (int i = 0; i &lt; _countof(vertices); ++i) {\n        builder.SetAttributeValueForPoint(pos_att_id, draco::PointIndex(i), &amp;vertices[i]);\n    }\n    auto res = builder.Finalize(false);\n\n    draco::EncoderBuffer encodeBuffer;\n    {\n        // encode\n        draco::Encoder encoder;\n        auto  status = encoder.EncodePointCloudToBuffer(*res, &amp;encodeBuffer);\n    }\n\n    {\n        // decode\n        draco::DecoderBuffer decodeBuffer;\n        decodeBuffer.Init(encodeBuffer.data(), encodeBuffer.size());\n\n        draco::Decoder decoder;\n        auto statusor = decoder.DecodePointCloudFromBuffer(&amp;decodeBuffer);\n\n        auto dpc = std::move(statusor).value();\n        auto num = dpc-&gt;NumNamedAttributes(draco::GeometryAttribute::POSITION);\n        auto attr = dpc-&gt;GetNamedAttribute(draco::GeometryAttribute::POSITION);\n        std::vector&lt;Vector3&gt; positions(attr-&gt;size());\n        for (int i = 0; i &lt; positions.size(); ++i)\n        {\n            attr-&gt;ConvertValue&lt;float, 3&gt;(draco::AttributeValueIndex(i), &amp;positions[i].x);\n        }\n    }\n\n    return 0;\n}</code></pre></div>'}}),"\n",r.createElement(t.p,null,"参考になるファイルは、"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"point_cloud_builder_test.cc(build point cloud)"),"\n",r.createElement(t.li,null,"draco_encoder.cc(obj to draco)"),"\n",r.createElement(t.li,null,"draco_decoder.cc(draco to obj)"),"\n"),"\n",r.createElement(t.p,null,"PointCloud -> dracoとdraco->PointCloud->get points は簡単でAPIを素直に呼び出せばいい。\n問題は如何に PointCloud を構築するか。 draco_encoder から解読したローレベルのAPIでやってみたらうまくいかなかったのだが、draco::PointCloudBuilderを発見した。\nMeshの読み書き"),"\n",r.createElement(t.p,null,"ToDo…"))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,o.ah)(),e.components);return t?r.createElement(t,e,r.createElement(a,e)):a(e)},l=(n(8678),n(8838));const d={code:e=>{let{children:t,className:n}=e;return n?r.createElement(l.Z,{className:n},t):r.createElement("code",null,t)}};function u(e){let{data:t,children:n}=e;return r.createElement(r.Fragment,null,r.createElement("h1",null,t.mdx.frontmatter.title),r.createElement(o.Zo,{components:d},n))}function i(e){return r.createElement(u,e,r.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2017-draco-basics-md-2d0c9d912048e1867325.js.map