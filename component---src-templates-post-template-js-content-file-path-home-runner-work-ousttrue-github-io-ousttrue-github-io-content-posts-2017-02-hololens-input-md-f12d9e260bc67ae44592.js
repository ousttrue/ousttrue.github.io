"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4279],{8417:function(n,e,t){t.r(e),t.d(e,{default:function(){return l}});var o=t(1151),r=t(7294);function a(n){const e=Object.assign({p:"p",pre:"pre",code:"code"},(0,o.ah)(),n.components);return r.createElement(r.Fragment,null,r.createElement(e.p,null,"Hololens の InputManager の動きを読んでみた"),"\n",r.createElement(e.pre,null,r.createElement(e.code,null,"HoloToolkit.Unity.InputModule.InputManager\nAssets/HoloToolkit/Input/Prefabs/InputManagerプレハブから見る。\nInputManager\n  + (GazeManager)\n  + (GazeStablilizer)\n  + (InputManager)\n  + (StabilizationPlaneModifier)\n\n  GesturesInput# BaseInputSource(UnityEngine.VR.WSA.Input.GestureRecognizerを通じてジェスチャーを取得する)\n  RawInteractionSourcesInput# BaseInputSource(UnityEngine.VR.WSA.Input.InteractionSourceを通じて手の検出・位置・ロストなどのイベントを検知する)\n  EditorHandsInput# BaseInputSource(Editor向けに手イベントを偽装する)\n\nこんな感じに親子関係があって結構たくさんスクリプトがアタッチされている。\n主要な部分だけに減らすと以下の3つのスクリプトになる。\nInputManager\n  + (GazeManager)\n  + (InputManager)\n  GesturesInput# BaseInputSource(UnityEngine.VR.WSA.Input.GestureRecognizerを通じてジェスチャーを取得する)\n\nこの３つのスクリプトは下記のように連携する。\nGazeManager -> raycast -> hitObject\n                                  |\n                                  v\nGesturesInput -> event -> InputManager -> hitObjectのeventハンドラを実行する\n\nUnityのEventSystemとの連携\n通常のUnityのEventは、EventSystemがアタッチされたInputModule(StandardInputModule)のProcess関数をコールすることで始まる。\nHoloToolkitのInputManagerは、GestureRecognizer等からのイベントを即座にUnityのEventに変換して発行していた。\nShouldSendUnityUiEventsでInputManager.csを検索すると以下がヒットする。\nHoloToolkit-Unity\\Assets\\HoloToolkit\\Input\\Scripts\\InputManager.cs(308)\nHoloToolkit-Unity\\Assets\\HoloToolkit\\Input\\Scripts\\InputManager.cs(317)\nHoloToolkit-Unity\\Assets\\HoloToolkit\\Input\\Scripts\\InputManager.cs(340)\nHoloToolkit-Unity\\Assets\\HoloToolkit\\Input\\Scripts\\InputManager.cs(363)\nHoloToolkit-Unity\\Assets\\HoloToolkit\\Input\\Scripts\\InputManager.cs(386)\n\nコードを見てみると\n// hololensのevent\nExecuteEvents.ExecuteHierarchy(newObject, null, OnFocusEnterEventHandler);\nif (ShouldSendUnityUiEvents)\n{\n    // unity仕様に変換して実行\n    ExecuteEvents.ExecuteHierarchy(newObject\n        , GazeManager.Instance.UnityUIPointerEvent, ExecuteEvents.pointerEnterHandler);\n}\n\nという風になっていて、以下の5種類のイベント転送を実装していた。\n\nIPointerClickHandler\nIPointerDownHandler\nIPointerEnterHandler\nIPointerExitHandler\nIPointerUpHandler\n\nこれだとButton等のクリックイベントを処理するタイプのものは動く。\nDragとかScrollイベントは別途イベント転送してやる必要がありそう。\nなるほど。\n")))}var u=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,o.ah)(),n.components);return e?r.createElement(e,n,r.createElement(a,n)):a(n)};t(8678);function i(n){let{data:e,children:t}=n;return r.createElement(r.Fragment,null,r.createElement("h1",null,e.mdx.frontmatter.title),r.createElement(o.Zo,null,t))}function l(n){return r.createElement(i,n,r.createElement(u,n))}},8678:function(n,e,t){t(7294)},1151:function(n,e,t){t.d(e,{Zo:function(){return i},ah:function(){return a}});var o=t(7294);const r=o.createContext({});function a(n){const e=o.useContext(r);return o.useMemo((()=>"function"==typeof n?n(e):{...e,...n}),[e,n])}const u={};function i({components:n,children:e,disableParentContext:t}){let i;return i=t?"function"==typeof n?n({}):n||u:a(n),o.createElement(r.Provider,{value:i},e)}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2017-02-hololens-input-md-f12d9e260bc67ae44592.js.map