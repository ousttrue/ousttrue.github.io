{"version":3,"file":"component---content-posts-2015-12-24-heroku-sokcetio-md-378e0331b2256757e71a.js","mappings":"yHAGA,SAASA,EAAkBC,GACzB,MAAMC,EAAcC,OAAOC,OAAO,CAChCC,EAAG,IACHC,IAAK,MACLC,KAAM,SACLC,EAAAA,EAAAA,MAAsBP,EAAMQ,YAC/B,OAAOC,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,oIAAqI,KAAMK,EAAAA,cAAoBR,EAAYI,IAAK,KAAMI,EAAAA,cAAoBR,EAAYK,KAAM,KAAM,8yKAC9T,CAKA,UAJA,SAAoBN,QAAK,IAALA,IAAAA,EAAQ,CAAC,GAC3B,MAAOU,QAASC,GAAaT,OAAOC,OAAO,CAAC,GAAGI,EAAAA,EAAAA,MAAsBP,EAAMQ,YAC3E,OAAOG,EAAYF,EAAAA,cAAoBE,EAAWX,EAAOS,EAAAA,cAAoBV,EAAmBC,IAAUD,EAAkBC,EAC9H,C,sECmBO,MAAMY,EAAa,gBAAoB,CAAC,GAiCxC,SAASC,EAAiBL,GAC/B,MAAMM,EAAoB,aAAiBF,GAG3C,OAAO,WAAc,IAEO,mBAAfJ,EACFA,EAAWM,GAGb,IAAIA,KAAsBN,IAChC,CAACM,EAAmBN,GACzB,C","sources":["webpack:///./content/posts/2015/12/24/heroku_sokcetio.md","webpack:///./node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"Socket.IO サーバーとして Heroku を使ってみよう。\\n実験中\\nhttps://shielded-caverns-4913.herokuapp.com/\\nHeroku 練習\\n以前作ったユーザーが生きていたので改めてチュートリアルを実践。\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, null, \"Getting Started with Node.js on Heroku\\n\\ngulpでexpressなサーバを作る\\n普通にnpmなプロジェクトを作る。\\n> mkdir bvh_sio\\n> cd bvh_sio\\n> npm init\\n> mkdir src\\n> mkidr src/server\\n> mkdir src/client\\n> cd src\\n> tsd init\\n> tsd query node -rosa install\\n> tsd query express -rosa install\\n> tsd query serve-static -rosa install\\n> tsd query socket.io -rosa install\\n\\nHerokuにデプロイする場合はでdevDependenciesじゃなくてdependenciesに書くらしいのでそのようにした。\\npackage.json\\n{\\n  \\\"name\\\": \\\"bvh_sio\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"description\\\": \\\"\\\",\\n  \\\"main\\\": \\\"build/app.js\\\",\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"node build/app.js\\\"\\n  },\\n  \\\"author\\\": \\\"ousttrue\\\",\\n  \\\"license\\\": \\\"ISC\\\",\\n  \\\"dependencies\\\": {\\n    \\\"express\\\": \\\"^4.13.3\\\",\\n    \\\"gulp\\\": \\\"^3.9.0\\\",\\n    \\\"gulp-if\\\": \\\"^2.0.0\\\",\\n    \\\"gulp-load-plugins\\\": \\\"^1.1.0\\\",\\n    \\\"gulp-run-sequence\\\": \\\"^0.3.2\\\",\\n    \\\"gulp-typescript\\\": \\\"^2.10.0\\\",\\n    \\\"serve-static\\\": \\\"^1.10.0\\\",\\n    \\\"socket.io\\\": \\\"^1.3.7\\\",\\n    \\\"tsd\\\": \\\"^0.6.5\\\"\\n  }\\n}\\n\\nserve-staticで静的なファイルをホストするexpress。後でsocket.ioを追加する。\\nsrc/server/app.ts\\n/// <reference path=\\\"../typings/tsd.d.ts\\\" />\\n\\nimport http = require('http');\\nimport express = require('express');\\nconst port = process.env.PORT || 3000; // <- Herokuで必要!\\nconst app = express();\\nconst server = http.createServer(app);\\nconst servestatic = require('serve-static');\\nconst serve_dir = __dirname + '/public';\\nconsole.log('serve %s', serve_dir);\\napp\\n    .use(servestatic(serve_dir))\\n;\\n\\n// start\\nserver.listen(port);\\nconsole.log('start port: %d...', port);\\n\\nこいつをtypescriptでコンパイルしてbuildディレクトリに展開したい。\\ngulpfile.js\\n'use strict';\\n\\nconst path = require('path');\\nconst execSync = require('child_process').execSync;\\nconst gulp = require('gulp');\\nconst $ = require('gulp-load-plugins')();\\n\\nconst config = {\\n    server_src: './src/server/**/*.*',\\n    server_dst: './build',\\n\\n    client_src: './src/client/**/*.*',\\n    client_dst: './build/public'\\n};\\nconst tsconfig = require('./tsconfig.json');\\n\\nfunction pushd(dst, callback) {\\n    const cwd = process.cwd();\\n    process.chdir(dst);\\n    callback();\\n    process.chdir(cwd);\\n}\\n\\ngulp.task('tsd:install', () => {\\n    pushd('./src', ()=>execSync('tsd install'));\\n});\\n\\ngulp.task('server', () => {\\n    gulp.src(config.server_src)\\n        .pipe($.if((file) => path.extname(file.path).toLowerCase() === '.ts'\\n            , $.typescript(tsconfig.compilerOptions)))\\n        .pipe(gulp.dest(config.server_dst))\\n    ;\\n});\\n\\ngulp.task('client', () => {\\n    gulp.src(config.client_src)\\n        .pipe($.if((file) => path.extname(file.path).toLowerCase() === '.ts'\\n            , $.typescript(tsconfig.compilerOptions)))\\n        .pipe(gulp.dest(config.client_dst))\\n    ;\\n});\\n\\ngulp.task('build', ['server', 'client']);\\n\\ngulp.task('install', (cb) => {\\n    $.runSequence('tsd:install', 'build', cb);\\n});\\n\\ngulp.task('default', ['build']);\\n\\ntsconfig.json\\n{\\n    \\\"compilerOptions\\\": {\\n        \\\"module\\\": \\\"commonjs\\\",\\n        \\\"target\\\": \\\"es5\\\",\\n        \\\"noImplicitAny\\\": true,\\n        \\\"outDir\\\": \\\".\\\",\\n        \\\"rootDir\\\": \\\".\\\",\\n        \\\"sourceMap\\\": false,\\n        \\\"removeComments\\\": true\\n    },\\n    \\\"exclude\\\": [\\n        \\\"node_modules\\\"\\n    ]\\n}\\n\\njsconfig.json\\n{\\n    \\\"compilerOptions\\\": {\\n        \\\"module\\\": \\\"commonjs\\\",\\n        \\\"target\\\": \\\"es6\\\"\\n    }\\n}\\n\\nsrc/client/index.html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <title>Document</title>\\n</head>\\n<body>\\n    <h1>Hello</h1>\\n</body>\\n</html>\\n\\nプロジェクトをHeroku化してデプロイ\\nHerokuでビルドしたりbuild結果だけをpushするなどの方式があるようだが、Heroku上でgulpする方式にしてみた(git苦手w)。\\ngit push時に実行するコマンドをpackage.jsonに記述できる。\\npackage.json\\n  \\\"scripts\\\": {\\n    \\\"postinstall\\\": \\\"gulp install\\\", // <- 追加する\\n    \\\"start\\\": \\\"node build/app.js\\\"\\n  },\\n\\nサーバー実行コマンド。\\nProcfile\\nweb: node build/app.js\\n\\nherokuにデプロイ。\\n# 一回だけ実行する\\n> heroku create\\n\\n# herokuを更新\\n> git push heroku master\\n# エラーが出たら直す。npm installなど\\n\\n# herokuサイトをブラウザで開く\\n> heroku open\\n# エラーが出たら直す。npm installなど\\n\\nheroku側でgulp-typescriptするように作ってみたけどうまくいった。\\nsocket.ioを追加\\nwebsocketじゃなくてajax pollingらしいけどSocket.IOがよきに計らってくれる。\\nsrc/server/app.tsに追加\\n// socket.io\\nimport socketio = require('socket.io');\\nconst io = socketio(server);\\nio.on('connection', (socket) => {\\n    var clientAddress = socket.client.conn.remoteAddress;\\n    console.log('connected: %s from %s', socket.id, clientAddress);\\n\\n    function recTimer(interval: number, callback: Function)\\n    {\\n        setTimeout(()=>recTimer(interval, callback), interval);\\n        callback();\\n    }\\n    recTimer(3000, ()=>socket.emit('time', Date.now()));\\n});\\n\\nsrc/client/index.html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <title>Document</title>\\n    <script src=\\\"/socket.io/socket.io.js\\\"></script>\\n    <script src=\\\"index.js\\\"></script>\\n</head>\\n<body>\\n    <h1>Hello</h1>\\n\\n    <div id='content'></div>\\n</body>\\n</html>\\n\\nsrc/client/index.ts\\n/// <reference path=\\\"../typings/tsd.d.ts\\\" />\\n\\ndeclare module io {\\n    export function connect(): SocketIO.Socket;\\n}\\n\\nwindow.onload = () => {\\n    const socket = io.connect();\\n\\n    const content=document.getElementById('content');\\n\\n    socket.on('connect', ()=>{\\n        content.innerHTML='connected!';\\n    });\\n\\n    socket.on('time', (message: any)=>{\\n        content.innerHTML+='<br>'+message;\\n    });\\n}\\n\\nbvh\\n準備が整ったので、node.js側でパースしたbvhを適当にjson化してsocket.ioにemitするサーバーを作る。\\n\")));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('mdx/types.js').MDXComponents} Components\n *\n * @typedef Props\n *   Configuration.\n * @property {Components | MergeComponents | null | undefined} [components]\n *   Mapping of names for JSX components to React components.\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context.\n * @property {ReactNode | null | undefined} [children]\n *   Children.\n *\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Components} currentComponents\n *   Current components from the context.\n * @returns {Components}\n *   Merged components.\n */\n\nimport React from 'react'\n\n/**\n * @type {import('react').Context<Components>}\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components and\n *   `MDXProvider` to set context based components instead.\n */\nexport const MDXContext = React.createContext({})\n\n/**\n * @param {import('react').ComponentType<any>} Component\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components instead.\n */\nexport function withMDXComponents(Component) {\n  return boundMDXComponent\n\n  /**\n   * @param {Record<string, unknown> & {components?: Components | null | undefined}} props\n   * @returns {JSX.Element}\n   */\n  function boundMDXComponent(props) {\n    const allComponents = useMDXComponents(props.components)\n    return React.createElement(Component, {...props, allComponents})\n  }\n}\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Components | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that takes the current\n *   components and filters/merges/changes them.\n * @returns {Components}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(() => {\n    // Custom merge via a function prop\n    if (typeof components === 'function') {\n      return components(contextComponents)\n    }\n\n    return {...contextComponents, ...components}\n  }, [contextComponents, components])\n}\n\n/** @type {Components} */\nconst emptyObject = {}\n\n/**\n * Provider for MDX context\n *\n * @param {Props} props\n * @returns {JSX.Element}\n */\nexport function MDXProvider({components, children, disableParentContext}) {\n  /** @type {Components} */\n  let allComponents\n\n  if (disableParentContext) {\n    allComponents =\n      typeof components === 'function'\n        ? components({})\n        : components || emptyObject\n  } else {\n    allComponents = useMDXComponents(components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","p","pre","code","_provideComponents","components","React","wrapper","MDXLayout","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}