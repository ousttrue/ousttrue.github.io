"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[742],{9962:function(e,t,n){n.r(t),n.d(t,{default:function(){return d}});var o=n(1151),r=n(7294);function c(e){const t=Object.assign({p:"p",code:"code",pre:"pre",ul:"ul",li:"li"},(0,o.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.p,null,"Googleのメッシュ圧縮ライブラリDracoの使い方を調査中。"),"\n",r.createElement(t.p,null,"https://github.com/google/draco"),"\n",r.createElement(t.p,null,"コマンドラインツールから ",r.createElement(t.code,null,"obj")," と ",r.createElement(t.code,null,"ply")," 形式の読み書きができるのでそこから解読する。\nポイントクラウドの読み書き\n点群を表す ",r.createElement(t.code,null,"draco::PointCloud")," 型があって、それを継承して面を追加した ",r.createElement(t.code,null,"draco::Mesh")," 型がある。\nまずは、基本となる ",r.createElement(t.code,null,"PointCloud")," の読み書き。"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-c++"},'#include "draco/point_cloud/point_cloud.h"\n#include "draco/point_cloud/point_cloud_builder.h"\n#include "draco/compression/encode.h"\n#include "draco/compression/decode.h"\n\n\nstruct Vector3\n{\n    float x;\n    float y;\n    float z;\n};\n\n/*\nstatic int AddPositionAttribute(draco::PointCloud *pc, int vertexCount)\n{\n    draco::GeometryAttribute va;\n    va.Init(draco::GeometryAttribute::POSITION, nullptr, 3, draco::DT_FLOAT32, false, \n        sizeof(float) * 3, 0);\n    return pc->AddAttribute(va, false, vertexCount);\n}\nstatic int AddTexCoordAttribute(draco::PointCloud *pc, int vertexCount)\n{\n    draco::GeometryAttribute va;\n    va.Init(draco::GeometryAttribute::TEX_COORD, nullptr, 2, draco::DT_FLOAT32, false,\n        sizeof(float) * 2, 0);\n    return pc->AddAttribute(va, false, vertexCount);\n}\nstatic int AddNormaldAttribute(draco::PointCloud *pc, int vertexCount)\n{\n    draco::GeometryAttribute va;\n    va.Init(draco::GeometryAttribute::NORMAL, nullptr, 3, draco::DT_FLOAT32, false,\n        sizeof(float) * 3, 0);\n    return pc->AddAttribute(va, false, vertexCount);\n}\n*/\n\nint main(int argc, char **argv)\n{\n    Vector3 vertices[] =\n    {\n        {-1, -1, -1},\n        { -1, 1, -1 },\n        { 1, 1, -1 },\n        { 1, -1, -1 },\n    };\n\n    // setup point cloud\n    /*\n    draco::PointCloud pc;\n    pc.set_num_points(_countof(vertices));\n\n    {\n        auto pos_att_id = AddPositionAttribute(&pc, _countof(vertices));\n        auto attr = pc.attribute(pos_att_id);\n        auto size = attr->size();\n        attr->SetAttributeValue(draco::AttributeValueIndex(0), vertices);\n    }\n    */\n    draco::PointCloudBuilder builder;\n    builder.Start(_countof(vertices));\n    auto pos_att_id = builder.AddAttribute(draco::GeometryAttribute::POSITION, 3, draco::DT_FLOAT32);\n    for (int i = 0; i < _countof(vertices); ++i) {\n        builder.SetAttributeValueForPoint(pos_att_id, draco::PointIndex(i), &vertices[i]);\n    }\n    auto res = builder.Finalize(false);\n\n    draco::EncoderBuffer encodeBuffer;\n    {\n        // encode\n        draco::Encoder encoder;\n        auto  status = encoder.EncodePointCloudToBuffer(*res, &encodeBuffer);\n    }\n\n    {\n        // decode\n        draco::DecoderBuffer decodeBuffer;\n        decodeBuffer.Init(encodeBuffer.data(), encodeBuffer.size());\n\n        draco::Decoder decoder;\n        auto statusor = decoder.DecodePointCloudFromBuffer(&decodeBuffer);\n\n        auto dpc = std::move(statusor).value();\n        auto num = dpc->NumNamedAttributes(draco::GeometryAttribute::POSITION);\n        auto attr = dpc->GetNamedAttribute(draco::GeometryAttribute::POSITION);\n        std::vector<Vector3> positions(attr->size());\n        for (int i = 0; i < positions.size(); ++i)\n        {\n            attr->ConvertValue<float, 3>(draco::AttributeValueIndex(i), &positions[i].x);\n        }\n    }\n\n    return 0;\n}\n')),"\n",r.createElement(t.p,null,"参考になるファイルは、"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"point_cloud_builder_test.cc(build point cloud)"),"\n",r.createElement(t.li,null,"draco_encoder.cc(obj to draco)"),"\n",r.createElement(t.li,null,"draco_decoder.cc(draco to obj)"),"\n"),"\n",r.createElement(t.p,null,"PointCloud -> dracoとdraco->PointCloud->get points は簡単でAPIを素直に呼び出せばいい。\n問題は如何に PointCloud を構築するか。 draco_encoder から解読したローレベルのAPIでやってみたらうまくいかなかったのだが、draco::PointCloudBuilderを発見した。\nMeshの読み書き"),"\n",r.createElement(t.p,null,"ToDo…"))}var u=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,o.ah)(),e.components);return t?r.createElement(t,e,r.createElement(c,e)):c(e)};n(8678);function a(e){let{data:t,children:n}=e;return r.createElement(r.Fragment,null,r.createElement("h1",null,t.mdx.frontmatter.title),r.createElement(o.Zo,null,n))}function d(e){return r.createElement(a,e,r.createElement(u,e))}},8678:function(e,t,n){n(7294)},1151:function(e,t,n){n.d(t,{Zo:function(){return a},ah:function(){return c}});var o=n(7294);const r=o.createContext({});function c(e){const t=o.useContext(r);return o.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const u={};function a({components:e,children:t,disableParentContext:n}){let a;return a=n?"function"==typeof e?e({}):e||u:c(e),o.createElement(r.Provider,{value:a},t)}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2017-draco-basics-md-a18b4f66b49e8bcea06a.js.map