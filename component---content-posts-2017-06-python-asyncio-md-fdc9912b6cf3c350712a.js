"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9178],{5717:function(n,e,o){o.r(e);var t=o(1151),l=o(7294);function a(n){const e=Object.assign({p:"p",pre:"pre",code:"code"},(0,t.ah)(),n.components);return l.createElement(l.Fragment,null,l.createElement(e.p,null,"Python の Version3.4 から始まった asyncio 周りについてのメモ。\n環境は、Windows10 上の python3.6(64bit)。"),"\n",l.createElement(e.p,null,"Version\nPython3.4"),"\n",l.createElement(e.p,null,"asyncio\nyield from"),"\n",l.createElement(e.p,null,"Python3.5"),"\n",l.createElement(e.p,null,"async def\nawait"),"\n",l.createElement(e.p,null,"EventLoop"),"\n",l.createElement(e.p,null,"https://docs.python.org/3/library/asyncio-eventloop.html"),"\n",l.createElement(e.pre,null,l.createElement(e.code,{className:"language-python"},"import asyncio\nloop=asyncio.get_event_loop()\nprint(loop)\n# <_WindowsSelectorEventLoop running=False closed=False debug=False>\n\nloop.run_forever()\nprint('done')\n")),"\n",l.createElement(e.p,null,"ただし永遠(forever)走り続けるのでプロセスを kill しないと止まらず。\nWindows 向けの loop"),"\n",l.createElement(e.p,null,"https://docs.python.org/3/library/asyncio-eventloops.html#asyncio.ProactorEventLoop"),"\n",l.createElement(e.pre,null,l.createElement(e.code,{className:"language-python"},"import asyncio\nimport sys\n\nif sys.platform == 'win32':\n    loop = asyncio.ProactorEventLoop()\n    # <ProactorEventLoop running=False closed=False debug=False>\n    asyncio.set_event_loop(loop)\nelse:\n    loop = asyncio.get_event_loop()\n")),"\n",l.createElement(e.p,null,"以降、loop を得るコードを省略。\nEventLoop に関数を投入する"),"\n",l.createElement(e.pre,null,l.createElement(e.code,{className:"language-python"},"def func(loop):\n    loop.stop() # 停止\n\nloop.call_soon(func, loop)\nloop.run_forever()\nprint('done')\n")),"\n",l.createElement(e.p,null,"asyncio.get_event_loop で loop を取得。loop.call_soon で loop に関数を投入できる。\n投入された関数は、loop.run_forever で消化される。\nついでに、loop.stop で run_forever から抜けることができる。\nEventLoop に generator を投入する"),"\n",l.createElement(e.pre,null,l.createElement(e.code,{className:"language-python"},"def gen(loop, name, count):\n    print(name, loop.time())\n    for i in range(count):\n        print(name, i, loop.time())\n        yield\n    print(name, 'done')\n    loop.stop()\n\nasyncio.ensure_future(gen(loop, 'a', 3))\nasyncio.ensure_future(gen(loop, 'b', 3))\nloop.run_forever()\n\na 534341.609\na 0 534341.609\nb 534341.609\nb 0 534341.609\na 1 534341.609\nb 1 534341.609\na 2 534341.609\nb 2 534341.609\na done\nb done\n")),"\n",l.createElement(e.p,null,"loop.stop で止まった。\nすべての task が終わるのを待つ"),"\n",l.createElement(e.pre,null,l.createElement(e.code,null,"def gen(loop, name, count):\n    print(name, loop.time())\n    for i in range(count):\n        print(name, i, loop.time())\n        yield\n    print(name, 'done')\n\ntaskA=asyncio.ensure_future(gen(loop, 'a', 3), loop=loop)\ntaskB=asyncio.ensure_future(gen(loop, 'b', 5), loop=loop)\nfuture=asyncio.gather(taskA, taskB)\nfuture.add_done_callback(lambda future: loop.stop())\ntask=asyncio.ensure_future(future, loop=loop)\n\nloop.run_forever()\n\na 571911.359\na 0 571911.359\nb 571911.359\nb 0 571911.359\na 1 571911.359\nb 1 571911.359\na 2 571911.359\nb 2 571911.359\na done\nb 3 571911.359\nb 4 571911.359\nb done\n")),"\n",l.createElement(e.p,null,"loop.run_until_complete で future が終わるのを待つ"),"\n",l.createElement(e.pre,null,l.createElement(e.code,{className:"language-python"},"def gen(loop, name, count):\n    print(name, loop.time())\n    for i in range(count):\n        print(name, i, loop.time())\n        yield\n    print(name, 'done')\nfutureA=asyncio.ensure_future(gen(loop, 'a', 3), loop=loop)\nfutureB=asyncio.ensure_future(gen(loop, 'b', 5), loop=loop)\nfuture=asyncio.gather(futureA, futureB)\n\nloop.run_until_complete(future)\n")),"\n",l.createElement(e.p,null,"future の終了を待って loop.stop したいなら run_until_complete するのが明瞭。\nPEP492 – Coroutines with async and await syntax(python3.5 09-Apr-2015)"),"\n",l.createElement(e.p,null,"generator を流用した coroutine は紛らわしいので、coroutine に独自のシンタックスを導入するで。native coroutine と呼称する。C で実装しているわけではない。\n関数内で await を使わなくても coroutine として有効"),"\n",l.createElement(e.pre,null,l.createElement(e.code,{className:"language-python"},"async def read_data(db):\n    pass\n\nEventLoopにnative coroutineを投入する\nasync def gen(loop, name, count):\n    print(name, loop.time())\n    for i in range(count):\n        print(name, i, loop.time())\n        #yield\n        await asyncio.sleep(0)\n    print(name, 'done')\n\ntaskA=asyncio.ensure_future(gen(loop, 'a', 3), loop=loop)\ntaskB=asyncio.ensure_future(gen(loop, 'b', 5), loop=loop)\nfuture=asyncio.gather(taskA, taskB)\n\nloop.run_until_complete(future)\n")),"\n",l.createElement(e.p,null,"yield を await asyncio.sleep(0)で置き換えた。\nyield のままだと TypeError になる。"),"\n",l.createElement(e.pre,null,l.createElement(e.code,null,"Traceback (most recent call last):\n  File \".\\exp.py\", line 18, in <module>\n    taskA=asyncio.ensure_future(gen(loop, 'a', 3), loop=loop)\n  File \"D:\\Python36\\lib\\asyncio\\tasks.py\", line 519, in ensure_future\n    raise TypeError('A Future, a coroutine or an awaitable is required')\nTypeError: A Future, a coroutine or an awaitable is required\n\nIt is a TypeError if __await__ returns anything but an iterator.\n")),"\n",l.createElement(e.p,null,"実験。"),"\n",l.createElement(e.pre,null,l.createElement(e.code,{className:"language-python"},"def it():\n    yield\n\nasync def co_y():\n    yield\n\nasync def co():\n    pass\n\n<class 'generator'>\n<class 'async_generator'>\n.\\exp.py:22: RuntimeWarning: coroutine 'co' was never awaited\n  print(type(co()))\n<class 'coroutine'>\n")),"\n",l.createElement(e.p,null,"async_generator…。async def 内で yield すると違うものになるのね。syntax error にはできんな。\n自前のメインループに loop を組み込むとすれば\nloop.once のような関数があると毎フレーム小出しにタスクを消化できるのだが。\nググってみた。"),"\n",l.createElement(e.p,null,"https://stackoverflow.com/questions/29868372/python-asyncio-run-event-loop-once"),"\n",l.createElement(e.p,null,"loop.stop(); loop.run_forever()"),"\n",l.createElement(e.p,null,"なるほど。"),"\n",l.createElement(e.pre,null,l.createElement(e.code,{className:"language-python"},"async def gen(loop, name, count):\n    print(name, loop.time())\n    for i in range(count):\n        print(name, i, loop.time())\n        await asyncio.sleep(0)\n    print(name, 'done')\n\ntaskA=asyncio.ensure_future(gen(loop, 'a', 3), loop=loop)\ntaskB=asyncio.ensure_future(gen(loop, 'b', 5), loop=loop)\nfuture=asyncio.gather(taskA, taskB)\n\ncount=1\nwhile not future.done():\n    print(count)\n    count+=1\n    # loop one step\n    loop.stop()\n    loop.run_forever()\n\nprint('done')\n\n1\na 579281.828\na 0 579281.828\nb 579281.828\nb 0 579281.828\n2\na 1 579281.828\nb 1 579281.828\n3\na 2 579281.828\nb 2 579281.828\n4\na done\nb 3 579281.828\n5\nb 4 579281.828\n6\nb done\n7\ndone\n")),"\n",l.createElement(e.p,null,"いいかんじになった。これなら付き合っていけそうだ。"))}e.default=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?l.createElement(e,n,l.createElement(a,n)):a(n)}},1151:function(n,e,o){o.d(e,{ah:function(){return a}});var t=o(7294);const l=t.createContext({});function a(n){const e=t.useContext(l);return t.useMemo((()=>"function"==typeof n?n(e):{...e,...n}),[e,n])}}}]);
//# sourceMappingURL=component---content-posts-2017-06-python-asyncio-md-fdc9912b6cf3c350712a.js.map