"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4984],{9876:function(n,a,s){s.r(a),s.d(a,{default:function(){return r}});var t=s(1151),e=s(7294);function p(n){const a=Object.assign({p:"p",span:"span"},(0,t.ah)(),n.components);return e.createElement(e.Fragment,null,e.createElement(a.p,null,"SharpDX で Hololens が頓挫したので、C++でまいりましょう。"),"\n",e.createElement(a.p,null,"VisualStudio2015update3 しか Univsersal cpp HolographicApp template が含まれないので github にコピーしておいた。"),"\n",e.createElement(a.p,null,"https://github.com/ousttrue/HolographicApp"),"\n",e.createElement(a.p,null,"エミュレーターで描画が乱れる件"),"\n",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">>>(tools)から</code></pre></div>'}}),"\n",e.createElement(a.p,null,"check を外したらなおった。\n実機\n問題ない。\nHololens 特有の部分\n通常の DirectX と HolographicApp の違いを調べていたのだけれど、\n両目レンダリングを効率よくするために、複数のレンダーターゲットに対して\nまとめてパイプラインを実行する関連のようだ。"),"\n",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="cpp"><pre class="language-cpp"><code class="language-cpp">VPAndRTArrayIndexFromAnyShaderFeedingRasterizer\nVPAndRTArrayIndexFromAnyShaderFeedingRasterizerないとき<span class="token punctuation">(</span>エミュレーター<span class="token punctuation">)</span>\n<span class="token comment">// A constant buffer that stores the model transform.</span>\ncbuffer ModelConstantBuffer <span class="token operator">:</span> <span class="token keyword">register</span><span class="token punctuation">(</span>b0<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    float4x4 model<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// A constant buffer that stores each set of view and projection matrices in column-major format.</span>\ncbuffer ViewProjectionConstantBuffer <span class="token operator">:</span> <span class="token keyword">register</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    float4x4 viewProjection<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Per-vertex data used as input to the vertex shader.</span>\n<span class="token keyword">struct</span> <span class="token class-name">VertexShaderInput</span>\n<span class="token punctuation">{</span>\n    min16float3 pos     <span class="token operator">:</span> POSITION<span class="token punctuation">;</span>\n    min16float3 color   <span class="token operator">:</span> COLOR0<span class="token punctuation">;</span>\n    uint        instId  <span class="token operator">:</span> SV_InstanceID<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Per-vertex data passed to the geometry shader.</span>\n<span class="token comment">// Note that the render target array index will be set by the geometry shader</span>\n<span class="token comment">// using the value of viewId.</span>\n<span class="token keyword">struct</span> <span class="token class-name">VertexShaderOutput</span>\n<span class="token punctuation">{</span>\n    min16float4 pos     <span class="token operator">:</span> SV_POSITION<span class="token punctuation">;</span>\n    min16float3 color   <span class="token operator">:</span> COLOR0<span class="token punctuation">;</span>\n    uint        viewId  <span class="token operator">:</span> TEXCOORD0<span class="token punctuation">;</span>  <span class="token comment">// SV_InstanceID % 2</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Simple shader to do vertex processing on the GPU.</span>\nVertexShaderOutput <span class="token function">main</span><span class="token punctuation">(</span>VertexShaderInput input<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    VertexShaderOutput output<span class="token punctuation">;</span>\n    float4 pos <span class="token operator">=</span> <span class="token function">float4</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>pos<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Note which view this vertex has been sent to. Used for matrix lookup.</span>\n    <span class="token comment">// Taking the modulo of the instance ID allows geometry instancing to be used</span>\n    <span class="token comment">// along with stereo instanced drawing; in that case, two copies of each</span>\n    <span class="token comment">// instance would be drawn, one for left and one for right.</span>\n    <span class="token keyword">int</span> idx <span class="token operator">=</span> input<span class="token punctuation">.</span>instId <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Transform the vertex position into world space.</span>\n    pos <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Correct for perspective and project the vertex position onto the screen.</span>\n    pos <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> viewProjection<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    output<span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token punctuation">(</span>min16float4<span class="token punctuation">)</span>pos<span class="token punctuation">;</span>\n\n    <span class="token comment">// Pass the color through without modification.</span>\n    output<span class="token punctuation">.</span>color <span class="token operator">=</span> input<span class="token punctuation">.</span>color<span class="token punctuation">;</span>\n\n    <span class="token comment">// Set the instance ID. The pass-through geometry shader will set the</span>\n    <span class="token comment">// render target array index to whatever value is set here.</span>\n    output<span class="token punctuation">.</span>viewId <span class="token operator">=</span> idx<span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> output<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n\n<span class="token comment">// Per-vertex data from the vertex shader.</span>\n<span class="token keyword">struct</span> <span class="token class-name">GeometryShaderInput</span>\n<span class="token punctuation">{</span>\n    min16float4 pos     <span class="token operator">:</span> SV_POSITION<span class="token punctuation">;</span>\n    min16float3 color   <span class="token operator">:</span> COLOR0<span class="token punctuation">;</span>\n    uint        instId  <span class="token operator">:</span> TEXCOORD0<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Per-vertex data passed to the rasterizer.</span>\n<span class="token keyword">struct</span> <span class="token class-name">GeometryShaderOutput</span>\n<span class="token punctuation">{</span>\n    min16float4 pos     <span class="token operator">:</span> SV_POSITION<span class="token punctuation">;</span>\n    min16float3 color   <span class="token operator">:</span> COLOR0<span class="token punctuation">;</span>\n    uint        rtvId   <span class="token operator">:</span> SV_RenderTargetArrayIndex<span class="token punctuation">;</span> <span class="token comment">// &lt;- RTVテクスチャアレイのindex</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// This geometry shader is a pass-through that leaves the geometry unmodified</span>\n<span class="token comment">// and sets the render target array index.</span>\n<span class="token punctuation">[</span><span class="token function">maxvertexcount</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>\n<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>triangle GeometryShaderInput input<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inout TriangleStream<span class="token operator">&lt;</span>GeometryShaderOutput<span class="token operator">></span> outStream<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    GeometryShaderOutput output<span class="token punctuation">;</span>\n    <span class="token punctuation">[</span><span class="token function">unroll</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        output<span class="token punctuation">.</span>pos   <span class="token operator">=</span> input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pos<span class="token punctuation">;</span>\n        output<span class="token punctuation">.</span>color <span class="token operator">=</span> input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>color<span class="token punctuation">;</span>\n        output<span class="token punctuation">.</span>rtvId <span class="token operator">=</span> input<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>instId<span class="token punctuation">;</span>\n        outStream<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nVPAndRTArrayIndexFromAnyShaderFeedingRasterizerあるとき\n<span class="token comment">// A constant buffer that stores the model transform.</span>\ncbuffer ModelConstantBuffer <span class="token operator">:</span> <span class="token keyword">register</span><span class="token punctuation">(</span>b0<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    float4x4 model<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// A constant buffer that stores each set of view and projection matrices in column-major format.</span>\ncbuffer ViewProjectionConstantBuffer <span class="token operator">:</span> <span class="token keyword">register</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    float4x4 viewProjection<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Per-vertex data used as input to the vertex shader.</span>\n<span class="token keyword">struct</span> <span class="token class-name">VertexShaderInput</span>\n<span class="token punctuation">{</span>\n    min16float3 pos     <span class="token operator">:</span> POSITION<span class="token punctuation">;</span>\n    min16float3 color   <span class="token operator">:</span> COLOR0<span class="token punctuation">;</span>\n    uint        instId  <span class="token operator">:</span> SV_InstanceID<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Per-vertex data passed to the geometry shader.</span>\n<span class="token comment">// Note that the render target array index is set here in the vertex shader.</span>\n<span class="token keyword">struct</span> <span class="token class-name">VertexShaderOutput</span>\n<span class="token punctuation">{</span>\n    min16float4 pos     <span class="token operator">:</span> SV_POSITION<span class="token punctuation">;</span>\n    min16float3 color   <span class="token operator">:</span> COLOR0<span class="token punctuation">;</span>\n    uint        rtvId   <span class="token operator">:</span> SV_RenderTargetArrayIndex<span class="token punctuation">;</span> <span class="token comment">// SV_InstanceID % 2 // &lt;- RTVテクスチャアレイのindex</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Simple shader to do vertex processing on the GPU.</span>\nVertexShaderOutput <span class="token function">main</span><span class="token punctuation">(</span>VertexShaderInput input<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    VertexShaderOutput output<span class="token punctuation">;</span>\n    float4 pos <span class="token operator">=</span> <span class="token function">float4</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>pos<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Note which view this vertex has been sent to. Used for matrix lookup.</span>\n    <span class="token comment">// Taking the modulo of the instance ID allows geometry instancing to be used</span>\n    <span class="token comment">// along with stereo instanced drawing; in that case, two copies of each</span>\n    <span class="token comment">// instance would be drawn, one for left and one for right.</span>\n    <span class="token keyword">int</span> idx <span class="token operator">=</span> input<span class="token punctuation">.</span>instId <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Transform the vertex position into world space.</span>\n    pos <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Correct for perspective and project the vertex position onto the screen.</span>\n    pos <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> viewProjection<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    output<span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token punctuation">(</span>min16float4<span class="token punctuation">)</span>pos<span class="token punctuation">;</span>\n\n    <span class="token comment">// Pass the color through without modification.</span>\n    output<span class="token punctuation">.</span>color <span class="token operator">=</span> input<span class="token punctuation">.</span>color<span class="token punctuation">;</span>\n\n    <span class="token comment">// Set the render target array index.</span>\n    output<span class="token punctuation">.</span>rtvId <span class="token operator">=</span> idx<span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> output<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",e.createElement(a.p,null,"どう違うのか\n見比べてみたところ、\nVPAndRTArrayIndexFromAnyShaderFeedingRasterizer=true の場合\nVertexShader で SV_RenderTargetArrayIndex を使うことが可能で、\nそうでない場合は VertexShader で使うことができないが GeometryShader で SV_RenderTargetArrayIndex を使うことが可能ということらしい。\nデバッガで確認したところ、実機・エミュレーター共に\nbackbuffer は D3D11_TEXTURE2D_DESC.ArraySize=2 となっていた。"),"\n",e.createElement(a.p,null,"https://developer.microsoft.com/en-us/windows/mixed-reality/rendering_in_directx#important_note_about_rendering_on_non-hololens_devices"),"\n",e.createElement(a.p,null,"実機では VPAndRTArrayIndexFromAnyShaderFeedingRasterizer=true、エミュレーターで false で gometryshader 版になることがわかった。\nSV_RenderTargetArrayIndex"),"\n",e.createElement(a.p,null,"VR のためのステレオレンダリングを高速化するアイデア"),"\n",e.createElement(a.p,null,"なんとなくわかってきた。"),"\n",e.createElement(a.p,null,"ジオメトリシェーダを使用した複数画面描画"),"\n",e.createElement(a.p,null,"SV_ViewportArrayIndex というのもあるらしい。\nなるほどー。"),"\n",e.createElement(a.p,null,"セマンティクス (DirectX HLSL)"),"\n",e.createElement(a.p,null,"まとめ\nD3D11 専用のレンダラを作ってみる。\nHololens と UWP 兼用のプロジェクトにできそうな気がする。\nHololens の初期化に失敗したら通常の UWP にフォールバックすればよいのではないか。"),"\n",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">HoloApp\n    Backbuffer\n    CameraUpdate\n    Input\n        |\n        v\n    +----------+\n    |SceneGraph|\n    |Renderer  |\n    +----------+\n        ^\n        |\n    Input\n    CameraUpdate\n    Backbuffer\nUwpApp</code></pre></div>'}}),"\n",e.createElement(a.p,null,"こんな感じのプロジェクトを模索してみよう。"))}var o=function(n){void 0===n&&(n={});const{wrapper:a}=Object.assign({},(0,t.ah)(),n.components);return a?e.createElement(a,n,e.createElement(p,n)):p(n)},c=(s(8678),s(8838));const u={code:n=>{let{children:a,className:s}=n;return s?e.createElement(c.Z,{className:s},a):e.createElement("code",null,a)}};function l(n){let{data:a,children:s}=n;return e.createElement(e.Fragment,null,e.createElement("h1",null,a.mdx.frontmatter.title),e.createElement(t.Zo,{components:u},s))}function r(n){return e.createElement(l,n,e.createElement(o,n))}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2017-07-hololens-cpp-md-7c571a523d1810b1e8dc.js.map