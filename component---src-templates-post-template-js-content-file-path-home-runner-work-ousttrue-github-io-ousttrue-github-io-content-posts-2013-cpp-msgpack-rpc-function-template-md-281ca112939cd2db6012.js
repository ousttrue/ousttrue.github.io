"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9395],{9920:function(n,e,t){t.r(e),t.d(e,{default:function(){return o}});var a=t(1151),s=t(7294);function l(n){const e=Object.assign({p:"p",span:"span"},(0,a.ah)(),n.components);return s.createElement(s.Fragment,null,s.createElement(e.p,null,"(記事復旧のついでに少し修正)"),"\n",s.createElement(e.p,null,"msgpack-rpcのリクエストは、によると"),"\n",s.createElement(e.p,null,s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">[type, msgid, method, params]</code>'}})),"\n",s.createElement(e.p,null,"という形式なのでmethod名をstd::stringとしてparamsをstd::tupleとして得られる。\nこれをサーバ側で如何に呼び出すかについて。"),"\n",s.createElement(e.p,null,"単純な実装だと以下のようにメソッド名をキーにして分岐することになる。"),"\n",s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">int and(int, int);\n\nclass dispatcher {\n\n    void dispatch(int msgid, const std::string &amp;method, const msgpack::object &amp;params)\n    {\n        if(method==“add”){ // 引数展開\n            std::tuple t; params.convert(&amp;t);\n\n            // 関数実行\n            int result=add(std::get&lt;0&gt;(t), std::get&lt;1&gt;(t));\n\n            // 結果のパッキング\n            // response [type, msgid, error, result]\n            msgpack::sbuffer response;\n            msgpack::packer&lt;msgpack::sbuffer&gt; pk(&amp;response);\n            pk.pack_array(4)\n            pk.pack(1);\n            pk.pack(msgid);\n            pk.pack_nil();\n            pk.pack(result);\n\n            // responseを送り返す\n        }\n        else{\n            throw “unknown func”;\n        }\n    }\n\n};</code></pre></div>'}}),"\n",s.createElement(e.p,null,"引数展開、関数呼び出し、結果のパッキングと一連の操作を定型処理として括りだすと下記のように書ける。"),"\n",s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">// ２引数展開用\nclass dispatcher {\n    // 実行\n    void dispatch(int msgid, const std::string &amp;method, const msgpack::object &amp;params)\n    {\n        if(method==“add”)\n        {\n            msgpack::sbuffer response=unpack_exec_pack(msgid, add, params);\n\n            // responseを送り返す\n        }\n        else{\n            throw “unknown func”;\n        }\n    }\n};\n\n// ヘルパー\ntemplate msgpack::sbuffer unpack_exec_pack(\n    int msgid, R(*f)(A1, A2), const msgpack::object &amp;params)\n{\n    // 引数展開\n    std::tuple t; params.convert(&amp;t);\n\n    // 関数実行\n    R result=add(std::get&lt;0&gt;(t), std::get&lt;1&gt;(t));\n\n    // 結果のパッキング\n    // response [type, msgid, error, result]\n    msgpack::sbuffer response;\n    msgpack::packer&lt;msgpack::sbuffer&gt; pk(&amp;response);\n    pk.pack_array(4)\n    pk.pack(1);\n    pk.pack(msgid);\n    pk.pack_nil();\n    pk.pack(result);\n\n    return response;\n}</code></pre></div>'}}),"\n",s.createElement(e.p,null,"１引数関数から９引数くらいまでと返り値void版を作ってやればだいたいの関数を登録することができる。"),"\n",s.createElement(e.p,null,"さらに 関数の登録と実行を分けるべく次のように拡張した。"),"\n",s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">class dispatcher {\n    std::map m_map;\n\n    // 実行\n    void dispatch(int msgid, const std::string &amp;method, const msgpack::object &amp;params)\n    {\n        std::function f=m_map.find(method);\n        if(f!=m_map.end()){\n            // 関数実行\n            msgpack::sbuffer resonse=f(msgid, params);\n\n            // responseを送り返す\n        }\n        else{\n            throw “unknown func”;\n        }\n    }\n\n    // 登録\n    template void add_handler(const std::string &amp;method, R(*f)(A1, A2))\n    {\n        m_map[method]=f-&gt;msgpack::sbuffer{\n\n            // 引数展開\n            std::tuple&lt;A1, A2&gt; t;\n            params.convert(&amp;t);\n\n            // 実行\n            R result=f(std::get&lt;0&gt;(t), std::get&lt;1&gt;(t));\n\n            // 結果のパッキング\n            // response [type, msgid, error, result]\n            msgpack::sbuffer response;\n            msgpack::packer&lt;msgpack::sbuffer&gt; pk(&amp;response);\n            pk.pack_array(4)\n            pk.pack(1);\n            pk.pack(msgid);\n            pk.pack_nil();\n            pk.pack(result);\n\n            return response;\n        };\n    }\n};</code></pre></div>'}}),"\n",s.createElement(e.p,null,s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">msgpack->引数展開->c++関数呼び出し->msgpack</code>'}})," への一連の操作を 同一のシグネチャの",s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::function</code>'}})," に 封じ込めることができる。"),"\n",s.createElement(e.p,null,"次にこれを関数ポインタ以外に関数オブジェクトを受け付けるように拡張したい。 まず、std::functionから実装。"),"\n",s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">// std::function用\ntemplate&lt;typname R, typename A1, typename A2&gt;\nvoid add_handler(contt std::string &amp;method, std::function&lt;R(A1, A2)&gt; f)\n{\n    // 中身同じ\n}</code></pre></div>'}}),"\n",s.createElement(e.p,null,"呼び出し時に ",s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::function</code>'}})," を経由するようにすればあらゆる関数呼び出しを登録できる。 例えば、ラムダ関数も以下のように登録できる。"),"\n",s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">// ラムダ登録\ndispatcher d;\nd.add_handler(&quot;add&quot;, std::function&lt;int(int, int)&gt;(\n    [](int a, int b)-&gt;int{ return a+b; }\n));</code></pre></div>'}}),"\n",s.createElement(e.p,null,"しかし、どうせなら"),"\n",s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">dispatcher d;\nd.add_handler(&quot;add&quot;, [](int a, int b)-&gt;int{ return a+b; });</code></pre></div>'}}),"\n",s.createElement(e.p,null,"と書きたい。"),"\n",s.createElement(e.p,null,"となると下記のような登録関数を書かねばならぬが関数のシグネチャがわからないので中身を記述することができない。"),"\n",s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">// ラムダの登録\ntemplate&lt;typname F&gt;\nvoid add_handler(const std::string &amp;method, F f)\n{\n    // 型がわからぬ\n}</code></pre></div>'}}),"\n",s.createElement(e.p,null,"ここで関数オブジェクトのoperator()へのポインタを型推論することでFのシグネチャを得ることができる。"),"\n",s.createElement(e.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">template\nvoid add_handler(const std::string &amp;method, F f, R(C::*)(A1, A2)const) {\n    // 中身同じ\n}\n// ラムダの登録\n// std::functionも受けられる\n// std::bindは無理だった\n// operator()がひとつしかない関数オブジェクトを受け付けられる？\n\ntemplate void add_handler(const std::string &amp;method, F f)\n{\n   // 上の関数で型推論させる\n   add_handler(method, f, &amp;F::operator());\n}</code></pre></div>'}}),"\n",s.createElement(e.p,null,"これでめでたくラムダも直接登録できるようになった。\nただし、operator()のオーバーロードが解決できないらしくstd::bindが登録できない。 std::bindに関しては、ラムダで代用できるしstd::functionでラップできるのでおいておくことにした。"))}var c=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,a.ah)(),n.components);return e?s.createElement(e,n,s.createElement(l,n)):l(n)},r=t(8678),p=t(1883),d=t(8838);const g={code:n=>{let{children:e,className:t}=n;return t?s.createElement(d.Z,{className:t},e):s.createElement("code",null,e)}};function m(n){let{data:e,children:t}=n;const l=e.mdx.frontmatter;return s.createElement(r.Z,null,s.createElement("h1",null,l.title),s.createElement("div",{className:"tags-index"},l.tags&&l.tags.length>0&&l.tags.map((n=>s.createElement(p.rU,{to:"/tags/"+n+"/",itemProp:"url"},s.createElement("button",null,n))))),s.createElement(a.Zo,{components:g},t))}function o(n){return s.createElement(m,n,s.createElement(c,n))}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2013-cpp-msgpack-rpc-function-template-md-281ca112939cd2db6012.js.map