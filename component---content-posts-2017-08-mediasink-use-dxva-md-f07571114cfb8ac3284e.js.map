{"version":3,"file":"component---content-posts-2017-08-mediasink-use-dxva-md-f07571114cfb8ac3284e.js","mappings":"yHAGA,SAASA,EAAkBC,GACzB,MAAMC,EAAcC,OAAOC,OAAO,CAChCC,EAAG,IACHC,IAAK,MACLC,KAAM,SACLC,EAAAA,EAAAA,MAAsBP,EAAMQ,YAC/B,OAAOC,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,2BAA4B,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,8FAA+F,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,sFAAuF,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,0BAA2B,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,8SAA+S,KAAMK,EAAAA,cAAoBR,EAAYI,IAAK,KAAMI,EAAAA,cAAoBR,EAAYK,KAAM,CACv4BI,UAAW,gBACV,+qBAAgrB,KAAMD,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,kHAAmH,KAAMK,EAAAA,cAAoBR,EAAYI,IAAK,KAAMI,EAAAA,cAAoBR,EAAYK,KAAM,CAC16BI,UAAW,gBACV,8nBAA+nB,KAAMD,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,0CAA2C,KAAMK,EAAAA,cAAoBR,EAAYI,IAAK,KAAMI,EAAAA,cAAoBR,EAAYK,KAAM,CACjzBI,UAAW,gBACV,2vBAA4vB,KAAMD,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,uIAAwI,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,qDAAsD,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,kCAAmC,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,6CAA8C,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,gHAAiH,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,WAAY,KAAMK,EAAAA,cAAoBR,EAAYI,IAAK,KAAMI,EAAAA,cAAoBR,EAAYK,KAAM,CAC1/CI,UAAW,gBACV,yaAA0a,KAAMD,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,8CAA+C,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,uBAAwB,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,kDAAmD,KAAMK,EAAAA,cAAoBR,EAAYI,IAAK,KAAMI,EAAAA,cAAoBR,EAAYK,KAAM,CACzwBI,UAAW,gBACV,ySAA0S,KAAMD,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,iNAAkN,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,6DAA8D,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,mHAAoH,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,yBAA0B,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,sBAAuB,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,0CAA2C,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAMK,EAAAA,cAAoBR,EAAYK,KAAM,KAAM,yCACpoC,CAKA,UAJA,SAAoBN,QAAK,IAALA,IAAAA,EAAQ,CAAC,GAC3B,MAAOW,QAASC,GAAaV,OAAOC,OAAO,CAAC,GAAGI,EAAAA,EAAAA,MAAsBP,EAAMQ,YAC3E,OAAOI,EAAYH,EAAAA,cAAoBG,EAAWZ,EAAOS,EAAAA,cAAoBV,EAAmBC,IAAUD,EAAkBC,EAC9H,C,sECSO,MAAMa,EAAa,gBAAoB,CAAC,GAiCxC,SAASC,EAAiBN,GAC/B,MAAMO,EAAoB,aAAiBF,GAG3C,OAAO,WAAc,IAEO,mBAAfL,EACFA,EAAWO,GAGb,IAAIA,KAAsBP,IAChC,CAACO,EAAmBP,GACzB,C","sources":["webpack:///./content/posts/2017/08/mediasink_use_dxva.md","webpack:///./node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"MediaSink で DXVA を使うには。\"), \"\\n\", React.createElement(_components.p, null, \"https://github.com/Microsoft/Windows-classic-samples/tree/master/Samples/DX11VideoRenderer\"), \"\\n\", React.createElement(_components.p, null, \"解読の後半。\\nDXVA が何かということについてはぼんやりとしているのだけれど、VideoSample のバッファーに D3D のテクスチャを使うということぽい。\"), \"\\n\", React.createElement(_components.p, null, \"DirectX Surface Buffer\"), \"\\n\", React.createElement(_components.p, null, \"ということは Pipeline のどこかのタイミングで CPU 上の bitmap を CreateTexture して GPU に移動するのだけど、Decoder なり Renderer なりのなるべく上流で GPU に上げた方がうれしいという話。\\nID3D11Device を MediaSession に供給する\\nPipeline でテクスチャをやりとりするのだからデバイスを共有しましょうと。MediaSession の場合は、レンダラがデバイスを作成して IMFDXGIDeviceManager を公開する。\\n公開するのは IMFGetService を通してぽい。\\nこの辺。\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-c++\"\n  }, \"HRESULT DX11VideoRenderer::CMediaSink::GetService(__RPC__in REFGUID guidService, __RPC__in REFIID riid, __RPC__deref_out_opt LPVOID* ppvObject)\\n{\\n    HRESULT hr = S_OK;\\n\\n    if (guidService == MF_RATE_CONTROL_SERVICE)\\n    {\\n        hr = QueryInterface(riid, ppvObject);\\n    }\\n    else if (guidService == MR_VIDEO_RENDER_SERVICE)\\n    {\\n        hr = m_pPresenter->QueryInterface(riid, ppvObject);\\n    }\\n    else if (guidService == MR_VIDEO_ACCELERATION_SERVICE)\\n    {\\n        // ここからIMFDXGIDeviceManagerを得る\\n        hr = m_pPresenter->GetService(guidService, riid, ppvObject);\\n    }\\n    else\\n    {\\n        hr = MF_E_UNSUPPORTED_SERVICE;\\n    }\\n\\n    return hr;\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, \"実験\\nまだ IMFGetService を実装していない VideoRenderer で、\\nProcessSample に入ってくる IMFSample から IMFDXGIBuffer が取得できるか試してみよう。\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-c++\"\n  }, \"DWORD cBuffers = 0;\\nauto hr = pSample->GetBufferCount(&cBuffers);\\nif (FAILED(hr))\\n{\\n    return hr;\\n}\\n\\nMicrosoft::WRL::ComPtr<IMFMediaBuffer> pBuffer;\\nif (1 == cBuffers)\\n{\\n    hr = pSample->GetBufferByIndex(0, &pBuffer);\\n}\\nelse\\n{\\n    hr = pSample->ConvertToContiguousBuffer(&pBuffer);\\n}\\nif (FAILED(hr))\\n{\\n    return hr;\\n}\\n\\nMicrosoft::WRL::ComPtr<IMFDXGIBuffer> pDXGIBuffer;\\nhr = pBuffer.As(&pDXGIBuffer);\\nif (FAILED(hr))\\n{\\n    // ここに来た\\n    return hr;\\n}\\n\\nMicrosoft::WRL::ComPtr<ID3D11Texture2D> pTexture2D;\\nhr = pDXGIBuffer->GetResource(IID_PPV_ARGS(&pTexture2D));\\nif (FAILED(hr))\\n{\\n    return hr;\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, \"実験２\\nStreamSink に IMFGetService を実装した。\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-c++\"\n  }, \"// IMFGetService\\nSTDMETHODIMP GetService(__RPC__in REFGUID guidService, __RPC__in REFIID riid, __RPC__deref_out_opt LPVOID* ppvObject)override\\n{\\n    HRESULT hr = S_OK;\\n\\n    if (guidService == MR_VIDEO_ACCELERATION_SERVICE)\\n    {\\n        if (riid == __uuidof(IMFDXGIDeviceManager))\\n        {\\n            if (NULL != m_pDXGIManager)\\n            {\\n                *ppvObject = (void*) static_cast<IUnknown*>(m_pDXGIManager);\\n                ((IUnknown*)*ppvObject)->AddRef();\\n            }\\n            else\\n            {\\n                hr = E_NOINTERFACE;\\n            }\\n        }\\n        else\\n        {\\n            hr = E_NOINTERFACE;\\n        }\\n    }\\n    else\\n    {\\n        hr = MF_E_UNSUPPORTED_SERVICE;\\n    }\\n\\n    return hr;\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, \"IMFSample から ID3D11Texture2D を取得できた。\\n上流が、DXVA 化されて Sample のバッファがテクスチャになった。\\nどんなテクスチャなのか\\nArraySize = 13\\nFormat = DXGI_FORMAT_NV12\"), \"\\n\", React.createElement(_components.p, null, \"中身がよくわからぬ。\\nDecode された yuv フレームを Swapchain にコピーする\"), \"\\n\", React.createElement(_components.p, null, \"deinterlace\\nYUV To RGB\\nサイズ調整\"), \"\\n\", React.createElement(_components.p, null, \"等をしてデコード済みのフレームを RGB 画像にする工程。\\n２種類の実装がある。\"), \"\\n\", React.createElement(_components.p, null, \"https://github.com/Microsoft/Windows-classic-samples/blob/master/Samples/DX11VideoRenderer/cpp/Presenter.cpp\"), \"\\n\", React.createElement(_components.p, null, \"の以下の部分。\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-c++\"\n  }, \"if (m_useXVP)\\n{\\n    BOOL bInputFrameUsed = FALSE;\\n\\n    hr = ProcessFrameUsingXVP( pCurrentType, pSample, pTexture2D, rcDest, ppOutputSample, &bInputFrameUsed );\\n\\n    if (SUCCEEDED(hr) && !bInputFrameUsed)\\n    {\\n        *pbProcessAgain = TRUE;\\n    }\\n}\\nelse\\n{\\n    hr = ProcessFrameUsingD3D11( pTexture2D, pEVTexture2D, dwViewIndex, dwEVViewIndex, rcDest, *punInterlaceMode, ppOutputSample );\\n\\n    // 省略\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, \"どちらでもだいたい同じ動きになると思う。\\nProcessFrameUsingXVP\"), \"\\n\", React.createElement(_components.p, null, \"Video Processor MFT\"), \"\\n\", React.createElement(_components.p, null, \"初期化時に IDXGIDeviceManager を直接渡して DXVA を有効にしている。\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-c++\"\n  }, \"hr = CoCreateInstance(CLSID_VideoProcessorMFT, nullptr, CLSCTX_INPROC_SERVER, IID_IMFTransform, (void**)&m_pXVP);\\nif (FAILED(hr))\\n{\\n    break;\\n}\\n\\n// MFTにDirectXを渡す\\nhr = m_pXVP->ProcessMessage(MFT_MESSAGE_SET_D3D_MANAGER, ULONG_PTR(m_pDXGIManager));\\nif (FAILED(hr))\\n{\\n    break;\\n}\\n\")), \"\\n\", React.createElement(_components.p, null, \"Texture の入ったサンプルを処理して、Texture の入ったサンプルに出力できる。\\nProcessFrameUsingD3D11\\nD3D11VideoDevice を使う。\\nこっちの方が手順が長くて大変。\\nおそらく、VideoProcessorMFT は D3D11VideoDevice を使って実装していてこちらの方がローレベルなのであろう。\\nDecode\\nAPI の説明としてはこれ。\"), \"\\n\", React.createElement(_components.p, null, \"Supporting Direct3D 11 Video Decoding in Media Foundation\"), \"\\n\", React.createElement(_components.p, null, \"DX11VideoRenderer サンプルでは、直接使っていない。\\nVideo Processing\\nDX11VideoRenderer サンプルでは、D3D11VideoDevice を最後の色変換等で使っている。\"), \"\\n\", React.createElement(_components.p, null, \"DXVA Video Processing\"), \"\\n\", React.createElement(_components.p, null, \"Video Process Blit\"), \"\\n\", React.createElement(_components.p, null, \"DXVA2.0+D3D9 のドキュメントぽい。\\nD3D11 ではこの関数。\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"D3D11VideoContext::VideoProcessorBlt\")));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('mdx/types.js').MDXComponents} Components\n *\n * @typedef Props\n *   Configuration.\n * @property {Components | MergeComponents | null | undefined} [components]\n *   Mapping of names for JSX components to React components.\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context.\n * @property {ReactNode | null | undefined} [children]\n *   Children.\n *\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Components} currentComponents\n *   Current components from the context.\n * @returns {Components}\n *   Merged components.\n */\n\nimport React from 'react'\n\n/**\n * @type {import('react').Context<Components>}\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components and\n *   `MDXProvider` to set context based components instead.\n */\nexport const MDXContext = React.createContext({})\n\n/**\n * @param {import('react').ComponentType<any>} Component\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components instead.\n */\nexport function withMDXComponents(Component) {\n  return boundMDXComponent\n\n  /**\n   * @param {Record<string, unknown> & {components?: Components | null | undefined}} props\n   * @returns {JSX.Element}\n   */\n  function boundMDXComponent(props) {\n    const allComponents = useMDXComponents(props.components)\n    return React.createElement(Component, {...props, allComponents})\n  }\n}\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Components | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that takes the current\n *   components and filters/merges/changes them.\n * @returns {Components}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(() => {\n    // Custom merge via a function prop\n    if (typeof components === 'function') {\n      return components(contextComponents)\n    }\n\n    return {...contextComponents, ...components}\n  }, [contextComponents, components])\n}\n\n/** @type {Components} */\nconst emptyObject = {}\n\n/**\n * Provider for MDX context\n *\n * @param {Props} props\n * @returns {JSX.Element}\n */\nexport function MDXProvider({components, children, disableParentContext}) {\n  /** @type {Components} */\n  let allComponents\n\n  if (disableParentContext) {\n    allComponents =\n      typeof components === 'function'\n        ? components({})\n        : components || emptyObject\n  } else {\n    allComponents = useMDXComponents(components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","p","pre","code","_provideComponents","components","React","className","wrapper","MDXLayout","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}