<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="generator" content="Nikola (getnikola.com)">
<meta name="viewport" content="width=device-width">
<script src="../../../../assets/js/all-nocdn.js"></script><title>MediaSinkを実装する | 三次元日誌</title>
<link href="../../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
</head>
<body>
    <h1 id="brand">
        <a href="../../../../" title="三次元日誌" rel="home">
            <span id="blog-title">三次元日誌</span>
        </a>
    </h1>

    <nav id="menu"><ul>
<li><a href="../../../../archive.html">Archives</a></li>
<li><a href="../../../../categories/index.html">Tags</a></li>
<li><a href="../../../../rss.xml">RSS feed</a></li>
<li><a href="../../../../about">About</a></li>
<li><a href="../../../../books">MemoBooks</a></li>

            
            
            
        </ul></nav><hr>
<main id="content"><h1 class="p-name entry-title" itemprop="headline name">
    <h1 class="p-name entry-title" itemprop="headline name">
    <a href="." class="u-url">MediaSinkを実装する
    </a>
</h1>
<ul itemprop="keywords" class="tags">
<li>
        <time datetime="2017-08-27T00:00:00+09:00" title="2017-08-27">2017-08-27</time>
</li>
    <li><a class="tag p-category" href="../../../../categories/d3d/" rel="tag">d3d</a></li>
    <li><a class="tag p-category" href="../../../../categories/mediafoundation/" rel="tag">mediafoundation</a></li>
</ul>
</h1>

<p>DX11VideoRendererを解読して、VideoRenderer要件を探る。</p>
<p>Microsoftのサンプルがあり参考になる。</p>
<p>https://github.com/Microsoft/Windows-classic-samples/tree/master/Samples/DX11VideoRenderer</p>
<p>これは結構がっつり作ってあるので、削って最低限必要な要素を探る。
IMFMediaSinkを作る
手抜きしてIMFActivate抜きで。
https://github.com/Microsoft/Windows-classic-samples/blob/master/Samples/DX11VideoRenderer/c++/DX11VideoRenderer.h
を参考に最低限を実装してみる。
guidgen.exeでguidを決めた。
CustomVideoRenderer.h</p>
<h2>pragma once</h2>
<h2>include <windows.h></windows.h>
</h2>
<p>// {8C5C51AD-F400-4B2A-BD36-4990D07420B4}
DEFINE_GUID(CLSID_CustomVideoRenderer, 
0x8c5c51ad, 0xf400, 0x4b2a, 0xbd, 0x36, 0x49, 0x90, 0xd0, 0x74, 0x20, 0xb4);</p>
<p>STDAPI CreateCustomVideoRenderer(REFIID riid, void **ppvObject);</p>
<p>DX11VideoRendererから必要な部分をコピペしてくるだけである。
CustomVideoRenderer.c++</p>
<h2>include "CustomVideoRenderer.h"</h2>
<h2>include <mfidl.h></mfidl.h>
</h2>
<p>class CustomVideoRenderer: public IMFMediaSink
{
    ULONG m_nRefCount = 1;</p>
<p>public:
    // IUnknown
    STDMETHODIMP_(ULONG) AddRef(void)override
    {
        return InterlockedIncrement(&amp;m_nRefCount);
    }</p>
<pre class="code literal-block"><span class="n">STDMETHODIMP</span> <span class="n">QueryInterface</span><span class="p">(</span><span class="n">REFIID</span> <span class="n">iid</span><span class="p">,</span> <span class="n">__RPC__deref_out</span> <span class="n">_Result_nullonfailure_</span> <span class="n">void</span><span class="o">**</span> <span class="n">ppv</span><span class="p">)</span><span class="n">override</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppv</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">E_POINTER</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iid</span> <span class="o">==</span> <span class="n">IID_IUnknown</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">ppv</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">IUnknown</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">IMFMediaSink</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iid</span> <span class="o">==</span> <span class="n">__uuidof</span><span class="p">(</span><span class="n">IMFMediaSink</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">ppv</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">IMFMediaSink</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">ppv</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">E_NOINTERFACE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">AddRef</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">S_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">STDMETHODIMP_</span><span class="p">(</span><span class="n">ULONG</span><span class="p">)</span> <span class="n">Release</span><span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">override</span>
<span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">uCount</span> <span class="o">=</span> <span class="n">InterlockedDecrement</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_nRefCount</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">delete</span> <span class="n">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">//</span> <span class="n">For</span> <span class="n">thread</span> <span class="n">safety</span><span class="p">,</span> <span class="k">return</span> <span class="n">a</span> <span class="n">temporary</span> <span class="n">variable</span><span class="o">.</span>
    <span class="k">return</span> <span class="n">uCount</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">IMFMediaSink</span> <span class="n">methods</span>
<span class="n">STDMETHODIMP</span> <span class="n">AddStreamSink</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">dwStreamSinkIdentifier</span><span class="p">,</span> <span class="n">__RPC__in_opt</span> <span class="n">IMFMediaType</span><span class="o">*</span> <span class="n">pMediaType</span><span class="p">,</span> <span class="n">__RPC__deref_out_opt</span> <span class="n">IMFStreamSink</span><span class="o">**</span> <span class="n">ppStreamSink</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">GetCharacteristics</span><span class="p">(</span><span class="n">__RPC__out</span> <span class="n">DWORD</span><span class="o">*</span> <span class="n">pdwCharacteristics</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">GetPresentationClock</span><span class="p">(</span><span class="n">__RPC__deref_out_opt</span> <span class="n">IMFPresentationClock</span><span class="o">**</span> <span class="n">ppPresentationClock</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">GetStreamSinkById</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">dwIdentifier</span><span class="p">,</span> <span class="n">__RPC__deref_out_opt</span> <span class="n">IMFStreamSink</span><span class="o">**</span> <span class="n">ppStreamSink</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">GetStreamSinkByIndex</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">dwIndex</span><span class="p">,</span> <span class="n">__RPC__deref_out_opt</span> <span class="n">IMFStreamSink</span><span class="o">**</span> <span class="n">ppStreamSink</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">GetStreamSinkCount</span><span class="p">(</span><span class="n">__RPC__out</span> <span class="n">DWORD</span><span class="o">*</span> <span class="n">pcStreamSinkCount</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">RemoveStreamSink</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">dwStreamSinkIdentifier</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">SetPresentationClock</span><span class="p">(</span><span class="n">__RPC__in_opt</span> <span class="n">IMFPresentationClock</span><span class="o">*</span> <span class="n">pPresentationClock</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">Shutdown</span><span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
</pre>
<p>};</p>
<p>STDAPI CreateCustomVideoRenderer(REFIID riid, void **ppvObject)
{
    if(!ppvObject){
        return E_FAIL;
    }</p>
<pre class="code literal-block"><span class="nv">auto</span> <span class="nv">sink</span><span class="o">=</span><span class="nv">new</span> <span class="nv">CustomVideoRenderer</span><span class="ss">()</span><span class="c1">;</span>
<span class="o">*</span><span class="nv">ppvObject</span><span class="o">=</span><span class="nv">sink</span><span class="c1">;</span>
<span class="k">return</span> <span class="nv">S_OK</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>使う
IMFStreamSinkからIMFTopologyNodeを作る。</p>
<p>Creating Output Nodes</p>
<pre class="code literal-block"><span class="nt">Microsoft</span><span class="p">::</span><span class="nd">WRL</span><span class="p">::</span><span class="nd">ComPtr</span><span class="o">&lt;</span><span class="nt">IMFTopologyNode</span><span class="o">&gt;</span> <span class="nt">pOutputNode</span><span class="o">;</span>
<span class="nt">if</span><span class="o">(</span><span class="nt">FAILED</span><span class="o">(</span><span class="nt">hr</span> <span class="o">=</span> <span class="nt">MFCreateTopologyNode</span><span class="o">(</span><span class="nt">MF_TOPOLOGY_OUTPUT_NODE</span><span class="o">,</span> <span class="o">&amp;</span><span class="nt">pOutputNode</span><span class="o">)))</span>
<span class="p">{</span>
    <span class="err">return</span> <span class="err">hr</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">Microsoft</span><span class="p">::</span><span class="nd">WRL</span><span class="p">::</span><span class="nd">ComPtr</span><span class="o">&lt;</span><span class="nt">IMFMediaSink</span><span class="o">&gt;</span> <span class="nt">pSink</span><span class="o">;</span>
<span class="o">//</span> <span class="nt">自前のIMFMediaSinkを作る</span>
<span class="nt">if</span><span class="o">(</span><span class="nt">FAILED</span><span class="o">(</span><span class="nt">hr</span><span class="o">=</span><span class="nt">CreateCustomVideoRenderer</span><span class="o">(</span><span class="nt">IID_PPV_ARGS</span><span class="o">(&amp;</span><span class="nt">pSink</span><span class="o">))))</span><span class="p">{</span>
    <span class="err">return</span> <span class="err">hr</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">Microsoft</span><span class="p">::</span><span class="nd">WRL</span><span class="p">::</span><span class="nd">ComPtr</span><span class="o">&lt;</span><span class="nt">IMFStreamSink</span><span class="o">&gt;</span> <span class="nt">pSSink</span><span class="o">;</span>
<span class="nt">if</span><span class="o">(</span><span class="nt">FAILED</span><span class="o">(</span><span class="nt">hr</span><span class="o">=</span><span class="nt">pSink-</span><span class="o">&gt;</span><span class="nt">GetStreamSinkByIndex</span><span class="o">(</span><span class="nt">0</span><span class="o">,</span> <span class="o">&amp;</span><span class="nt">pSSink</span><span class="o">)))</span><span class="p">{</span>
    <span class="err">//</span> <span class="err">まだ作っていないのでここでエラーになる</span>
    <span class="err">return</span> <span class="err">hr</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">if</span> <span class="o">(</span><span class="nt">FAILED</span><span class="o">(</span><span class="nt">hr</span> <span class="o">=</span> <span class="nt">pOutputNode-</span><span class="o">&gt;</span><span class="nt">SetObject</span><span class="o">(</span><span class="nt">pSSink</span><span class="p">.</span><span class="nc">Get</span><span class="o">())))</span>
<span class="p">{</span>
    <span class="err">return</span> <span class="err">hr</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>IMFStreamSinkがひとつは必要
作る。
class CustomVideoStreamSink: public IMFStreamSink
{
    ULONG m_nRefCount = 1;</p>
<pre class="code literal-block"><span class="k">const</span> <span class="n">DWORD</span>                 <span class="n">STREAM_ID</span><span class="p">;</span>
<span class="n">CCritSec</span><span class="o">&amp;</span>                   <span class="n">m_critSec</span><span class="p">;</span>                      <span class="o">//</span> <span class="n">critical</span> <span class="n">section</span> <span class="k">for</span> <span class="n">thread</span> <span class="n">safety</span>
<span class="n">Microsoft</span><span class="p">::</span><span class="n">WRL</span><span class="p">::</span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IMFMediaSink</span><span class="o">&gt;</span>               <span class="n">m_pSink</span><span class="p">;</span>
</pre>
<p>public:
    CustomVideoStreamSink(DWORD dwStreamId, CCritSec&amp; critSec
            , IMFMediaSink *parent)
        : STREAM_ID(dwStreamId)
          , m_critSec(critSec)
          , m_pSink(parent)
    {
    }</p>
<pre class="code literal-block"><span class="o">//</span> <span class="n">IUnknown</span>
<span class="n">STDMETHODIMP_</span><span class="p">(</span><span class="n">ULONG</span><span class="p">)</span> <span class="n">AddRef</span><span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">QueryInterface</span><span class="p">(</span><span class="n">REFIID</span> <span class="n">iid</span><span class="p">,</span> <span class="n">__RPC__deref_out</span> <span class="n">_Result_nullonfailure_</span> <span class="n">void</span><span class="o">**</span> <span class="n">ppv</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP_</span><span class="p">(</span><span class="n">ULONG</span><span class="p">)</span> <span class="n">Release</span><span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>

<span class="o">//</span> <span class="n">IMFStreamSink</span>
<span class="n">STDMETHODIMP</span> <span class="n">Flush</span><span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">GetIdentifier</span><span class="p">(</span><span class="n">__RPC__out</span> <span class="n">DWORD</span><span class="o">*</span> <span class="n">pdwIdentifier</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">GetMediaSink</span><span class="p">(</span><span class="n">__RPC__deref_out_opt</span> <span class="n">IMFMediaSink</span><span class="o">**</span> <span class="n">ppMediaSink</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">GetMediaTypeHandler</span><span class="p">(</span><span class="n">__RPC__deref_out_opt</span> <span class="n">IMFMediaTypeHandler</span><span class="o">**</span> <span class="n">ppHandler</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">PlaceMarker</span><span class="p">(</span><span class="n">MFSTREAMSINK_MARKER_TYPE</span> <span class="n">eMarkerType</span><span class="p">,</span> <span class="n">__RPC__in</span> <span class="k">const</span> <span class="n">PROPVARIANT</span><span class="o">*</span> <span class="n">pvarMarkerValue</span><span class="p">,</span> <span class="n">__RPC__in</span> <span class="k">const</span> <span class="n">PROPVARIANT</span><span class="o">*</span> <span class="n">pvarContextValue</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">ProcessSample</span><span class="p">(</span><span class="n">__RPC__in_opt</span> <span class="n">IMFSample</span><span class="o">*</span> <span class="n">pSample</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>

<span class="o">//</span> <span class="n">IMFMediaEventGenerator</span> <span class="p">(</span><span class="n">from</span> <span class="n">IMFStreamSink</span><span class="p">)</span>
<span class="n">STDMETHODIMP</span> <span class="n">BeginGetEvent</span><span class="p">(</span><span class="n">IMFAsyncCallback</span><span class="o">*</span> <span class="n">pCallback</span><span class="p">,</span><span class="n">IUnknown</span><span class="o">*</span> <span class="n">punkState</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">EndGetEvent</span><span class="p">(</span><span class="n">IMFAsyncResult</span><span class="o">*</span> <span class="n">pResult</span><span class="p">,</span> <span class="n">_Out_</span> <span class="n">IMFMediaEvent</span><span class="o">**</span> <span class="n">ppEvent</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">GetEvent</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">dwFlags</span><span class="p">,</span> <span class="n">__RPC__deref_out_opt</span> <span class="n">IMFMediaEvent</span><span class="o">**</span> <span class="n">ppEvent</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
<span class="n">STDMETHODIMP</span> <span class="n">QueueEvent</span><span class="p">(</span><span class="n">MediaEventType</span> <span class="n">met</span><span class="p">,</span> <span class="n">__RPC__in</span> <span class="n">REFGUID</span> <span class="n">guidExtendedType</span><span class="p">,</span> <span class="n">HRESULT</span> <span class="n">hrStatus</span><span class="p">,</span> <span class="n">__RPC__in_opt</span> <span class="k">const</span> <span class="n">PROPVARIANT</span><span class="o">*</span> <span class="n">pvValue</span><span class="p">)</span><span class="n">override</span><span class="p">;</span>
</pre>
<p>};</p>
<p>メソッドの中身は
return E_FAIL;</p>
<p>でお茶を濁した。
IMFMediaSink::AddStreamSink実装
IMFMediaSink::GetStreamSinkById実装
IMFMediaSink::GetStreamSinkByIndex実装
IMFMediaSink::GetStreamSinkCount実装
IMFMediaSink::RemoveStreamSink実装
実行してみる。
// Handler for Media Session events.
void OnPlayerEvent(HWND hwnd, WPARAM pUnkPtr)
{
    HRESULT hr = g_pPlayer-&gt;HandleEvent(pUnkPtr);
    if (FAILED(hr))
    {
        // ここに来る
        NotifyError(hwnd, L"An error occurred.", hr);
    }
    UpdateUI(hwnd, g_pPlayer-&gt;GetState());
}</p>
<pre class="code literal-block"><span class="c1">// Get the event status. If the operation that triggered the event </span>
<span class="c1">// did not succeed, the status is a failure code.</span>
<span class="n">HRESULT</span> <span class="n">hrStatus</span> <span class="o">=</span> <span class="n">S_OK</span><span class="p">;</span>
<span class="n">hr</span> <span class="o">=</span> <span class="n">pEvent</span><span class="o">-&gt;</span><span class="n">GetStatus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hrStatus</span><span class="p">);</span>

<span class="c1">// Check if the async operation succeeded.</span>
<span class="nf">if</span> <span class="p">(</span><span class="n">SUCCEEDED</span><span class="p">(</span><span class="n">hr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">FAILED</span><span class="p">(</span><span class="n">hrStatus</span><span class="p">))</span> 
<span class="p">{</span>
    <span class="c1">// ここに来る</span>
    <span class="n">hr</span><span class="o">=</span><span class="n">hrStatus</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>デバッガで調べたらIMFStreamSink::GetMediaSinkの直後にエラーになることがわかった。
IMFStreamSink::GetMediaSink実装
たんたんとエラーを直していく。
IMFStreamSink::GetMediaTypeHandler実装
HRESULT DX11VideoRenderer::CStreamSink::GetMediaTypeHandler(__RPC__deref_out_opt IMFMediaTypeHandler** ppHandler)
{
    CAutoLock lock(&amp;m_critSec);</p>
<pre class="code literal-block"><span class="nf">if</span> <span class="p">(</span><span class="n">ppHandler</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kr">return</span> <span class="n">E_POINTER</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">HRESULT</span> <span class="n">hr</span> <span class="o">=</span> <span class="n">CheckShutdown</span><span class="p">();</span>

<span class="c1">// This stream object acts as its own type handler, so we QI ourselves.</span>
<span class="nf">if</span> <span class="p">(</span><span class="n">SUCCEEDED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">hr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">QueryInterface</span><span class="p">(</span><span class="n">IID_IMFMediaTypeHandler</span><span class="p">,</span> <span class="p">(</span><span class="n">void</span><span class="o">**</span><span class="p">)</span><span class="n">ppHandler</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">return</span> <span class="n">hr</span><span class="p">;</span>
</pre>
<p>}</p>
<p>IMFMediaTypeHandlerが必要。
StreamSinkにIMFMediaTypeHandlerを実装
このインタフェースはStreamSinkが処理できるMediaTypeを示すので必要。
サポートするフォーマットを決める。
// IMFMediaTypeHandler
STDMETHODIMP GetCurrentMediaType(<em>Outptr</em> IMFMediaType<strong> ppMediaType);
STDMETHODIMP GetMajorType(__RPC__out GUID* pguidMajorType);
STDMETHODIMP GetMediaTypeByIndex(DWORD dwIndex, <em>Outptr</em> IMFMediaType</strong> ppType);
STDMETHODIMP GetMediaTypeCount(__RPC__out DWORD<em> pdwTypeCount);
STDMETHODIMP IsMediaTypeSupported(IMFMediaType</em> pMediaType, <em>Outptr_opt_result_maybenull</em> IMFMediaType*<em> ppMediaType);
STDMETHODIMP SetCurrentMediaType(IMFMediaType</em> pMediaType);</p>
<p>PresentationClockが必要</p>
<p>Presentation Clock</p>
<p>IMFMediaSink::GetPresentationClock実装
IMFMediaSink::SetPresentationClock実装
MediaSinkにIMFClockStateSinkを実装
// IMFClockStateSink methods
STDMETHODIMP OnClockPause(MFTIME hnsSystemTime);
STDMETHODIMP OnClockRestart(MFTIME hnsSystemTime);
STDMETHODIMP OnClockSetRate(MFTIME hnsSystemTime, float flRate);
STDMETHODIMP OnClockStart(MFTIME hnsSystemTime, LONGLONG llClockStartOffset);
STDMETHODIMP OnClockStop(MFTIME hnsSystemTime);</p>
<p>Data Flow
ここまでの実装でIMFSession::Startの呼び出しに応じてIMFClockStateSink::OnClockStartが呼ばれるようになった。
Data Flow</p>
<p>Media sinks use a pull model</p>
<p>MesiaSink側からサンプルを取りに行かないといけない。</p>
<p>[1] The client sets the media types and the presentation clock. The media sink registers itself with the presentation clock to receive notifications about clock state changes.
[2][3][4] はPreroll。ミニマムを目指す今回は省略。
[5] The client calls IMFPresentationClock::Start to start the presentation clock.
[6] The presentation clock notifies the media sink that the clock is starting, by calling IMFClockStateSink::OnClockStart.
[7] To get more data, each stream sink sends MEStreamSinkRequestSample events. In response to each of these events, the client gets the next sample and calls ProcessSample. This step is repeated until the presentation ends.</p>
<p>State Changes
IMFClockStateSinkの実装について。</p>
<p>In addition, stream sinks must send the following events when they have completed the state transitions:</p>
<p>OnClockStart, OnClockRestart: MEStreamSinkStarted event
OnClockPause: MEStreamSinkPaused event
OnClockStop: MEStreamSinkStopped event</p>
<p>なるほど。
STDMETHODIMP OnClockStart(MFTIME hnsSystemTime, LONGLONG llClockStartOffset)override
{
    CAutoLock lock(&amp;m_csMediaSink);</p>
<pre class="code literal-block"><span class="n">HRESULT</span> <span class="n">hr</span> <span class="o">=</span> <span class="n">CheckShutdown</span><span class="p">();</span>
<span class="nf">if</span> <span class="p">(</span><span class="n">SUCCEEDED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// これが必要。このあとMEStreamSinkRequestSampleを受け付ける</span>
    <span class="c1">//</span>
    <span class="n">hr</span> <span class="o">=</span> <span class="n">m_pStream</span><span class="o">-&gt;</span><span class="n">QueueEvent</span><span class="p">(</span><span class="n">MEStreamSinkStarted</span><span class="p">,</span> <span class="n">GUID_NULL</span><span class="p">,</span> <span class="n">hr</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">if</span> <span class="p">(</span><span class="n">SUCCEEDED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">hr</span> <span class="o">=</span> <span class="n">m_pStream</span><span class="o">-&gt;</span><span class="n">QueueEvent</span><span class="p">(</span><span class="n">MEStreamSinkRequestSample</span><span class="p">,</span> <span class="n">GUID_NULL</span><span class="p">,</span> <span class="n">hr</span><span class="p">,</span> <span class="n">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">return</span> <span class="n">hr</span><span class="p">;</span>
</pre>
<p>}</p>
<p>ついにIMFStreamSink::ProcessSampleがコールされた。
試しに下記のような実装にしてみたがこれではClock無視で最速でフレームを消化してしまうのでだめ。
int m_count = 0;
STDMETHODIMP ProcessSample(__RPC__in_opt IMFSample* pSample)override
{
    ++m_count;</p>
<pre class="code literal-block"><span class="nv">auto</span> <span class="nv">hr</span> <span class="o">=</span> <span class="nv">S_OK</span><span class="c1">;</span>
<span class="nv">hr</span> <span class="o">=</span> <span class="nv">QueueEvent</span><span class="ss">(</span><span class="nv">MEStreamSinkRequestSample</span>, <span class="nv">GUID_NULL</span>, <span class="nv">hr</span>, <span class="nv">NULL</span><span class="ss">)</span><span class="c1">;</span>

<span class="k">return</span> <span class="nv">hr</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>MEStreamSinkRequestSampleをスケジューリングする</p>
<p>Scheduled Work Items</p>
<p>これを使ってみる。
BOOL NeedMoreSamples(void)
{
    const DWORD cSamplesInFlight = /<em>m_SamplesToProcess.GetCount() +</em>/ m_cOutstandingSampleRequests;</p>
<pre class="code literal-block"><span class="k">return</span> <span class="nv">cSamplesInFlight</span> <span class="o">&lt;</span> <span class="nv">SAMPLE_QUEUE_HIWATER_THRESHOLD</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>HRESULT RequestSamples(IMFAsyncResult* pAsyncResult)
{
    HRESULT hr = S_OK;</p>
<pre class="code literal-block"><span class="k">while</span> <span class="ss">(</span><span class="nv">NeedMoreSamples</span><span class="ss">())</span>
{
    <span class="nv">hr</span> <span class="o">=</span> <span class="nv">CheckShutdown</span><span class="ss">()</span><span class="c1">;</span>
    <span class="k">if</span> <span class="ss">(</span><span class="nv">FAILED</span><span class="ss">(</span><span class="nv">hr</span><span class="ss">))</span>
    {
        <span class="k">break</span><span class="c1">;</span>
    }

    <span class="nv">m_cOutstandingSampleRequests</span><span class="o">++</span><span class="c1">;</span>

    <span class="nv">hr</span> <span class="o">=</span> <span class="nv">QueueEvent</span><span class="ss">(</span><span class="nv">MEStreamSinkRequestSample</span>, <span class="nv">GUID_NULL</span>, <span class="nv">S_OK</span>, <span class="nv">NULL</span><span class="ss">)</span><span class="c1">;</span>
}

<span class="o">//</span> 再突入
<span class="nv">hr</span><span class="o">=</span><span class="nv">QueueRequest</span><span class="ss">()</span><span class="c1">;</span>

<span class="k">return</span> <span class="nv">hr</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>// 正しいRateにする必要がある
const INT64 interval = 1000 / 30;</p>
<p>HRESULT QueueRequest()
{
    HRESULT hr = S_OK;</p>
<pre class="code literal-block"><span class="k">if</span> <span class="ss">(</span><span class="nv">SUCCEEDED</span><span class="ss">(</span><span class="nv">hr</span><span class="ss">))</span>
{
    <span class="o">//</span> <span class="nv">Enqueue</span>
    <span class="nv">MFWORKITEM_KEY</span> <span class="nv">cancelKey</span><span class="c1">;</span>
    <span class="nv">hr</span> <span class="o">=</span> <span class="nv">MFScheduleWorkItem</span><span class="ss">(</span><span class="o">&amp;</span><span class="nv">m_WorkQueueCB</span>, <span class="nv">nullptr</span>, <span class="o">-</span><span class="nv">interval</span>, <span class="o">&amp;</span><span class="nv">cancelKey</span><span class="ss">)</span><span class="c1">;</span>
}

<span class="k">return</span> <span class="nv">hr</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>int m_count = 0;
STDMETHODIMP ProcessSample(__RPC__in_opt IMFSample* pSample)override
{
    ++m_count;</p>
<pre class="code literal-block"><span class="nv">m_cOutstandingSampleRequests</span><span class="o">--</span><span class="c1">;</span>

<span class="o">//</span> <span class="k">do</span> <span class="nv">something</span>

<span class="k">return</span>  <span class="nv">S_OK</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>DX11VideoRenderer::CSchedulerを使えばよいと思う。
だいたい仕組みがわかった。
DX11VideoRendererから引き算して最小限の構成にする(ProcessSampleが何もしない)場合、
以下の部品を残す必要がありそう。</p>
<p>Scheduler
StreamSink: IMFStreamSink, IMFMediaTypeHandler
MesiaSink: IMFMediaSink, IMFClockStateSink</p>

<hr>
<ul class="pager hidden-print">
<li class="previous">
        <a href="../../../../github/mediafoundationsample/" rel="prev" title="MediaFoundationSample">
            MediaFoundationSample 👈
        </a>
    </li>
    <li style="flex-grow: 1">
    <li class="next">
        <a href="../mediasink_use_dxva/" rel="next" title="MediaSinkでDXVA">
            👉 MediaSinkでDXVA
        </a>
    </li>
</ul></main><footer id="footer"><p>
            Powered by
            <a href="https://getnikola.com" rel="nofollow">Nikola</a>
        </p>
    </footer>
</body>
</html>
