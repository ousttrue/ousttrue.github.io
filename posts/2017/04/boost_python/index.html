<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="generator" content="Nikola (getnikola.com)">
<meta name="viewport" content="width=device-width">
<script src="../../../../assets/js/all-nocdn.js"></script><title>Boost.Pythonのリンク周り | 三次元日誌</title>
<link href="../../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
</head>
<body>
    <h1 id="brand">
        <a href="../../../../" title="三次元日誌" rel="home">
            <span id="blog-title">三次元日誌</span>
        </a>
    </h1>

    <nav id="menu"><ul>
<li><a href="../../../../archive.html">Archives</a></li>
<li><a href="../../../../categories/index.html">Tags</a></li>
<li><a href="../../../../rss.xml">RSS feed</a></li>
<li><a href="../../../../about">About</a></li>
<li><a href="../../../../books">MemoBooks</a></li>

            
            
            
        </ul></nav><hr>
<main id="content"><h1 class="p-name entry-title" itemprop="headline name">
    <a href="." class="u-url">Boost.Pythonのリンク周り</a>
</h1>
<div>
<p>mmdbridgeのビルドで必要になったBoost.Python周り。
どうやら、OpenEXR界隈では結構使われている様子。
AlembicとかUSDとか。
しかしWindows版のBoost.Pythonはリンク周りにはまり要素が多いので、記録しといた。</p>
<p>Pythonへのリンク
python_d.libにリンクする必要がない場合
Python自体のデバッグをするのでなければpython_dにリンクする必要はない。
python_dへのリンクの必要性は、リンクするライブラリをDebugで統一する必要の有無なのだけど、
pydを作っているときは必要ない。python.exeではなくpython_d.exeから実行して何もかもが、Debugを参照するようにするのはつらい。そうではなくて自分のアプリがPythonを内臓する場合は、python_dにリンクした方がよい。DebugとReleaseの混在によるエラーが出る可能性があるので。で、mmdbridgeは後者なのでpython_dをリンクすることに妥当性がある。
python_d.libへのリンクを防止する</p>
<p>https://stackoverflow.com/questions/16200997/why-doesnt-include-python-h-work</p>
<h2>ifdef _DEBUG</h2>
<p>#undef _DEBUG
  #include <python.h>
  #define _DEBUG</python.h></p>
<h2>else</h2>
<p>#include <python.h></python.h></p>
<h2>endif</h2>
<p>これが、常套手段になるようでpydの開発時には入れておくとよい。
Boost.Pythonがpython_dにリンクする</p>
<p>boost-1.64.0
python-3.5.3</p>
<p>debug版のboostをビルドしたのだが、よく見るとRelease版のpython35.dllの方がリンクされていた。がんばって、DEBUGマクロの定義等を調べたのだがなかなかわからなかった。どうやらどこかでundef _DEBUGされているらしいと当たりがついた。</p>
<p>boost/python/detail/wrap_python.hpp</p>
<h2>ifdef _DEBUG</h2>
<h2>ifndef BOOST_DEBUG_PYTHON</h2>
<h2>ifdef _MSC_VER</h2>
<pre class="code literal-block"><span></span>// VC8.0 will complain if system headers are #included both with
// and without _DEBUG defined, so we have to #include all the
// system headers used by pyconfig.h right here.
</pre>

<h2>include <stddef.h></stddef.h>
</h2>
<h2>include <stdarg.h></stdarg.h>
</h2>
<h2>include <stdio.h></stdio.h>
</h2>
<h2>include <stdlib.h></stdlib.h>
</h2>
<h2>include <assert.h></assert.h>
</h2>
<h2>include <errno.h></errno.h>
</h2>
<h2>include <ctype.h></ctype.h>
</h2>
<h2>include <wchar.h></wchar.h>
</h2>
<h2>include <basetsd.h></basetsd.h>
</h2>
<h2>include <io.h></io.h>
</h2>
<h2>include <limits.h></limits.h>
</h2>
<h2>include <float.h></float.h>
</h2>
<h2>include <string.h></string.h>
</h2>
<h2>include <math.h></math.h>
</h2>
<h2>include <time.h></time.h>
</h2>
<h2>endif</h2>
<h2>undef _DEBUG // Don't let Python force the debug library just because we're debugging.</h2>
<h2>define DEBUG_UNDEFINED_FROM_WRAP_PYTHON_H</h2>
<h2>endif</h2>
<h2>endif</h2>
<p>python_d.libにリンクするには
b2 --with-python --debug-configuration python-debugging=on</p>
<p>として
libboost_python3-vc140-mt-gyd-1_64
を作成する。gydのyがpython debugらしい。
Boost.Pythonへのリンク
boostはどうやってリンクするライブラリの名前を決めているのか</p>
<h2>pragma comment(lib,"wsock32.lib")</h2>
<p>どこかに#pragmaが記述されているはずだが。</p>
<p>https://stackoverflow.com/questions/16200997/why-doesnt-include-python-h-work
http://d.hatena.ne.jp/torutk/20121004/p1</p>
<p>autolinkらしい。自動的に有効になる。</p>
<p>http://www.boost.org/doc/libs/1_48_0/boost/config/auto_link.hpp</p>
<p>pragmaリンクの名前が一致しないんだけど</p>
<p>libboost_python3-vc140-mt-gd-1_64にリンクしたいのだがlibboost_python-vc140-mt-gd-1_64にリンクしようとする
boost_python3_vc140-mt-gd-1_64にリンクしたいのいだがlibboost_python-vc140-mt-gd-1_64にリンクしようとする</p>
<p>BOOST_ALL_NO_LIB</p>
<p>を定義してautolinkを阻止して自分でリンクする。
python3はどうやって決まるのか
むしろboost_python3がBOOST_LIB_NAMEから決まる。
BOOST_LIB_NAMEは、boost/python/detail/config.hppで下記の記述がある。
boost-1.61.0</p>
<h2>define BOOST_LIB_NAME boost_python</h2>
<p>boost_python3.dllとboost_python.dllは両方Python3にリンクされとった
なんだってー。つまり、boostは複数のPythonに対するビルド結果を共存させることは考慮されていないということだった。なるほど
ReleaseビルドとDebugビルドは同じReleaseのdllにリンクするべき
Debug版であっても、boost_python.dllも同じRelease版にリンクされる。
AutoLinkに逆らわない方がよい。
CMakeのFIND_PACKAGE(BOOST)によるBoost_LIBRARIESは使わない方がよいかもしれない。デバッグの方にリンクされてはまりうる。ていうか、はまった。
結論として、AutoLink邪魔だーからAutoLinkに従えとなった。
pybindを使おう
ヘッダオンリーなので。リンク無いし。</p>
<p>https://github.com/pybind/pybind11</p>
<p>既存のBoost.Pythonを使ったコードでも、pybindはBoost.Pythonと似たAPIになっているので簡単に置き換えられる。</p>
<p>pybind11でC++の関数をpythonから使う</p>
</div>
    </main><footer id="footer"><p>
            Powered by
            <a href="https://getnikola.com" rel="nofollow">Nikola</a>
        </p>
    </footer>
</body>
</html>
