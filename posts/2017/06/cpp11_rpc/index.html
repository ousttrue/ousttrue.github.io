<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="generator" content="Nikola (getnikola.com)">
<meta name="viewport" content="width=device-width">
<script src="../../../../assets/js/all-nocdn.js"></script><title>C++でMessagePack-RPCを実装する | 三次元日誌</title>
<link href="../../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
</head>
<body>
    <h1 id="brand">
        <a href="../../../../" title="三次元日誌" rel="home">
            <span id="blog-title">三次元日誌</span>
        </a>
    </h1>
    <hr>
<main id="content"><h1 class="p-name entry-title" itemprop="headline name">
    <a href="." class="u-url">C++でMessagePack-RPCを実装する</a>
</h1>
<div>
<p>最近のC++(-std=c++14)でMessagePack-RPCを再実装してみる。</p>
<h2>基本設計</h2>
<p>MessagePack-RPCの仕様をおさらいすると以下の通り。</p>
<p>request</p>
<pre class="code literal-block"><span></span><span class="k">[type, msgid, method, params]</span>
 <span class="na">(0)   (int)  (str)   (array)</span>
</pre>

<p>response</p>
<pre class="code literal-block"><span></span><span class="k">[type, msgid, error, result]</span>
 <span class="na">(1)   (int)  (any)  (any)</span>
</pre>

<p>msgpackのバイト列を受け取って、msgpackのバイト列を返す関数として一般化する。</p>
<pre class="code literal-block"><span></span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">bytes</span><span class="p">;</span>
<span class="c1">// msgpackのバイト列を引数にとり、msgpackのバイト列を返す</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">bytes</span><span class="p">(</span><span class="k">const</span> <span class="o">&amp;</span><span class="n">bytes</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">procedurecall</span><span class="p">;</span>
</pre>

<p>任意の関数呼び出しからprocedurecallを作り出せるようにして、MessagePack-RPCシステムの部品として使えるようにする。
簡単な例
例として</p>
<pre class="code literal-block"><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</pre>

<p>をprocedurecallに変換してみる。</p>
<pre class="code literal-block"><span></span><span class="n">procedurecall</span> <span class="nf">make_procedurecall</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">// request -&gt; response ではなくparams -&gt; result</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">](</span><span class="k">const</span> <span class="n">bytes</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bytes</span>
    <span class="p">{</span>
        <span class="c1">// unpack args</span>
        <span class="k">auto</span> <span class="n">parser</span> <span class="o">=</span> <span class="n">msgpackpp</span><span class="o">::</span><span class="n">parser</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">args</span><span class="p">;</span>
        <span class="n">parser</span> <span class="o">&gt;&gt;</span> <span class="n">args</span><span class="p">;</span>

        <span class="c1">// call</span>
        <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">));</span>

        <span class="c1">// pack result</span>
        <span class="n">msgpackpp</span><span class="o">::</span><span class="n">packer</span> <span class="n">packer</span><span class="p">;</span>
        <span class="n">packer</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">packer</span><span class="p">.</span><span class="n">get_payload</span><span class="p">();</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre>

<p><code>int add(int, int)</code> を <code>procedurecall</code> に変換するというのは、引数のアンパック、関数呼び出し、結果のパックという一連の定型コードの呼び出しになる。</p>
<p><code>procedurecall</code> の使い方は以下の通り。</p>
<pre class="code literal-block"><span></span><span class="c1">// register</span>
<span class="k">auto</span> <span class="n">proc</span> <span class="o">=</span> <span class="n">msgpackpp</span><span class="o">::</span><span class="n">rpc</span><span class="o">::</span><span class="n">make_procedurecall</span><span class="p">(</span><span class="o">&amp;</span><span class="n">add</span><span class="p">);</span>

<span class="c1">// call</span>
<span class="k">auto</span> <span class="n">packer</span> <span class="o">=</span> <span class="n">msgpackpp</span><span class="o">::</span><span class="n">packer</span><span class="p">();</span>
<span class="n">packer</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">proc</span><span class="p">(</span><span class="n">packer</span><span class="p">.</span><span class="n">get_payload</span><span class="p">());</span>

<span class="c1">// result</span>
<span class="n">REQUIRE</span><span class="p">(</span><span class="mi">3</span> <span class="o">==</span> <span class="n">msgpackpp</span><span class="o">::</span><span class="n">parser</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">get_number</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
</pre>

<p>とりあえず動いたが、関数を増やすたびにこれだけのコードを記述するのはやってられませぬ。
以下のような理想形を目指して作りこんでゆく。</p>
<pre class="code literal-block"><span></span><span class="n">REQUIRE</span><span class="p">(</span><span class="mi">3</span> <span class="o">==</span> <span class="n">msgpack_procedurecall</span><span class="p">([](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span> <span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
</pre>

<p><code>lambda</code> が動けば他も動くようにできるので、<code>lambda</code> を第一に実装する。</p>
<h2>実装</h2>
<p>ステップ毎に説明しようと思っていたが分かりにくいので、コードにコメントを追加することにした。</p>
<pre class="code literal-block"><span></span><span class="n">make_procedurecall</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">AS</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">IS</span><span class="o">&gt;</span>
<span class="n">procedurecall</span> <span class="n">_make_procedurecall</span><span class="p">(</span><span class="k">const</span> <span class="n">F</span> <span class="o">&amp;</span><span class="n">f</span>
    <span class="p">,</span> <span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="p">)(</span><span class="n">AS</span><span class="p">...)</span><span class="k">const</span> <span class="c1">// template引数R, C, ASを受け付けるためのダミー</span>
    <span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">IS</span><span class="p">...</span><span class="o">&gt;</span> <span class="c1">// template引数ISを受け付けるためのダミー</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// request -&gt; response ではなくparams -&gt; result</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">](</span><span class="k">const</span> <span class="n">bytes</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bytes</span>
    <span class="p">{</span>
        <span class="c1">// unpack args</span>
        <span class="k">auto</span> <span class="n">parser</span> <span class="o">=</span> <span class="n">msgpackpp</span><span class="o">::</span><span class="n">parser</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">AS</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">args</span><span class="p">;</span>
        <span class="n">parser</span> <span class="o">&gt;&gt;</span> <span class="n">args</span><span class="p">;</span>

        <span class="c1">// call</span>
        <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">IS</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span> <span class="c1">// 可変長テンプレート引数を展開できる。ISと...が離れていることに注意</span>

        <span class="c1">// pack result</span>
        <span class="n">msgpackpp</span><span class="o">::</span><span class="n">packer</span> <span class="n">packer</span><span class="p">;</span>
        <span class="n">packer</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">packer</span><span class="p">.</span><span class="n">get_payload</span><span class="p">();</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">AS</span><span class="o">&gt;</span>
<span class="n">procedurecall</span> <span class="n">_make_procedurecall</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span>
    <span class="p">,</span> <span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="p">)(</span><span class="n">AS</span><span class="p">...)</span><span class="k">const</span> <span class="c1">// template引数R, C, ASを受け付けるためのダミー</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_make_procedurecall</span><span class="p">(</span><span class="n">f</span>
        <span class="p">,</span> <span class="o">&amp;</span><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">::</span><span class="k">operator</span><span class="p">()</span> <span class="c1">// lambdaの返り値と引数の型を次のテンプレートに渡す</span>
        <span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">index_sequence_for</span><span class="o">&lt;</span><span class="n">AS</span><span class="p">...</span><span class="o">&gt;</span><span class="p">{}</span> <span class="c1">// std::get呼び出しのためにindex_sequenceを作る。</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="c1">// あらゆる型のlambdaを受け付けるようにした</span>
<span class="c1">//</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="n">procedurecall</span> <span class="n">make_procedurecall</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_make_procedurecall</span><span class="p">(</span><span class="n">f</span>
        <span class="p">,</span> <span class="o">&amp;</span><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">::</span><span class="k">operator</span><span class="p">()</span> <span class="c1">// lambdaの返り値と引数の型を次のテンプレートに渡す</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="n">msgpack_call</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">AS</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">_msgpack_call</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span>
    <span class="p">,</span> <span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="p">)(</span><span class="n">AS</span><span class="p">...)</span><span class="k">const</span> <span class="c1">// template引数R, C, ASを受けるためのダミー</span>
    <span class="p">,</span> <span class="n">AS</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">proc</span> <span class="o">=</span> <span class="n">msgpackpp</span><span class="o">::</span><span class="n">rpc</span><span class="o">::</span><span class="n">make_procedurecall</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="c1">// call</span>
    <span class="n">msgpackpp</span><span class="o">::</span><span class="n">packer</span> <span class="n">packer</span><span class="p">;</span>
    <span class="n">packer</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span> <span class="c1">// 可変長テンプレート引数を展開できる</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">proc</span><span class="p">(</span><span class="n">packer</span><span class="p">.</span><span class="n">get_payload</span><span class="p">());</span>

    <span class="c1">// unpack result</span>
    <span class="n">R</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">msgpackpp</span><span class="o">::</span><span class="n">parser</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">AS</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">msgpack_call</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">AS</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="c1">// 返り値の型はreturnから型推論</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_msgpack_call</span><span class="p">(</span><span class="n">f</span>
    <span class="p">,</span> <span class="o">&amp;</span><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">::</span><span class="k">operator</span><span class="p">()</span> <span class="c1">// lambdaの返り値と引数の型をテンプレート引数に渡す</span>
    <span class="p">,</span> <span class="n">args</span><span class="p">...</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre>

<h2>使う。</h2>
<pre class="code literal-block"><span></span><span class="n">REQUIRE</span><span class="p">(</span><span class="mi">3</span><span class="o">==</span><span class="n">msgpack_call</span><span class="p">([](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
<span class="n">REQUIRE</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">==</span><span class="n">msgpack_call</span><span class="p">([](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span> <span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
</pre>

<p><code>valiadic template</code> おそるべし。
従来であれば、1引数、２引数・・・と引数の個数ごとに手作業でバージョンを増やさねばならなかったものが、わりとさくっと書けるな。</p>
</div>
    </main><footer id="footer"><p>
            Powered by
            <a href="https://getnikola.com" rel="nofollow">Nikola</a>
        </p>
    </footer>
</body>
</html>
