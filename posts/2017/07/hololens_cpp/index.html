<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="generator" content="Nikola (getnikola.com)">
<meta name="viewport" content="width=device-width">
<script src="../../../../assets/js/all-nocdn.js"></script><title>c++でHololens | 三次元日誌</title>
<link href="../../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
</head>
<body>
    <h1 id="brand">
        <a href="../../../../" title="三次元日誌" rel="home">
            <span id="blog-title">三次元日誌</span>
        </a>
    </h1>

    <nav id="menu"><ul>
<li><a href="../../../../archive.html">Archives</a></li>
<li><a href="../../../../categories/index.html">Tags</a></li>
<li><a href="../../../../rss.xml">RSS feed</a></li>
<li><a href="../../../../about">About</a></li>
<li><a href="../../../../books">MemoBooks</a></li>

            
            
            
        </ul></nav><hr>
<main id="content"><h1 class="p-name entry-title" itemprop="headline name">
    <h1 class="p-name entry-title" itemprop="headline name">
    <a href="." class="u-url">c++でHololens
    </a>
</h1>
<ul itemprop="keywords" class="tags">
<li>
        <time datetime="2017-07-09T00:00:00+09:00" title="2017-07-09">2017-07-09</time>
</li>
    <li><a class="tag p-category" href="../../../../categories/cpp/" rel="tag">cpp</a></li>
    <li><a class="tag p-category" href="../../../../categories/hololens/" rel="tag">hololens</a></li>
</ul>
</h1>

<p>SharpDXでHololensが頓挫したので、C++でまいりましょう。</p>
<p>VisualStudio2015update3しかUnivsersal cpp HolographicApp templateが含まれないので githubにコピーしておいた。</p>
<p>https://github.com/ousttrue/HolographicApp</p>
<p>エミュレーターで描画が乱れる件</p>
<blockquote>
<blockquote>
<p>(tools)から</p>
</blockquote>
</blockquote>
<p>checkを外したらなおった。
実機
問題ない。
Hololens特有の部分
通常のDirectXとHolographicAppの違いを調べていたのだけれど、
両目レンダリングを効率よくするために、複数のレンダーターゲットに対して
まとめてパイプラインを実行する関連のようだ。
VPAndRTArrayIndexFromAnyShaderFeedingRasterizer
VPAndRTArrayIndexFromAnyShaderFeedingRasterizerないとき(エミュレーター)
// A constant buffer that stores the model transform.
cbuffer ModelConstantBuffer : register(b0)
{
    float4x4 model;
};</p>
<p>// A constant buffer that stores each set of view and projection matrices in column-major format.
cbuffer ViewProjectionConstantBuffer : register(b1)
{
    float4x4 viewProjection[2];
};</p>
<p>// Per-vertex data used as input to the vertex shader.
struct VertexShaderInput
{
    min16float3 pos     : POSITION;
    min16float3 color   : COLOR0;
    uint        instId  : SV_InstanceID;
};</p>
<p>// Per-vertex data passed to the geometry shader.
// Note that the render target array index will be set by the geometry shader
// using the value of viewId.
struct VertexShaderOutput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        viewId  : TEXCOORD0;  // SV_InstanceID % 2
};</p>
<p>// Simple shader to do vertex processing on the GPU.
VertexShaderOutput main(VertexShaderInput input)
{
    VertexShaderOutput output;
    float4 pos = float4(input.pos, 1.0f);</p>
<pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Note</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="k">view</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">sent</span><span class="w"> </span><span class="k">to</span><span class="p">.</span><span class="w"> </span><span class="n">Used</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">matrix</span><span class="w"> </span><span class="n">lookup</span><span class="p">.</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="n">Taking</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">modulo</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="n">allows</span><span class="w"> </span><span class="n">geometry</span><span class="w"> </span><span class="n">instancing</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="n">along</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">stereo</span><span class="w"> </span><span class="n">instanced</span><span class="w"> </span><span class="n">drawing</span><span class="p">;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="k">case</span><span class="p">,</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">copies</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">each</span><span class="w"> </span>
<span class="o">//</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">would</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">drawn</span><span class="p">,</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nf">left</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nf">right</span><span class="p">.</span><span class="w"></span>
<span class="nc">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">input</span><span class="p">.</span><span class="n">instId</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="k">position</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="nf">space</span><span class="p">.</span><span class="w"></span>
<span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">);</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Correct</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">perspective</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">project</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="k">position</span><span class="w"> </span><span class="n">onto</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">screen</span><span class="p">.</span><span class="w"></span>
<span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">viewProjection</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span><span class="p">);</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">min16float4</span><span class="p">)</span><span class="n">pos</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Pass</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">through</span><span class="w"> </span><span class="k">without</span><span class="w"> </span><span class="n">modification</span><span class="p">.</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">input</span><span class="p">.</span><span class="n">color</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="k">Set</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">ID</span><span class="p">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">pass</span><span class="o">-</span><span class="n">through</span><span class="w"> </span><span class="n">geometry</span><span class="w"> </span><span class="n">shader</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">the</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="n">render</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">array</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">whatever</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">here</span><span class="p">.</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">viewId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="k">output</span><span class="p">;</span><span class="w"></span>
</pre>
<p>}</p>
<p>// Per-vertex data from the vertex shader.
struct GeometryShaderInput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        instId  : TEXCOORD0;
};</p>
<p>// Per-vertex data passed to the rasterizer.
struct GeometryShaderOutput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        rtvId   : SV_RenderTargetArrayIndex; // &lt;- RTVテクスチャアレイのindex
};</p>
<p>// This geometry shader is a pass-through that leaves the geometry unmodified 
// and sets the render target array index.
[maxvertexcount(3)]
void main(triangle GeometryShaderInput input[3], inout TriangleStream<geometryshaderoutput> outStream)
{
    GeometryShaderOutput output;
    [unroll(3)]
    for (int i = 0; i &lt; 3; ++i)
    {
        output.pos   = input[i].pos;
        output.color = input[i].color;
        output.rtvId = input[i].instId;
        outStream.Append(output);
    }
}</geometryshaderoutput></p>
<p>VPAndRTArrayIndexFromAnyShaderFeedingRasterizerあるとき
// A constant buffer that stores the model transform.
cbuffer ModelConstantBuffer : register(b0)
{
    float4x4 model;
};</p>
<p>// A constant buffer that stores each set of view and projection matrices in column-major format.
cbuffer ViewProjectionConstantBuffer : register(b1)
{
    float4x4 viewProjection[2];
};</p>
<p>// Per-vertex data used as input to the vertex shader.
struct VertexShaderInput
{
    min16float3 pos     : POSITION;
    min16float3 color   : COLOR0;
    uint        instId  : SV_InstanceID;
};</p>
<p>// Per-vertex data passed to the geometry shader.
// Note that the render target array index is set here in the vertex shader.
struct VertexShaderOutput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        rtvId   : SV_RenderTargetArrayIndex; // SV_InstanceID % 2 // &lt;- RTVテクスチャアレイのindex
};</p>
<p>// Simple shader to do vertex processing on the GPU.
VertexShaderOutput main(VertexShaderInput input)
{
    VertexShaderOutput output;
    float4 pos = float4(input.pos, 1.0f);</p>
<pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Note</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="k">view</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">sent</span><span class="w"> </span><span class="k">to</span><span class="p">.</span><span class="w"> </span><span class="n">Used</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">matrix</span><span class="w"> </span><span class="n">lookup</span><span class="p">.</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="n">Taking</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">modulo</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="n">allows</span><span class="w"> </span><span class="n">geometry</span><span class="w"> </span><span class="n">instancing</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="n">along</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">stereo</span><span class="w"> </span><span class="n">instanced</span><span class="w"> </span><span class="n">drawing</span><span class="p">;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="k">case</span><span class="p">,</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">copies</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">each</span><span class="w"> </span>
<span class="o">//</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">would</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">drawn</span><span class="p">,</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nf">left</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nf">right</span><span class="p">.</span><span class="w"></span>
<span class="nc">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">input</span><span class="p">.</span><span class="n">instId</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="k">position</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="nf">space</span><span class="p">.</span><span class="w"></span>
<span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">);</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Correct</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">perspective</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">project</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="k">position</span><span class="w"> </span><span class="n">onto</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">screen</span><span class="p">.</span><span class="w"></span>
<span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">viewProjection</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span><span class="p">);</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">min16float4</span><span class="p">)</span><span class="n">pos</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Pass</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">through</span><span class="w"> </span><span class="k">without</span><span class="w"> </span><span class="n">modification</span><span class="p">.</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">input</span><span class="p">.</span><span class="n">color</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="k">Set</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">render</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">array</span><span class="w"> </span><span class="k">index</span><span class="p">.</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">rtvId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="k">output</span><span class="p">;</span><span class="w"></span>
</pre>
<p>}</p>
<p>どう違うのか
見比べてみたところ、
VPAndRTArrayIndexFromAnyShaderFeedingRasterizer=trueの場合
VertexShaderでSV_RenderTargetArrayIndexを使うことが可能で、
そうでない場合はVertexShaderで使うことができないがGeometryShaderでSV_RenderTargetArrayIndexを使うことが可能ということらしい。
デバッガで確認したところ、実機・エミュレーター共に
backbufferはD3D11_TEXTURE2D_DESC.ArraySize=2となっていた。</p>
<p>https://developer.microsoft.com/en-us/windows/mixed-reality/rendering_in_directx#important_note_about_rendering_on_non-hololens_devices</p>
<p>実機ではVPAndRTArrayIndexFromAnyShaderFeedingRasterizer=true、エミュレーターでfalseでgometryshader版になることがわかった。
SV_RenderTargetArrayIndex</p>
<p>VRのためのステレオレンダリングを高速化するアイデア</p>
<p>なんとなくわかってきた。</p>
<p>ジオメトリシェーダを使用した複数画面描画</p>
<p>SV_ViewportArrayIndexというのもあるらしい。
なるほどー。</p>
<p>セマンティクス (DirectX HLSL)</p>
<p>まとめ
D3D11専用のレンダラを作ってみる。
HololensとUWP兼用のプロジェクトにできそうな気がする。
Hololensの初期化に失敗したら通常のUWPにフォールバックすればよいのではないか。
HoloApp
    Backbuffer
    CameraUpdate
    Input
        |
        v
    +----------+
    |SceneGraph|
    |Renderer  |
    +----------+
        ^
        |
    Input
    CameraUpdate
    Backbuffer
UwpApp</p>
<p>こんな感じのプロジェクトを模索してみよう。</p>

<hr>
<ul class="pager hidden-print">
<li class="previous">
        <a href="../../../../github/rigidtransformutils/" rel="prev" title="RigidTransformUtils">
            RigidTransformUtils 👈
        </a>
    </li>
    <li style="flex-grow: 1">
    <li class="next">
        <a href="../../../../github/thinrenderer/" rel="next" title="ThinRenderer">
            👉 ThinRenderer
        </a>
    </li>
</ul></main><footer id="footer"><p>
            Powered by
            <a href="https://getnikola.com" rel="nofollow">Nikola</a>
        </p>
    </footer>
</body>
</html>
