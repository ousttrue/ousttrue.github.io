<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="generator" content="Nikola (getnikola.com)">
<meta name="viewport" content="width=device-width">
<script src="../../../../assets/js/all-nocdn.js"></script><title>c++ã§Hololens | ä¸‰æ¬¡å…ƒæ—¥èªŒ</title>
<link href="../../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
</head>
<body>
    <h1 id="brand">
        <a href="../../../../" title="ä¸‰æ¬¡å…ƒæ—¥èªŒ" rel="home">
            <span id="blog-title">ä¸‰æ¬¡å…ƒæ—¥èªŒ</span>
        </a>
    </h1>

    <nav id="menu"><ul>
<li><a href="../../../../archive.html">Archives</a></li>
<li><a href="../../../../categories/index.html">Tags</a></li>
<li><a href="../../../../rss.xml">RSS feed</a></li>
<li><a href="../../../../about">About</a></li>
<li><a href="../../../../books">MemoBooks</a></li>

            
            
            
        </ul></nav><hr>
<main id="content"><h1 class="p-name entry-title" itemprop="headline name">
    <h1 class="p-name entry-title" itemprop="headline name">
    <a href="." class="u-url">c++ã§Hololens</a>
</h1>
<ul itemprop="keywords" class="tags">
<li>
        <time datetime="2017-07-09T00:00:00+09:00" title="2017-07-09">2017-07-09</time>
</li>
</ul>
</h1>

<div>
<p>SharpDXã§HololensãŒé “æŒ«ã—ãŸã®ã§ã€C++ã§ã¾ã„ã‚Šã¾ã—ã‚‡ã†ã€‚</p>
<p>VisualStudio2015update3ã—ã‹Univsersal cpp HolographicApp templateãŒå«ã¾ã‚Œãªã„ã®ã§ githubã«ã‚³ãƒ”ãƒ¼ã—ã¦ãŠã„ãŸã€‚</p>
<p>https://github.com/ousttrue/HolographicApp</p>
<p>ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§æç”»ãŒä¹±ã‚Œã‚‹ä»¶</p>
<blockquote>
<blockquote>
<p>(tools)ã‹ã‚‰</p>
</blockquote>
</blockquote>
<p>checkã‚’å¤–ã—ãŸã‚‰ãªãŠã£ãŸã€‚
å®Ÿæ©Ÿ
å•é¡Œãªã„ã€‚
Hololensç‰¹æœ‰ã®éƒ¨åˆ†
é€šå¸¸ã®DirectXã¨HolographicAppã®é•ã„ã‚’èª¿ã¹ã¦ã„ãŸã®ã ã‘ã‚Œã©ã€
ä¸¡ç›®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’åŠ¹ç‡ã‚ˆãã™ã‚‹ãŸã‚ã«ã€è¤‡æ•°ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å¯¾ã—ã¦
ã¾ã¨ã‚ã¦ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹é–¢é€£ã®ã‚ˆã†ã ã€‚
VPAndRTArrayIndexFromAnyShaderFeedingRasterizer
VPAndRTArrayIndexFromAnyShaderFeedingRasterizerãªã„ã¨ã(ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼)
// A constant buffer that stores the model transform.
cbuffer ModelConstantBuffer : register(b0)
{
    float4x4 model;
};</p>
<p>// A constant buffer that stores each set of view and projection matrices in column-major format.
cbuffer ViewProjectionConstantBuffer : register(b1)
{
    float4x4 viewProjection[2];
};</p>
<p>// Per-vertex data used as input to the vertex shader.
struct VertexShaderInput
{
    min16float3 pos     : POSITION;
    min16float3 color   : COLOR0;
    uint        instId  : SV_InstanceID;
};</p>
<p>// Per-vertex data passed to the geometry shader.
// Note that the render target array index will be set by the geometry shader
// using the value of viewId.
struct VertexShaderOutput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        viewId  : TEXCOORD0;  // SV_InstanceID % 2
};</p>
<p>// Simple shader to do vertex processing on the GPU.
VertexShaderOutput main(VertexShaderInput input)
{
    VertexShaderOutput output;
    float4 pos = float4(input.pos, 1.0f);</p>
<pre class="code literal-block"><span></span>// Note which view this vertex has been sent to. Used for matrix lookup.
// Taking the modulo of the instance ID allows geometry instancing to be used
// along with stereo instanced drawing; in that case, two copies of each 
// instance would be drawn, one for left and one for right.
int idx = input.instId % 2;

// Transform the vertex position into world space.
pos = mul(pos, model);

// Correct for perspective and project the vertex position onto the screen.
pos = mul(pos, viewProjection[idx]);
output.pos = (min16float4)pos;

// Pass the color through without modification.
output.color = input.color;

// Set the instance ID. The pass-through geometry shader will set the
// render target array index to whatever value is set here.
output.viewId = idx;

return output;
</pre>

<p>}</p>
<p>// Per-vertex data from the vertex shader.
struct GeometryShaderInput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        instId  : TEXCOORD0;
};</p>
<p>// Per-vertex data passed to the rasterizer.
struct GeometryShaderOutput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        rtvId   : SV_RenderTargetArrayIndex; // &lt;- RTVãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒ¬ã‚¤ã®index
};</p>
<p>// This geometry shader is a pass-through that leaves the geometry unmodified 
// and sets the render target array index.
[maxvertexcount(3)]
void main(triangle GeometryShaderInput input[3], inout TriangleStream<geometryshaderoutput> outStream)
{
    GeometryShaderOutput output;
    [unroll(3)]
    for (int i = 0; i &lt; 3; ++i)
    {
        output.pos   = input[i].pos;
        output.color = input[i].color;
        output.rtvId = input[i].instId;
        outStream.Append(output);
    }
}</geometryshaderoutput></p>
<p>VPAndRTArrayIndexFromAnyShaderFeedingRasterizerã‚ã‚‹ã¨ã
// A constant buffer that stores the model transform.
cbuffer ModelConstantBuffer : register(b0)
{
    float4x4 model;
};</p>
<p>// A constant buffer that stores each set of view and projection matrices in column-major format.
cbuffer ViewProjectionConstantBuffer : register(b1)
{
    float4x4 viewProjection[2];
};</p>
<p>// Per-vertex data used as input to the vertex shader.
struct VertexShaderInput
{
    min16float3 pos     : POSITION;
    min16float3 color   : COLOR0;
    uint        instId  : SV_InstanceID;
};</p>
<p>// Per-vertex data passed to the geometry shader.
// Note that the render target array index is set here in the vertex shader.
struct VertexShaderOutput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        rtvId   : SV_RenderTargetArrayIndex; // SV_InstanceID % 2 // &lt;- RTVãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒ¬ã‚¤ã®index
};</p>
<p>// Simple shader to do vertex processing on the GPU.
VertexShaderOutput main(VertexShaderInput input)
{
    VertexShaderOutput output;
    float4 pos = float4(input.pos, 1.0f);</p>
<pre class="code literal-block"><span></span>// Note which view this vertex has been sent to. Used for matrix lookup.
// Taking the modulo of the instance ID allows geometry instancing to be used
// along with stereo instanced drawing; in that case, two copies of each 
// instance would be drawn, one for left and one for right.
int idx = input.instId % 2;

// Transform the vertex position into world space.
pos = mul(pos, model);

// Correct for perspective and project the vertex position onto the screen.
pos = mul(pos, viewProjection[idx]);
output.pos = (min16float4)pos;

// Pass the color through without modification.
output.color = input.color;

// Set the render target array index.
output.rtvId = idx;

return output;
</pre>

<p>}</p>
<p>ã©ã†é•ã†ã®ã‹
è¦‹æ¯”ã¹ã¦ã¿ãŸã¨ã“ã‚ã€
VPAndRTArrayIndexFromAnyShaderFeedingRasterizer=trueã®å ´åˆ
VertexShaderã§SV_RenderTargetArrayIndexã‚’ä½¿ã†ã“ã¨ãŒå¯èƒ½ã§ã€
ãã†ã§ãªã„å ´åˆã¯VertexShaderã§ä½¿ã†ã“ã¨ãŒã§ããªã„ãŒGeometryShaderã§SV_RenderTargetArrayIndexã‚’ä½¿ã†ã“ã¨ãŒå¯èƒ½ã¨ã„ã†ã“ã¨ã‚‰ã—ã„ã€‚
ãƒ‡ãƒãƒƒã‚¬ã§ç¢ºèªã—ãŸã¨ã“ã‚ã€å®Ÿæ©Ÿãƒ»ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼å…±ã«
backbufferã¯D3D11_TEXTURE2D_DESC.ArraySize=2ã¨ãªã£ã¦ã„ãŸã€‚</p>
<p>https://developer.microsoft.com/en-us/windows/mixed-reality/rendering_in_directx#important_note_about_rendering_on_non-hololens_devices</p>
<p>å®Ÿæ©Ÿã§ã¯VPAndRTArrayIndexFromAnyShaderFeedingRasterizer=trueã€ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§falseã§gometryshaderç‰ˆã«ãªã‚‹ã“ã¨ãŒã‚ã‹ã£ãŸã€‚
SV_RenderTargetArrayIndex</p>
<p>VRã®ãŸã‚ã®ã‚¹ãƒ†ãƒ¬ã‚ªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’é«˜é€ŸåŒ–ã™ã‚‹ã‚¢ã‚¤ãƒ‡ã‚¢</p>
<p>ãªã‚“ã¨ãªãã‚ã‹ã£ã¦ããŸã€‚</p>
<p>ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚·ã‚§ãƒ¼ãƒ€ã‚’ä½¿ç”¨ã—ãŸè¤‡æ•°ç”»é¢æç”»</p>
<p>SV_ViewportArrayIndexã¨ã„ã†ã®ã‚‚ã‚ã‚‹ã‚‰ã—ã„ã€‚
ãªã‚‹ã»ã©ãƒ¼ã€‚</p>
<p>ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ (DirectX HLSL)</p>
<p>ã¾ã¨ã‚
D3D11å°‚ç”¨ã®ãƒ¬ãƒ³ãƒ€ãƒ©ã‚’ä½œã£ã¦ã¿ã‚‹ã€‚
Hololensã¨UWPå…¼ç”¨ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã§ããã†ãªæ°—ãŒã™ã‚‹ã€‚
Hololensã®åˆæœŸåŒ–ã«å¤±æ•—ã—ãŸã‚‰é€šå¸¸ã®UWPã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚Œã°ã‚ˆã„ã®ã§ã¯ãªã„ã‹ã€‚
HoloApp
    Backbuffer
    CameraUpdate
    Input
        |
        v
    +----------+
    |SceneGraph|
    |Renderer  |
    +----------+
        ^
        |
    Input
    CameraUpdate
    Backbuffer
UwpApp</p>
<p>ã“ã‚“ãªæ„Ÿã˜ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¨¡ç´¢ã—ã¦ã¿ã‚ˆã†ã€‚</p>
</div>

<ul class="pager hidden-print">
<li class="previous">
        <a href="../../../../github/rigidtransformutils/" rel="prev" title="RigidTransformUtils">
            RigidTransformUtils ğŸ‘ˆ
        </a>
    </li>
    <li style="flex-grow: 1">
    <li class="next">
        <a href="../../../../github/thinrenderer/" rel="next" title="ThinRenderer">
            ğŸ‘‰ ThinRenderer
        </a>
    </li>
</ul></main><footer id="footer"><p>
            Powered by
            <a href="https://getnikola.com" rel="nofollow">Nikola</a>
        </p>
    </footer>
</body>
</html>
