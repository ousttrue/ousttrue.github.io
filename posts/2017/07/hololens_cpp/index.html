<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="generator" content="Nikola (getnikola.com)">
<meta name="viewport" content="width=device-width">
<script src="../../../../assets/js/all-nocdn.js"></script><title>c++ã§Hololens | ä¸‰æ¬¡å…ƒæ—¥èªŒ</title>
<link href="../../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
</head>
<body>
    <h1 id="brand">
        <a href="../../../../" title="ä¸‰æ¬¡å…ƒæ—¥èªŒ" rel="home">
            <span id="blog-title">ä¸‰æ¬¡å…ƒæ—¥èªŒ</span>
        </a>
    </h1>

    <nav id="menu"><ul>
<li><a href="../../../../archive.html">Archives</a></li>
<li><a href="../../../../categories/index.html">Tags</a></li>
<li><a href="../../../../rss.xml">RSS feed</a></li>
<li><a href="../../../../about">About</a></li>
<li><a href="../../../../books">MemoBooks</a></li>

            
            
            
        </ul></nav><hr>
<main id="content"><h1 class="p-name entry-title" itemprop="headline name">
    <h1 class="p-name entry-title" itemprop="headline name">
    <a href="." class="u-url">c++ã§Hololens
    </a>
</h1>
<ul itemprop="keywords" class="tags">
<li>
        <time datetime="2017-07-09T00:00:00+09:00" title="2017-07-09">2017-07-09</time>
</li>
    <li><a class="tag p-category" href="../../../../categories/cpp/" rel="tag">cpp</a></li>
    <li><a class="tag p-category" href="../../../../categories/hololens/" rel="tag">hololens</a></li>
</ul>
</h1>

<p>SharpDXã§HololensãŒé “æŒ«ã—ãŸã®ã§ã€C++ã§ã¾ã„ã‚Šã¾ã—ã‚‡ã†ã€‚</p>
<p>VisualStudio2015update3ã—ã‹Univsersal cpp HolographicApp templateãŒå«ã¾ã‚Œãªã„ã®ã§ githubã«ã‚³ãƒ”ãƒ¼ã—ã¦ãŠã„ãŸã€‚</p>
<p>https://github.com/ousttrue/HolographicApp</p>
<p>ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§æç”»ãŒä¹±ã‚Œã‚‹ä»¶</p>
<blockquote>
<blockquote>
<p>(tools)ã‹ã‚‰</p>
</blockquote>
</blockquote>
<p>checkã‚’å¤–ã—ãŸã‚‰ãªãŠã£ãŸã€‚
å®Ÿæ©Ÿ
å•é¡Œãªã„ã€‚
Hololensç‰¹æœ‰ã®éƒ¨åˆ†
é€šå¸¸ã®DirectXã¨HolographicAppã®é•ã„ã‚’èª¿ã¹ã¦ã„ãŸã®ã ã‘ã‚Œã©ã€
ä¸¡ç›®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’åŠ¹ç‡ã‚ˆãã™ã‚‹ãŸã‚ã«ã€è¤‡æ•°ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å¯¾ã—ã¦
ã¾ã¨ã‚ã¦ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹é–¢é€£ã®ã‚ˆã†ã ã€‚
VPAndRTArrayIndexFromAnyShaderFeedingRasterizer
VPAndRTArrayIndexFromAnyShaderFeedingRasterizerãªã„ã¨ã(ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼)
// A constant buffer that stores the model transform.
cbuffer ModelConstantBuffer : register(b0)
{
    float4x4 model;
};</p>
<p>// A constant buffer that stores each set of view and projection matrices in column-major format.
cbuffer ViewProjectionConstantBuffer : register(b1)
{
    float4x4 viewProjection[2];
};</p>
<p>// Per-vertex data used as input to the vertex shader.
struct VertexShaderInput
{
    min16float3 pos     : POSITION;
    min16float3 color   : COLOR0;
    uint        instId  : SV_InstanceID;
};</p>
<p>// Per-vertex data passed to the geometry shader.
// Note that the render target array index will be set by the geometry shader
// using the value of viewId.
struct VertexShaderOutput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        viewId  : TEXCOORD0;  // SV_InstanceID % 2
};</p>
<p>// Simple shader to do vertex processing on the GPU.
VertexShaderOutput main(VertexShaderInput input)
{
    VertexShaderOutput output;
    float4 pos = float4(input.pos, 1.0f);</p>
<pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Note</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="k">view</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">sent</span><span class="w"> </span><span class="k">to</span><span class="p">.</span><span class="w"> </span><span class="n">Used</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">matrix</span><span class="w"> </span><span class="n">lookup</span><span class="p">.</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="n">Taking</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">modulo</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="n">allows</span><span class="w"> </span><span class="n">geometry</span><span class="w"> </span><span class="n">instancing</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="n">along</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">stereo</span><span class="w"> </span><span class="n">instanced</span><span class="w"> </span><span class="n">drawing</span><span class="p">;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="k">case</span><span class="p">,</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">copies</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">each</span><span class="w"> </span>
<span class="o">//</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">would</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">drawn</span><span class="p">,</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nf">left</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nf">right</span><span class="p">.</span><span class="w"></span>
<span class="nc">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">input</span><span class="p">.</span><span class="n">instId</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="k">position</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="nf">space</span><span class="p">.</span><span class="w"></span>
<span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">);</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Correct</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">perspective</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">project</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="k">position</span><span class="w"> </span><span class="n">onto</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">screen</span><span class="p">.</span><span class="w"></span>
<span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">viewProjection</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span><span class="p">);</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">min16float4</span><span class="p">)</span><span class="n">pos</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Pass</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">through</span><span class="w"> </span><span class="k">without</span><span class="w"> </span><span class="n">modification</span><span class="p">.</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">input</span><span class="p">.</span><span class="n">color</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="k">Set</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">ID</span><span class="p">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">pass</span><span class="o">-</span><span class="n">through</span><span class="w"> </span><span class="n">geometry</span><span class="w"> </span><span class="n">shader</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">the</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="n">render</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">array</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">whatever</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">here</span><span class="p">.</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">viewId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="k">output</span><span class="p">;</span><span class="w"></span>
</pre>
<p>}</p>
<p>// Per-vertex data from the vertex shader.
struct GeometryShaderInput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        instId  : TEXCOORD0;
};</p>
<p>// Per-vertex data passed to the rasterizer.
struct GeometryShaderOutput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        rtvId   : SV_RenderTargetArrayIndex; // &lt;- RTVãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒ¬ã‚¤ã®index
};</p>
<p>// This geometry shader is a pass-through that leaves the geometry unmodified 
// and sets the render target array index.
[maxvertexcount(3)]
void main(triangle GeometryShaderInput input[3], inout TriangleStream<geometryshaderoutput> outStream)
{
    GeometryShaderOutput output;
    [unroll(3)]
    for (int i = 0; i &lt; 3; ++i)
    {
        output.pos   = input[i].pos;
        output.color = input[i].color;
        output.rtvId = input[i].instId;
        outStream.Append(output);
    }
}</geometryshaderoutput></p>
<p>VPAndRTArrayIndexFromAnyShaderFeedingRasterizerã‚ã‚‹ã¨ã
// A constant buffer that stores the model transform.
cbuffer ModelConstantBuffer : register(b0)
{
    float4x4 model;
};</p>
<p>// A constant buffer that stores each set of view and projection matrices in column-major format.
cbuffer ViewProjectionConstantBuffer : register(b1)
{
    float4x4 viewProjection[2];
};</p>
<p>// Per-vertex data used as input to the vertex shader.
struct VertexShaderInput
{
    min16float3 pos     : POSITION;
    min16float3 color   : COLOR0;
    uint        instId  : SV_InstanceID;
};</p>
<p>// Per-vertex data passed to the geometry shader.
// Note that the render target array index is set here in the vertex shader.
struct VertexShaderOutput
{
    min16float4 pos     : SV_POSITION;
    min16float3 color   : COLOR0;
    uint        rtvId   : SV_RenderTargetArrayIndex; // SV_InstanceID % 2 // &lt;- RTVãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒ¬ã‚¤ã®index
};</p>
<p>// Simple shader to do vertex processing on the GPU.
VertexShaderOutput main(VertexShaderInput input)
{
    VertexShaderOutput output;
    float4 pos = float4(input.pos, 1.0f);</p>
<pre class="code literal-block"><span class="o">//</span><span class="w"> </span><span class="n">Note</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="k">view</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">sent</span><span class="w"> </span><span class="k">to</span><span class="p">.</span><span class="w"> </span><span class="n">Used</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">matrix</span><span class="w"> </span><span class="n">lookup</span><span class="p">.</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="n">Taking</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">modulo</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="n">allows</span><span class="w"> </span><span class="n">geometry</span><span class="w"> </span><span class="n">instancing</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="n">along</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">stereo</span><span class="w"> </span><span class="n">instanced</span><span class="w"> </span><span class="n">drawing</span><span class="p">;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="k">case</span><span class="p">,</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">copies</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">each</span><span class="w"> </span>
<span class="o">//</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="n">would</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">drawn</span><span class="p">,</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nf">left</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nf">right</span><span class="p">.</span><span class="w"></span>
<span class="nc">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">input</span><span class="p">.</span><span class="n">instId</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Transform</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="k">position</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="nf">space</span><span class="p">.</span><span class="w"></span>
<span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">);</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Correct</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">perspective</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">project</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="k">position</span><span class="w"> </span><span class="n">onto</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">screen</span><span class="p">.</span><span class="w"></span>
<span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">viewProjection</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span><span class="p">);</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">min16float4</span><span class="p">)</span><span class="n">pos</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">Pass</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="n">through</span><span class="w"> </span><span class="k">without</span><span class="w"> </span><span class="n">modification</span><span class="p">.</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">input</span><span class="p">.</span><span class="n">color</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="k">Set</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">render</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="k">array</span><span class="w"> </span><span class="k">index</span><span class="p">.</span><span class="w"></span>
<span class="k">output</span><span class="p">.</span><span class="n">rtvId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="k">output</span><span class="p">;</span><span class="w"></span>
</pre>
<p>}</p>
<p>ã©ã†é•ã†ã®ã‹
è¦‹æ¯”ã¹ã¦ã¿ãŸã¨ã“ã‚ã€
VPAndRTArrayIndexFromAnyShaderFeedingRasterizer=trueã®å ´åˆ
VertexShaderã§SV_RenderTargetArrayIndexã‚’ä½¿ã†ã“ã¨ãŒå¯èƒ½ã§ã€
ãã†ã§ãªã„å ´åˆã¯VertexShaderã§ä½¿ã†ã“ã¨ãŒã§ããªã„ãŒGeometryShaderã§SV_RenderTargetArrayIndexã‚’ä½¿ã†ã“ã¨ãŒå¯èƒ½ã¨ã„ã†ã“ã¨ã‚‰ã—ã„ã€‚
ãƒ‡ãƒãƒƒã‚¬ã§ç¢ºèªã—ãŸã¨ã“ã‚ã€å®Ÿæ©Ÿãƒ»ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼å…±ã«
backbufferã¯D3D11_TEXTURE2D_DESC.ArraySize=2ã¨ãªã£ã¦ã„ãŸã€‚</p>
<p>https://developer.microsoft.com/en-us/windows/mixed-reality/rendering_in_directx#important_note_about_rendering_on_non-hololens_devices</p>
<p>å®Ÿæ©Ÿã§ã¯VPAndRTArrayIndexFromAnyShaderFeedingRasterizer=trueã€ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§falseã§gometryshaderç‰ˆã«ãªã‚‹ã“ã¨ãŒã‚ã‹ã£ãŸã€‚
SV_RenderTargetArrayIndex</p>
<p>VRã®ãŸã‚ã®ã‚¹ãƒ†ãƒ¬ã‚ªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’é«˜é€ŸåŒ–ã™ã‚‹ã‚¢ã‚¤ãƒ‡ã‚¢</p>
<p>ãªã‚“ã¨ãªãã‚ã‹ã£ã¦ããŸã€‚</p>
<p>ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚·ã‚§ãƒ¼ãƒ€ã‚’ä½¿ç”¨ã—ãŸè¤‡æ•°ç”»é¢æç”»</p>
<p>SV_ViewportArrayIndexã¨ã„ã†ã®ã‚‚ã‚ã‚‹ã‚‰ã—ã„ã€‚
ãªã‚‹ã»ã©ãƒ¼ã€‚</p>
<p>ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ (DirectX HLSL)</p>
<p>ã¾ã¨ã‚
D3D11å°‚ç”¨ã®ãƒ¬ãƒ³ãƒ€ãƒ©ã‚’ä½œã£ã¦ã¿ã‚‹ã€‚
Hololensã¨UWPå…¼ç”¨ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã§ããã†ãªæ°—ãŒã™ã‚‹ã€‚
Hololensã®åˆæœŸåŒ–ã«å¤±æ•—ã—ãŸã‚‰é€šå¸¸ã®UWPã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚Œã°ã‚ˆã„ã®ã§ã¯ãªã„ã‹ã€‚
HoloApp
    Backbuffer
    CameraUpdate
    Input
        |
        v
    +----------+
    |SceneGraph|
    |Renderer  |
    +----------+
        ^
        |
    Input
    CameraUpdate
    Backbuffer
UwpApp</p>
<p>ã“ã‚“ãªæ„Ÿã˜ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¨¡ç´¢ã—ã¦ã¿ã‚ˆã†ã€‚</p>

<hr>
<ul class="pager hidden-print">
<li class="previous">
        <a href="../../../../github/rigidtransformutils/" rel="prev" title="RigidTransformUtils">
            RigidTransformUtils ğŸ‘ˆ
        </a>
    </li>
    <li style="flex-grow: 1">
    <li class="next">
        <a href="../../../../github/thinrenderer/" rel="next" title="ThinRenderer">
            ğŸ‘‰ ThinRenderer
        </a>
    </li>
</ul></main><footer id="footer"><p>
            Powered by
            <a href="https://getnikola.com" rel="nofollow">Nikola</a>
        </p>
    </footer>
</body>
</html>
