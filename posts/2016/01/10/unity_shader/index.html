<!DOCTYPE html><html lang="ja"><head><link rel="icon" type="image/svg+xml" href="/favicon.svg"><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Astro v3.4.3"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://ousttrue.github.io/posts/2016/01/10/unity_shader/"><!-- Primary Meta Tags --><title></title><meta name="title"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://ousttrue.github.io/posts/2016/01/10/unity_shader/"><meta property="og:title"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://ousttrue.github.io/posts/2016/01/10/unity_shader/"><meta property="twitter:title"><style>:root{--accent: #2337ff;--accent-dark: #000d8a;--black: 15, 18, 25;--gray: 96, 115, 159;--gray-light: 229, 233, 240;--gray-dark: 34, 41, 57;--gray-gradient: rgba(var(--gray-light), 50%), #fff;--box-shadow: 0 2px 6px rgba(var(--gray), 25%), 0 8px 24px rgba(var(--gray), 33%), 0 16px 32px rgba(var(--gray), 33%)}@font-face{font-family:Atkinson;src:url(/fonts/atkinson-regular.woff) format("woff");font-weight:400;font-style:normal;font-display:swap}@font-face{font-family:Atkinson;src:url(/fonts/atkinson-bold.woff) format("woff");font-weight:700;font-style:normal;font-display:swap}body{font-family:Atkinson,sans-serif;margin:0;padding:0;text-align:left;background:linear-gradient(var(--gray-gradient)) no-repeat;background-size:100% 600px;word-wrap:break-word;overflow-wrap:break-word;color:rgb(var(--gray-dark));font-size:20px;line-height:1.7}main{width:720px;max-width:calc(100% - 2em);margin:auto;padding:3em 1em}h1,h2,h3,h4,h5,h6{margin:0 0 .5rem;color:rgb(var(--black));line-height:1.2}h1{font-size:2em}h2{font-size:1.8em}h3{font-size:1.6em}h4{font-size:1.4em}h5{font-size:1.2em}strong,b{font-weight:700}a,a:hover{color:var(--accent)}p{margin-bottom:1em}.prose p{margin-bottom:2em}textarea{width:100%;font-size:16px}input{font-size:16px}table{width:100%}img{max-width:100%;height:auto;border-radius:8px}code{padding:2px 5px;background-color:rgb(var(--gray-light));border-radius:2px}pre{padding:1.5em;border-radius:8px}pre>code{all:unset}blockquote{border-left:4px solid var(--accent);padding:0 0 0 20px;margin:0;font-size:1.333em}hr{border:none;border-top:1px solid rgb(var(--gray-light))}@media (max-width: 720px){body{font-size:18px}main{padding:1em}}.sr-only{border:0;padding:0;margin:0;position:absolute!important;height:1px;width:1px;overflow:hidden;clip:rect(1px 1px 1px 1px);clip:rect(1px,1px,1px,1px);clip-path:inset(50%);white-space:nowrap}.date{margin-bottom:.5em;color:rgb(var(--gray))}.tags{display:flex;flex-wrap:wrap}.tag{margin:.25em;border:dotted 1px #a1a1a1;border-radius:.5em;padding:.5em 1em;font-size:1.15em;background-color:#f8fcfd}a[data-astro-cid-eimmu3lg]{display:inline-block;text-decoration:none}a[data-astro-cid-eimmu3lg].active{font-weight:bolder;text-decoration:underline}header[data-astro-cid-3ef6ksr2]{margin:0;padding:0 1em;background:white;box-shadow:0 2px 8px rgba(var(--black),5%)}h2[data-astro-cid-3ef6ksr2]{margin:0;font-size:1em}h2[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2],h2[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2].active{text-decoration:none}nav[data-astro-cid-3ef6ksr2]{display:flex;align-items:center;justify-content:space-between}nav[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]{padding:1em .5em;color:var(--black);border-bottom:4px solid transparent;text-decoration:none}nav[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2].active{text-decoration:none;border-bottom-color:var(--accent)}.social-links[data-astro-cid-3ef6ksr2],.social-links[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]{display:flex}@media (max-width: 720px){.social-links[data-astro-cid-3ef6ksr2]{display:none}}footer[data-astro-cid-sz7xmlte]{padding:2em 1em 6em;background:linear-gradient(var(--gray-gradient)) no-repeat;color:rgb(var(--gray));text-align:center}.social-links[data-astro-cid-sz7xmlte]{display:flex;justify-content:center;gap:1em;margin-top:1em}.social-links[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]{text-decoration:none;color:rgb(var(--gray))}.social-links[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]:hover{color:rgb(var(--gray-dark))}
</style></head><body><header data-astro-cid-3ef6ksr2><nav data-astro-cid-3ef6ksr2><h2 data-astro-cid-3ef6ksr2><a href="/" data-astro-cid-3ef6ksr2>三次元日誌(Astro)</a></h2><div class="internal-links" data-astro-cid-3ef6ksr2><a href="/tags/" data-astro-cid-3ef6ksr2 data-astro-cid-eimmu3lg>Tags</a><a href="/about" data-astro-cid-3ef6ksr2 data-astro-cid-eimmu3lg>About</a></div><div class="social-links" data-astro-cid-3ef6ksr2><a href="https://github.com/ousttrue/" target="_blank" data-astro-cid-3ef6ksr2><span class="sr-only" data-astro-cid-3ef6ksr2>Go to Astro's GitHub repo</span><svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" data-astro-cid-3ef6ksr2><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-3ef6ksr2></path></svg></a></div></nav></header><main><article><div class="prose"><div class="title"><div class="date"><time datetime="2016-01-10T00:00:00.000Z">2016
-01
-10</time></div><a href="/posts/2016/01/10/unity_shader"><h1>UnityのUsePassを追う</h1></a><div class="tags"><p class="tag"><a href="/tags/unity">unity</a></p></div></div></div><p>下記の Unity の半透明シェーダーがいったいどういうメカニズムなのかを調べる。
Shader の元ネタはこちら</p>
<p>Unity で Transparent/Diffuse で描画順が崩れてしまう際の対処法</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" lang="plaintext"><code><span class="line"><span>Shader "Transparent/Diffuse ZWrite" {</span></span>
<span class="line"><span>    Properties{</span></span>
<span class="line"><span>        _Color("Main Color", Color) = (1,1,1,1)</span></span>
<span class="line"><span>        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    SubShader{</span></span>
<span class="line"><span>        Tags{ "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" }</span></span>
<span class="line"><span>        LOD 200</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // extra pass that renders to depth buffer only</span></span>
<span class="line"><span>        Pass{</span></span>
<span class="line"><span>            ZWrite On</span></span>
<span class="line"><span>            ColorMask 0</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // paste in forward rendering passes from Transparent/Diffuse</span></span>
<span class="line"><span>        UsePass "Transparent/Diffuse/FORWARD"</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    Fallback "Transparent/VertexLit"</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>２パス描画になる。</span></span>
<span class="line"><span>パス1: 深度バッファのみの描画</span></span>
<span class="line"><span>Pass{</span></span>
<span class="line"><span>    ZWrite On</span></span>
<span class="line"><span>    ColorMask 0</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>これは、ShaderLab ：旧ライティングというものらしく</span></span>
<span class="line"><span>Fixed function</span></span>
<span class="line"><span>という機能らしい。</span></span>
<span class="line"><span>レガシーとか旧呼ばわりされているけどサンプルコードにしれっと出てくるので知っている必要がある。</span></span>
<span class="line"><span>次のようなコードが生成されていた。</span></span>
<span class="line"><span>ShaderのInspector: Fixed function. Show generated codeの該当部分</span></span>
<span class="line"><span> Pass {</span></span>
<span class="line"><span>  Tags { "QUEUE"="Transparent" "IGNOREPROJECTOR"="true" "RenderType"="Transparent" }</span></span>
<span class="line"><span>  ColorMask 0</span></span>
<span class="line"><span>CGPROGRAM</span></span>
<span class="line"><span>#pragma vertex vert</span></span>
<span class="line"><span>#pragma fragment frag</span></span>
<span class="line"><span>#include "UnityShaderVariables.cginc"</span></span>
<span class="line"><span>#pragma multi_compile_fog</span></span>
<span class="line"><span>#include "UnityCG.cginc"</span></span>
<span class="line"><span>#define USING_FOG (defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// uniforms</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// vertex shader input data</span></span>
<span class="line"><span>struct appdata {</span></span>
<span class="line"><span>  float3 pos : POSITION;</span></span>
<span class="line"><span>  half4 color : COLOR;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// vertex-to-fragment interpolators</span></span>
<span class="line"><span>struct v2f {</span></span>
<span class="line"><span>  fixed4 color : COLOR0;</span></span>
<span class="line"><span>  #if USING_FOG</span></span>
<span class="line"><span>    fixed fog : TEXCOORD0;</span></span>
<span class="line"><span>  #endif</span></span>
<span class="line"><span>  float4 pos : SV_POSITION;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// vertex shader</span></span>
<span class="line"><span>v2f vert (appdata IN) {</span></span>
<span class="line"><span>  v2f o;</span></span>
<span class="line"><span>  half4 color = IN.color;</span></span>
<span class="line"><span>  float3 eyePos = mul (UNITY_MATRIX_MV, float4(IN.pos,1)).xyz;</span></span>
<span class="line"><span>  half3 viewDir = 0.0;</span></span>
<span class="line"><span>  o.color = saturate(color);</span></span>
<span class="line"><span>  // compute texture coordinates</span></span>
<span class="line"><span>  // fog</span></span>
<span class="line"><span>  #if USING_FOG</span></span>
<span class="line"><span>    float fogCoord = length(eyePos.xyz); // radial fog distance</span></span>
<span class="line"><span>    UNITY_CALC_FOG_FACTOR(fogCoord);</span></span>
<span class="line"><span>    o.fog = saturate(unityFogFactor);</span></span>
<span class="line"><span>  #endif</span></span>
<span class="line"><span>  // transform position</span></span>
<span class="line"><span>  o.pos = mul(UNITY_MATRIX_MVP, float4(IN.pos,1));</span></span>
<span class="line"><span>  return o;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// fragment shader</span></span>
<span class="line"><span>fixed4 frag (v2f IN) : SV_Target {</span></span>
<span class="line"><span>  fixed4 col;</span></span>
<span class="line"><span>  col = IN.color;</span></span>
<span class="line"><span>  // fog</span></span>
<span class="line"><span>  #if USING_FOG</span></span>
<span class="line"><span>    col.rgb = lerp (unity_FogColor.rgb, col.rgb, IN.fog);</span></span>
<span class="line"><span>  #endif</span></span>
<span class="line"><span>  return col;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>ENDCG</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>単に頂点カラーをそのまま描画しているようだが、ColorMaskが0なので色は変わらずということらしい。</span></span>
<span class="line"><span>パス2: カラーバッファ</span></span>
<span class="line"><span>Transparent/Diffuse</span></span>
<span class="line"><span>UsePass "Transparent/Diffuse/FORWARD"</span></span>
<span class="line"><span></span></span>
<span class="line"><span>は何なのか。</span></span>
<span class="line"><span>https://unity3d.com/jp/get-unity/download/archive</span></span>
<span class="line"><span>からビルトインシェーダーをDownloadして観察してみる。</span></span>
<span class="line"><span>探してみると”Transparent/Diffuse”という名のシェーダーは無くて、</span></span>
<span class="line"><span>“Legacy Shaders/Transparent/Diffuse”が見つかる。</span></span>
<span class="line"><span>DefaultResourceExtra/Alpha-Diffuse.shader</span></span>
<span class="line"><span>Shader "Legacy Shaders/Transparent/Diffuse" {</span></span>
<span class="line"><span>Properties {</span></span>
<span class="line"><span>    _Color ("Main Color", Color) = (1,1,1,1)</span></span>
<span class="line"><span>    _MainTex ("Base (RGB) Trans (A)", 2D) = "white" {}</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SubShader {</span></span>
<span class="line"><span>    Tags {"Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent"}</span></span>
<span class="line"><span>    LOD 200</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CGPROGRAM</span></span>
<span class="line"><span>#pragma surface surf Lambert alpha:fade</span></span>
<span class="line"><span></span></span>
<span class="line"><span>sampler2D _MainTex;</span></span>
<span class="line"><span>fixed4 _Color;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct Input {</span></span>
<span class="line"><span>    float2 uv_MainTex;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void surf (Input IN, inout SurfaceOutput o) {</span></span>
<span class="line"><span>    fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;</span></span>
<span class="line"><span>    o.Albedo = c.rgb;</span></span>
<span class="line"><span>    o.Alpha = c.a;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>ENDCG</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Fallback "Legacy Shaders/Transparent/VertexLit"</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>surfaceシェーダーらしい。</span></span>
<span class="line"><span>surfaceシェーダーが如何なるPassに展開されるのかがまったくわからないが(LightMode等が関係ある？)</span></span>
<span class="line"><span>FORWARDパスはどこで定義されているのか。</span></span>
<span class="line"><span>Transparent/Diffuse/FORWARD</span></span>
<span class="line"><span>DefaultResourcesExtra/Standard.shader</span></span>
<span class="line"><span>    SubShader</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        Tags { "RenderType"="Opaque" "PerformanceChecks"="False" }</span></span>
<span class="line"><span>        LOD 300</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // ------------------------------------------------------------------</span></span>
<span class="line"><span>        //  Base forward pass (directional light, emission, lightmaps, ...)</span></span>
<span class="line"><span>        Pass</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>            Name "FORWARD"</span></span>
<span class="line"><span>            Tags { "LightMode" = "ForwardBase" }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            Blend [_SrcBlend] [_DstBlend]</span></span>
<span class="line"><span>            ZWrite [_ZWrite]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            CGPROGRAM</span></span>
<span class="line"><span>            #pragma target 3.0</span></span>
<span class="line"><span>            // TEMPORARY: GLES2.0 temporarily disabled to prevent errors spam on devices without textureCubeLodEXT</span></span>
<span class="line"><span>            #pragma exclude_renderers gles</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            // -------------------------------------</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            #pragma shader_feature _NORMALMAP</span></span>
<span class="line"><span>            #pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON</span></span>
<span class="line"><span>            #pragma shader_feature _EMISSION</span></span>
<span class="line"><span>            #pragma shader_feature _METALLICGLOSSMAP</span></span>
<span class="line"><span>            #pragma shader_feature ___ _DETAIL_MULX2</span></span>
<span class="line"><span>            #pragma shader_feature _PARALLAXMAP</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            #pragma multi_compile_fwdbase</span></span>
<span class="line"><span>            #pragma multi_compile_fog</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            #pragma vertex vertBase</span></span>
<span class="line"><span>            #pragma fragment fragBase</span></span>
<span class="line"><span>            #include "UnityStandardCoreForward.cginc"</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            ENDCG</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>vertBaseとfragBaseという関数に辿り着く。</span></span>
<span class="line"><span>vertBaseとfragBase</span></span>
<span class="line"><span>CGIncludes/UnityStandardCoreForward.cginc</span></span>
<span class="line"><span>#ifndef UNITY_STANDARD_CORE_FORWARD_INCLUDED</span></span>
<span class="line"><span>#define UNITY_STANDARD_CORE_FORWARD_INCLUDED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if defined(UNITY_NO_FULL_STANDARD_SHADER)</span></span>
<span class="line"><span>#    define UNITY_STANDARD_SIMPLE 1</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#include "UnityStandardConfig.cginc"</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_STANDARD_SIMPLE</span></span>
<span class="line"><span>    #include "UnityStandardCoreForwardSimple.cginc"</span></span>
<span class="line"><span>    VertexOutputBaseSimple vertBase (VertexInput v) { return vertForwardBaseSimple(v); }</span></span>
<span class="line"><span>    VertexOutputForwardAddSimple vertAdd (VertexInput v) { return vertForwardAddSimple(v); }</span></span>
<span class="line"><span>    half4 fragBase (VertexOutputBaseSimple i) : SV_Target { return fragForwardBaseSimpleInternal(i); }</span></span>
<span class="line"><span>    half4 fragAdd (VertexOutputForwardAddSimple i) : SV_Target { return fragForwardAddSimpleInternal(i); }</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    #include "UnityStandardCore.cginc"</span></span>
<span class="line"><span>    VertexOutputForwardBase vertBase (VertexInput v) { return vertForwardBase(v); }</span></span>
<span class="line"><span>    VertexOutputForwardAdd vertAdd (VertexInput v) { return vertForwardAdd(v); }</span></span>
<span class="line"><span>    half4 fragBase (VertexOutputForwardBase i) : SV_Target { return fragForwardBaseInternal(i); }</span></span>
<span class="line"><span>    half4 fragAdd (VertexOutputForwardAdd i) : SV_Target { return fragForwardAddInternal(i); }</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#endif // UNITY_STANDARD_CORE_FORWARD_INCLUDED</span></span>
<span class="line"><span></span></span>
<span class="line"><span>シンプルとノットシンプルの振り分けをしている。</span></span>
<span class="line"><span>vertBase</span></span>
<span class="line"><span>    VertexOutputForwardBase vertBase (VertexInput v) { return vertForwardBase(v); }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CGInlucdes/UnityStandardCore.cginc</span></span>
<span class="line"><span>VertexOutputForwardBase vertForwardBase (VertexInput v)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    VertexOutputForwardBase o;</span></span>
<span class="line"><span>    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    float4 posWorld = mul(_Object2World, v.vertex);</span></span>
<span class="line"><span>    #if UNITY_SPECCUBE_BOX_PROJECTION</span></span>
<span class="line"><span>        o.posWorld = posWorld.xyz;</span></span>
<span class="line"><span>    #endif</span></span>
<span class="line"><span>    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span></span>
<span class="line"><span>    o.tex = TexCoords(v);</span></span>
<span class="line"><span>    o.eyeVec = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);</span></span>
<span class="line"><span>    float3 normalWorld = UnityObjectToWorldNormal(v.normal);</span></span>
<span class="line"><span>    #ifdef _TANGENT_TO_WORLD</span></span>
<span class="line"><span>        float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);</span></span>
<span class="line"><span>        o.tangentToWorldAndParallax[0].xyz = tangentToWorld[0];</span></span>
<span class="line"><span>        o.tangentToWorldAndParallax[1].xyz = tangentToWorld[1];</span></span>
<span class="line"><span>        o.tangentToWorldAndParallax[2].xyz = tangentToWorld[2];</span></span>
<span class="line"><span>    #else</span></span>
<span class="line"><span>        o.tangentToWorldAndParallax[0].xyz = 0;</span></span>
<span class="line"><span>        o.tangentToWorldAndParallax[1].xyz = 0;</span></span>
<span class="line"><span>        o.tangentToWorldAndParallax[2].xyz = normalWorld;</span></span>
<span class="line"><span>    #endif</span></span>
<span class="line"><span>    //We need this for shadow receving</span></span>
<span class="line"><span>    TRANSFER_SHADOW(o);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    o.ambientOrLightmapUV = VertexGIForward(v, posWorld, normalWorld);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    #ifdef _PARALLAXMAP</span></span>
<span class="line"><span>        TANGENT_SPACE_ROTATION;</span></span>
<span class="line"><span>        half3 viewDirForParallax = mul (rotation, ObjSpaceViewDir(v.vertex));</span></span>
<span class="line"><span>        o.tangentToWorldAndParallax[0].w = viewDirForParallax.x;</span></span>
<span class="line"><span>        o.tangentToWorldAndParallax[1].w = viewDirForParallax.y;</span></span>
<span class="line"><span>        o.tangentToWorldAndParallax[2].w = viewDirForParallax.z;</span></span>
<span class="line"><span>    #endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    #if UNITY_OPTIMIZE_TEXCUBELOD</span></span>
<span class="line"><span>        o.reflUVW         = reflect(o.eyeVec, normalWorld);</span></span>
<span class="line"><span>    #endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    UNITY_TRANSFER_FOG(o,o.pos);</span></span>
<span class="line"><span>    return o;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>普通に頂点シェーダー。たぶん</span></span>
<span class="line"><span>fragBase</span></span>
<span class="line"><span>    half4 fragBase (VertexOutputForwardBase i) : SV_Target { return fragForwardBaseInternal(i); }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CGInlucdes/UnityStandardCore.cginc</span></span>
<span class="line"><span>#define FRAGMENT_SETUP(x) FragmentCommonData x = \</span></span>
<span class="line"><span>    FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct FragmentCommonData</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    half3 diffColor, specColor;</span></span>
<span class="line"><span>    // Note: oneMinusRoughness &#x26; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.</span></span>
<span class="line"><span>    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.</span></span>
<span class="line"><span>    half oneMinusReflectivity, oneMinusRoughness;</span></span>
<span class="line"><span>    half3 normalWorld, eyeVec, posWorld;</span></span>
<span class="line"><span>    half alpha;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</span></span>
<span class="line"><span>    half3 reflUVW;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_STANDARD_SIMPLE</span></span>
<span class="line"><span>    half3 tangentSpaceNormal;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half4 OutputForward (half4 output, half alphaFromSurface)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    #if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON)</span></span>
<span class="line"><span>        output.a = alphaFromSurface;</span></span>
<span class="line"><span>    #else</span></span>
<span class="line"><span>        UNITY_OPAQUE_ALPHA(output.a);</span></span>
<span class="line"><span>    #endif</span></span>
<span class="line"><span>    return output;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half4 fragForwardBaseInternal (VertexOutputForwardBase i)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    FRAGMENT_SETUP(s)</span></span>
<span class="line"><span>#if UNITY_OPTIMIZE_TEXCUBELOD</span></span>
<span class="line"><span>    s.reflUVW        = i.reflUVW;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    UnityLight mainLight = MainLight (s.normalWorld);</span></span>
<span class="line"><span>    half atten = SHADOW_ATTENUATION(i);</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half occlusion = Occlusion(i.tex.xy);</span></span>
<span class="line"><span>    UnityGI gi = FragmentGI (s, occlusion, i.ambientOrLightmapUV, atten, mainLight);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half4 c = UNITY_BRDF_PBS (s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, gi.light, gi.indirect);</span></span>
<span class="line"><span>    c.rgb += UNITY_BRDF_GI (s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, occlusion, gi);</span></span>
<span class="line"><span>    c.rgb += Emission(i.tex.xy);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    UNITY_APPLY_FOG(i.fogCoord, c.rgb);</span></span>
<span class="line"><span>    return OutputForward (c, s.alpha);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>普通にピクセルシェーダーで便利関数がいっぱい定義済みという感じか。</span></span>
<span class="line"><span>しかし、#ifの類がたくさんありどのルートが使われるか不明瞭。</span></span>
<span class="line"><span>includeを展開してみる</span></span>
<span class="line"><span>UsePassの代わりに自前のファイルにシェーダーのコードをコピーしてそっちを使ってみる。</span></span>
<span class="line"><span>DefaultResourcesExtra/Standard.shaderから切り張り</span></span>
<span class="line"><span>        Pass{</span></span>
<span class="line"><span>            Name "FORWARD"</span></span>
<span class="line"><span>            Tags{ "LightMode" = "ForwardBase" }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            ZWrite Off</span></span>
<span class="line"><span>            ColorMask RGB</span></span>
<span class="line"><span>            Blend SrcAlpha OneMinusSrcAlpha</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            CGPROGRAM</span></span>
<span class="line"><span>            #pragma target 2.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            #pragma shader_feature _NORMALMAP</span></span>
<span class="line"><span>            #pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON</span></span>
<span class="line"><span>            #pragma shader_feature _EMISSION</span></span>
<span class="line"><span>            #pragma shader_feature _METALLICGLOSSMAP</span></span>
<span class="line"><span>            #pragma shader_feature ___ _DETAIL_MULX2</span></span>
<span class="line"><span>            // SM2.0: NOT SUPPORTED shader_feature _PARALLAXMAP</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            #pragma skip_variants SHADOWS_SOFT DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            #pragma multi_compile_fwdbase</span></span>
<span class="line"><span>            #pragma multi_compile_fog</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            #pragma vertex vertBase</span></span>
<span class="line"><span>            #pragma fragment fragBase</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            #include "TransparentDiffuseWithZwrite_FORWARD.cginc"</span></span>
<span class="line"><span>            ENDCG</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>UnityStandardCore.cgincから使うところだけ収集。</span></span>
<span class="line"><span>TransparentDiffuseWithZwrite_FORWARD.cginc</span></span>
<span class="line"><span>#include "UnityStandardConfig.cginc"</span></span>
<span class="line"><span>#include "UnityCG.cginc"</span></span>
<span class="line"><span>#include "UnityStandardInput.cginc"</span></span>
<span class="line"><span>#include "AutoLight.cginc"</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct VertexOutputForwardBase</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    float4 pos                            : SV_POSITION;</span></span>
<span class="line"><span>    float4 tex                            : TEXCOORD0;</span></span>
<span class="line"><span>    half3 eyeVec                         : TEXCOORD1;</span></span>
<span class="line"><span>    half4 tangentToWorldAndParallax[3]    : TEXCOORD2;    // [3x3:tangentToWorld | 1x3:viewDirForParallax]</span></span>
<span class="line"><span>    half4 ambientOrLightmapUV            : TEXCOORD5;    // SH or Lightmap UV</span></span>
<span class="line"><span>    SHADOW_COORDS(6)</span></span>
<span class="line"><span>        UNITY_FOG_COORDS(7)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // next ones would not fit into SM2.0 limits, but they are always for SM3.0+</span></span>
<span class="line"><span>#if UNITY_SPECCUBE_BOX_PROJECTION</span></span>
<span class="line"><span>        float3 posWorld                    : TEXCOORD8;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_OPTIMIZE_TEXCUBELOD</span></span>
<span class="line"><span>#if UNITY_SPECCUBE_BOX_PROJECTION</span></span>
<span class="line"><span>    half3 reflUVW                : TEXCOORD9;</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    half3 reflUVW                : TEXCOORD8;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half3 NormalizePerVertexNormal(half3 n)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>#if (SHADER_TARGET &#x3C; 30) || UNITY_STANDARD_SIMPLE</span></span>
<span class="line"><span>    return normalize(n);</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    return n; // will normalize per-pixel instead</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half3 NormalizePerPixelNormal(half3 n)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>#if (SHADER_TARGET &#x3C; 30) || UNITY_STANDARD_SIMPLE</span></span>
<span class="line"><span>    return n;</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    return normalize(n);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>UnityLight MainLight(half3 normalWorld)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    UnityLight l;</span></span>
<span class="line"><span>#ifdef LIGHTMAP_OFF</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    l.color = _LightColor0.rgb;</span></span>
<span class="line"><span>    l.dir = _WorldSpaceLightPos0.xyz;</span></span>
<span class="line"><span>    l.ndotl = LambertTerm(normalWorld, l.dir);</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    // no light specified by the engine</span></span>
<span class="line"><span>    // analytical light might be extracted from Lightmap data later on in the shader depending on the Lightmap type</span></span>
<span class="line"><span>    l.color = half3(0.f, 0.f, 0.f);</span></span>
<span class="line"><span>    l.ndotl = 0.f;</span></span>
<span class="line"><span>    l.dir = half3(0.f, 0.f, 0.f);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return l;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    half4 ambientOrLightmapUV = 0;</span></span>
<span class="line"><span>    // Static lightmaps</span></span>
<span class="line"><span>#ifndef LIGHTMAP_OFF</span></span>
<span class="line"><span>    ambientOrLightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;</span></span>
<span class="line"><span>    ambientOrLightmapUV.zw = 0;</span></span>
<span class="line"><span>    // Sample light probe for Dynamic objects only (no static or dynamic lightmaps)</span></span>
<span class="line"><span>#elif UNITY_SHOULD_SAMPLE_SH</span></span>
<span class="line"><span>#ifdef VERTEXLIGHT_ON</span></span>
<span class="line"><span>    // Approximated illumination from non-important point lights</span></span>
<span class="line"><span>    ambientOrLightmapUV.rgb = Shade4PointLights(</span></span>
<span class="line"><span>            unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,</span></span>
<span class="line"><span>            unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,</span></span>
<span class="line"><span>            unity_4LightAtten0, posWorld, normalWorld);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ambientOrLightmapUV.rgb = ShadeSHPerVertex(normalWorld, ambientOrLightmapUV.rgb);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef DYNAMICLIGHTMAP_ON</span></span>
<span class="line"><span>    ambientOrLightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return ambientOrLightmapUV;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>VertexOutputForwardBase vertForwardBase(VertexInput v)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    VertexOutputForwardBase o;</span></span>
<span class="line"><span>    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    float4 posWorld = mul(_Object2World, v.vertex);</span></span>
<span class="line"><span>#if UNITY_SPECCUBE_BOX_PROJECTION</span></span>
<span class="line"><span>    o.posWorld = posWorld.xyz;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span></span>
<span class="line"><span>    o.tex = TexCoords(v);</span></span>
<span class="line"><span>    o.eyeVec = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);</span></span>
<span class="line"><span>    float3 normalWorld = UnityObjectToWorldNormal(v.normal);</span></span>
<span class="line"><span>#ifdef _TANGENT_TO_WORLD</span></span>
<span class="line"><span>    float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[0].xyz = tangentToWorld[0];</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[1].xyz = tangentToWorld[1];</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[2].xyz = tangentToWorld[2];</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[0].xyz = 0;</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[1].xyz = 0;</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[2].xyz = normalWorld;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>    //We need this for shadow receving</span></span>
<span class="line"><span>    TRANSFER_SHADOW(o);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    o.ambientOrLightmapUV = VertexGIForward(v, posWorld, normalWorld);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef _PARALLAXMAP</span></span>
<span class="line"><span>    TANGENT_SPACE_ROTATION;</span></span>
<span class="line"><span>    half3 viewDirForParallax = mul(rotation, ObjSpaceViewDir(v.vertex));</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[0].w = viewDirForParallax.x;</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[1].w = viewDirForParallax.y;</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[2].w = viewDirForParallax.z;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_OPTIMIZE_TEXCUBELOD</span></span>
<span class="line"><span>    o.reflUVW = reflect(o.eyeVec, normalWorld);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    UNITY_TRANSFER_FOG(o,o.pos);</span></span>
<span class="line"><span>    return o;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>VertexOutputForwardBase vertBase(VertexInput v) { return vertForwardBase(v); }</span></span>
<span class="line"><span>//VertexOutputForwardAdd vertAdd(VertexInput v) { return vertForwardAdd(v); }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef _PARALLAXMAP</span></span>
<span class="line"><span>#define IN_VIEWDIR4PARALLAX(i) NormalizePerPixelNormal(half3(i.tangentToWorldAndParallax[0].w,i.tangentToWorldAndParallax[1].w,i.tangentToWorldAndParallax[2].w))</span></span>
<span class="line"><span>#define IN_VIEWDIR4PARALLAX_FWDADD(i) NormalizePerPixelNormal(i.viewDirForParallax.xyz)</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>#define IN_VIEWDIR4PARALLAX(i) half3(0,0,0)</span></span>
<span class="line"><span>#define IN_VIEWDIR4PARALLAX_FWDADD(i) half3(0,0,0)</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_SPECCUBE_BOX_PROJECTION</span></span>
<span class="line"><span>#define IN_WORLDPOS(i) i.posWorld</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>#define IN_WORLDPOS(i) half3(0,0,0)</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct FragmentCommonData</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    half3 diffColor, specColor;</span></span>
<span class="line"><span>    // Note: oneMinusRoughness &#x26; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.</span></span>
<span class="line"><span>    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.</span></span>
<span class="line"><span>    half oneMinusReflectivity, oneMinusRoughness;</span></span>
<span class="line"><span>    half3 normalWorld, eyeVec, posWorld;</span></span>
<span class="line"><span>    half alpha;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</span></span>
<span class="line"><span>    half3 reflUVW;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_STANDARD_SIMPLE</span></span>
<span class="line"><span>    half3 tangentSpaceNormal;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>inline FragmentCommonData MetallicSetup(float4 i_tex)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    half2 metallicGloss = MetallicGloss(i_tex.xy);</span></span>
<span class="line"><span>    half metallic = metallicGloss.x;</span></span>
<span class="line"><span>    half oneMinusRoughness = metallicGloss.y;        // this is 1 minus the square root of real roughness m.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half oneMinusReflectivity;</span></span>
<span class="line"><span>    half3 specColor;</span></span>
<span class="line"><span>    half3 diffColor = DiffuseAndSpecularFromMetallic(Albedo(i_tex), metallic, /*out*/ specColor, /*out*/ oneMinusReflectivity);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    FragmentCommonData o = (FragmentCommonData)0;</span></span>
<span class="line"><span>    o.diffColor = diffColor;</span></span>
<span class="line"><span>    o.specColor = specColor;</span></span>
<span class="line"><span>    o.oneMinusReflectivity = oneMinusReflectivity;</span></span>
<span class="line"><span>    o.oneMinusRoughness = oneMinusRoughness;</span></span>
<span class="line"><span>    return o;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifndef UNITY_SETUP_BRDF_INPUT</span></span>
<span class="line"><span>#define UNITY_SETUP_BRDF_INPUT SpecularSetup</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>inline FragmentCommonData SpecularSetup(float4 i_tex)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    half4 specGloss = SpecularGloss(i_tex.xy);</span></span>
<span class="line"><span>    half3 specColor = specGloss.rgb;</span></span>
<span class="line"><span>    half oneMinusRoughness = specGloss.a;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half oneMinusReflectivity;</span></span>
<span class="line"><span>    half3 diffColor = EnergyConservationBetweenDiffuseAndSpecular(Albedo(i_tex), specColor, /*out*/ oneMinusReflectivity);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    FragmentCommonData o = (FragmentCommonData)0;</span></span>
<span class="line"><span>    o.diffColor = diffColor;</span></span>
<span class="line"><span>    o.specColor = specColor;</span></span>
<span class="line"><span>    o.oneMinusReflectivity = oneMinusReflectivity;</span></span>
<span class="line"><span>    o.oneMinusRoughness = oneMinusRoughness;</span></span>
<span class="line"><span>    return o;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half3 PerPixelWorldNormal(float4 i_tex, half4 tangentToWorld[3])</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>#ifdef _NORMALMAP</span></span>
<span class="line"><span>    half3 tangent = tangentToWorld[0].xyz;</span></span>
<span class="line"><span>    half3 binormal = tangentToWorld[1].xyz;</span></span>
<span class="line"><span>    half3 normal = tangentToWorld[2].xyz;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_TANGENT_ORTHONORMALIZE</span></span>
<span class="line"><span>    normal = NormalizePerPixelNormal(normal);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ortho-normalize Tangent</span></span>
<span class="line"><span>    tangent = normalize(tangent - normal * dot(tangent, normal));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // recalculate Binormal</span></span>
<span class="line"><span>    half3 newB = cross(normal, tangent);</span></span>
<span class="line"><span>    binormal = newB * sign(dot(newB, binormal));</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half3 normalTangent = NormalInTangentSpace(i_tex);</span></span>
<span class="line"><span>    half3 normalWorld = NormalizePerPixelNormal(tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z); // @TODO: see if we can squeeze this normalize on SM2.0 as well</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    half3 normalWorld = normalize(tangentToWorld[2].xyz);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>    return normalWorld;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#define FRAGMENT_SETUP(x) FragmentCommonData x = \</span></span>
<span class="line"><span>                                                 FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>inline FragmentCommonData FragmentSetup(float4 i_tex, half3 i_eyeVec, half3 i_viewDirForParallax, half4 tangentToWorld[3], half3 i_posWorld)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    i_tex = Parallax(i_tex, i_viewDirForParallax);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half alpha = Alpha(i_tex.xy);</span></span>
<span class="line"><span>#if defined(_ALPHATEST_ON)</span></span>
<span class="line"><span>    clip(alpha - _Cutoff);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    FragmentCommonData o = UNITY_SETUP_BRDF_INPUT(i_tex);</span></span>
<span class="line"><span>    o.normalWorld = PerPixelWorldNormal(i_tex, tangentToWorld);</span></span>
<span class="line"><span>    o.eyeVec = NormalizePerPixelNormal(i_eyeVec);</span></span>
<span class="line"><span>    o.posWorld = i_posWorld;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // NOTE: shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)</span></span>
<span class="line"><span>    o.diffColor = PreMultiplyAlpha(o.diffColor, alpha, o.oneMinusReflectivity, /*out*/ o.alpha);</span></span>
<span class="line"><span>    return o;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light, bool reflections)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    UnityGIInput d;</span></span>
<span class="line"><span>    d.light = light;</span></span>
<span class="line"><span>    d.worldPos = s.posWorld;</span></span>
<span class="line"><span>    d.worldViewDir = -s.eyeVec;</span></span>
<span class="line"><span>    d.atten = atten;</span></span>
<span class="line"><span>#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)</span></span>
<span class="line"><span>    d.ambient = 0;</span></span>
<span class="line"><span>    d.lightmapUV = i_ambientOrLightmapUV;</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    d.ambient = i_ambientOrLightmapUV.rgb;</span></span>
<span class="line"><span>    d.lightmapUV = 0;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>    d.boxMax[0] = unity_SpecCube0_BoxMax;</span></span>
<span class="line"><span>    d.boxMin[0] = unity_SpecCube0_BoxMin;</span></span>
<span class="line"><span>    d.probePosition[0] = unity_SpecCube0_ProbePosition;</span></span>
<span class="line"><span>    d.probeHDR[0] = unity_SpecCube0_HDR;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    d.boxMax[1] = unity_SpecCube1_BoxMax;</span></span>
<span class="line"><span>    d.boxMin[1] = unity_SpecCube1_BoxMin;</span></span>
<span class="line"><span>    d.probePosition[1] = unity_SpecCube1_ProbePosition;</span></span>
<span class="line"><span>    d.probeHDR[1] = unity_SpecCube1_HDR;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (reflections)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        Unity_GlossyEnvironmentData g;</span></span>
<span class="line"><span>        g.roughness = 1 - s.oneMinusRoughness;</span></span>
<span class="line"><span>#if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</span></span>
<span class="line"><span>        g.reflUVW = s.reflUVW;</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>        g.reflUVW = reflect(s.eyeVec, s.normalWorld);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return UnityGlobalIllumination(d, occlusion, s.normalWorld, g);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        return UnityGlobalIllumination(d, occlusion, s.normalWorld);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    return FragmentGI(s, occlusion, i_ambientOrLightmapUV, atten, light, true);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half4 OutputForward(half4 output, half alphaFromSurface)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>#if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON)</span></span>
<span class="line"><span>    output.a = alphaFromSurface;</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    UNITY_OPAQUE_ALPHA(output.a);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>    return output;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half4 fragForwardBaseInternal(VertexOutputForwardBase i)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    FRAGMENT_SETUP(s)</span></span>
<span class="line"><span>#if UNITY_OPTIMIZE_TEXCUBELOD</span></span>
<span class="line"><span>        s.reflUVW = i.reflUVW;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    UnityLight mainLight = MainLight(s.normalWorld);</span></span>
<span class="line"><span>    half atten = SHADOW_ATTENUATION(i);</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half occlusion = Occlusion(i.tex.xy);</span></span>
<span class="line"><span>    UnityGI gi = FragmentGI(s, occlusion, i.ambientOrLightmapUV, atten, mainLight);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half4 c = UNITY_BRDF_PBS(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, gi.light, gi.indirect);</span></span>
<span class="line"><span>    c.rgb += UNITY_BRDF_GI(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, occlusion, gi);</span></span>
<span class="line"><span>    c.rgb += Emission(i.tex.xy);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    UNITY_APPLY_FOG(i.fogCoord, c.rgb);</span></span>
<span class="line"><span>    return OutputForward(c, s.alpha);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half4 fragBase(VertexOutputForwardBase i) : SV_Target{ return fragForwardBaseInternal(i); }</span></span>
<span class="line"><span>//half4 fragAdd(VertexOutputForwardAdd i) : SV_Target{ return fragForwardAddInternal(i); }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ある程度#includeを除いてシンプル化した。しかし、アルファブレンディングがなかなか有効にならずに悩んだ。</span></span>
<span class="line"><span>原因は、</span></span>
<span class="line"><span>#pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON</span></span>
<span class="line"><span></span></span>
<span class="line"><span>で、このShaderキーワードの_ALPHABLEND_ONをEnableにしてやる必要があった。</span></span>
<span class="line"><span>material.EnableKeyword("_ALPHABLEND_ON");</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ビルトインシェーダーでは何故自動で”_ALPHABLEND_ON”になるのか</span></span>
<span class="line"><span>DefaultResourcesExtra/Standard.shaderの末尾</span></span>
<span class="line"><span>    CustomEditor "StandardShaderGUI"</span></span>
<span class="line"><span></span></span>
<span class="line"><span>でカスタムエディタが指定してありこれを経由してマテリアルに介入してたのであった・・・。わかりにくいw</span></span>
<span class="line"><span>shader_featureとmulti_compileを剥がす</span></span>
<span class="line"><span>少しコード整理。</span></span>
<span class="line"><span>shader_featureとmulti_compileを剥がした。</span></span>
<span class="line"><span>ピクセルシェーダーは、GIとか書いてあってわりと複雑なのでその辺には手を触れず。</span></span>
<span class="line"><span>#include "UnityStandardConfig.cginc"</span></span>
<span class="line"><span>#include "UnityCG.cginc"</span></span>
<span class="line"><span>#include "UnityStandardInput.cginc"</span></span>
<span class="line"><span>#include "AutoLight.cginc"</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//////////////////////////////////////////////////////////////////////////////</span></span>
<span class="line"><span>// vertBase</span></span>
<span class="line"><span>//////////////////////////////////////////////////////////////////////////////</span></span>
<span class="line"><span>struct VertexOutputForwardBase</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    float4 pos                            : SV_POSITION;</span></span>
<span class="line"><span>    float4 tex                            : TEXCOORD0;</span></span>
<span class="line"><span>    half3 eyeVec                         : TEXCOORD1;</span></span>
<span class="line"><span>    half4 tangentToWorldAndParallax[3]    : TEXCOORD2;    // [3x3:tangentToWorld | 1x3:viewDirForParallax]</span></span>
<span class="line"><span>    half4 ambientOrLightmapUV            : TEXCOORD5;    // SH or Lightmap UV</span></span>
<span class="line"><span>    SHADOW_COORDS(6)</span></span>
<span class="line"><span>    UNITY_FOG_COORDS(7)</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    half4 ambientOrLightmapUV = 0;</span></span>
<span class="line"><span>    // Static lightmaps</span></span>
<span class="line"><span>#ifndef LIGHTMAP_OFF</span></span>
<span class="line"><span>    ambientOrLightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;</span></span>
<span class="line"><span>    ambientOrLightmapUV.zw = 0;</span></span>
<span class="line"><span>    // Sample light probe for Dynamic objects only (no static or dynamic lightmaps)</span></span>
<span class="line"><span>#elif UNITY_SHOULD_SAMPLE_SH</span></span>
<span class="line"><span>#ifdef VERTEXLIGHT_ON</span></span>
<span class="line"><span>    // Approximated illumination from non-important point lights</span></span>
<span class="line"><span>    ambientOrLightmapUV.rgb = Shade4PointLights(</span></span>
<span class="line"><span>            unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,</span></span>
<span class="line"><span>            unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,</span></span>
<span class="line"><span>            unity_4LightAtten0, posWorld, normalWorld);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ambientOrLightmapUV.rgb = ShadeSHPerVertex(normalWorld, ambientOrLightmapUV.rgb);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef DYNAMICLIGHTMAP_ON</span></span>
<span class="line"><span>    ambientOrLightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return ambientOrLightmapUV;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half3 NormalizePerVertexNormal(half3 n)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    return normalize(n);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>VertexOutputForwardBase vertForwardBase(VertexInput v)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    VertexOutputForwardBase o;</span></span>
<span class="line"><span>    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    float4 posWorld = mul(_Object2World, v.vertex);</span></span>
<span class="line"><span>#if UNITY_SPECCUBE_BOX_PROJECTION</span></span>
<span class="line"><span>    o.posWorld = posWorld.xyz;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span></span>
<span class="line"><span>    o.tex = TexCoords(v);</span></span>
<span class="line"><span>    o.eyeVec = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);</span></span>
<span class="line"><span>    float3 normalWorld = UnityObjectToWorldNormal(v.normal);</span></span>
<span class="line"><span>#ifdef _TANGENT_TO_WORLD</span></span>
<span class="line"><span>    float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[0].xyz = tangentToWorld[0];</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[1].xyz = tangentToWorld[1];</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[2].xyz = tangentToWorld[2];</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[0].xyz = 0;</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[1].xyz = 0;</span></span>
<span class="line"><span>    o.tangentToWorldAndParallax[2].xyz = normalWorld;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>    //We need this for shadow receving</span></span>
<span class="line"><span>    TRANSFER_SHADOW(o);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    o.ambientOrLightmapUV = VertexGIForward(v, posWorld, normalWorld);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_OPTIMIZE_TEXCUBELOD</span></span>
<span class="line"><span>    o.reflUVW = reflect(o.eyeVec, normalWorld);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    UNITY_TRANSFER_FOG(o,o.pos);</span></span>
<span class="line"><span>    return o;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>VertexOutputForwardBase vertBase(VertexInput v) { return vertForwardBase(v); }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//////////////////////////////////////////////////////////////////////////////</span></span>
<span class="line"><span>// fragBase</span></span>
<span class="line"><span>//////////////////////////////////////////////////////////////////////////////</span></span>
<span class="line"><span>#define IN_VIEWDIR4PARALLAX(i) half3(0,0,0)</span></span>
<span class="line"><span>#define IN_VIEWDIR4PARALLAX_FWDADD(i) half3(0,0,0)</span></span>
<span class="line"><span>#define IN_WORLDPOS(i) half3(0,0,0)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct FragmentCommonData</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    half3 diffColor, specColor;</span></span>
<span class="line"><span>    // Note: oneMinusRoughness &#x26; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.</span></span>
<span class="line"><span>    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.</span></span>
<span class="line"><span>    half oneMinusReflectivity, oneMinusRoughness;</span></span>
<span class="line"><span>    half3 normalWorld, eyeVec, posWorld;</span></span>
<span class="line"><span>    half alpha;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</span></span>
<span class="line"><span>    half3 reflUVW;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if UNITY_STANDARD_SIMPLE</span></span>
<span class="line"><span>    half3 tangentSpaceNormal;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifndef UNITY_SETUP_BRDF_INPUT</span></span>
<span class="line"><span>#define UNITY_SETUP_BRDF_INPUT SpecularSetup</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>inline FragmentCommonData SpecularSetup(float4 i_tex)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    half4 specGloss = SpecularGloss(i_tex.xy);</span></span>
<span class="line"><span>    half3 specColor = specGloss.rgb;</span></span>
<span class="line"><span>    half oneMinusRoughness = specGloss.a;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half oneMinusReflectivity;</span></span>
<span class="line"><span>    half3 diffColor = EnergyConservationBetweenDiffuseAndSpecular(Albedo(i_tex), specColor, /*out*/ oneMinusReflectivity);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    FragmentCommonData o = (FragmentCommonData)0;</span></span>
<span class="line"><span>    o.diffColor = diffColor;</span></span>
<span class="line"><span>    o.specColor = specColor;</span></span>
<span class="line"><span>    o.oneMinusReflectivity = oneMinusReflectivity;</span></span>
<span class="line"><span>    o.oneMinusRoughness = oneMinusRoughness;</span></span>
<span class="line"><span>    return o;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half3 PerPixelWorldNormal(float4 i_tex, half4 tangentToWorld[3])</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    half3 normalWorld = normalize(tangentToWorld[2].xyz);</span></span>
<span class="line"><span>    return normalWorld;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#define FRAGMENT_SETUP(x) FragmentCommonData x = \</span></span>
<span class="line"><span>                                                 FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>inline FragmentCommonData FragmentSetup(float4 i_tex, half3 i_eyeVec, half3 i_viewDirForParallax, half4 tangentToWorld[3], half3 i_posWorld)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    i_tex = Parallax(i_tex, i_viewDirForParallax);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half alpha = Alpha(i_tex.xy);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    FragmentCommonData o = UNITY_SETUP_BRDF_INPUT(i_tex);</span></span>
<span class="line"><span>    o.normalWorld = PerPixelWorldNormal(i_tex, tangentToWorld);</span></span>
<span class="line"><span>    o.eyeVec = i_eyeVec;</span></span>
<span class="line"><span>    o.posWorld = i_posWorld;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // NOTE: shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)</span></span>
<span class="line"><span>    o.diffColor = PreMultiplyAlpha(o.diffColor, alpha, o.oneMinusReflectivity, /*out*/ o.alpha);</span></span>
<span class="line"><span>    return o;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light, bool reflections)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    UnityGIInput d;</span></span>
<span class="line"><span>    d.light = light;</span></span>
<span class="line"><span>    d.worldPos = s.posWorld;</span></span>
<span class="line"><span>    d.worldViewDir = -s.eyeVec;</span></span>
<span class="line"><span>    d.atten = atten;</span></span>
<span class="line"><span>#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)</span></span>
<span class="line"><span>    d.ambient = 0;</span></span>
<span class="line"><span>    d.lightmapUV = i_ambientOrLightmapUV;</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    d.ambient = i_ambientOrLightmapUV.rgb;</span></span>
<span class="line"><span>    d.lightmapUV = 0;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>    d.boxMax[0] = unity_SpecCube0_BoxMax;</span></span>
<span class="line"><span>    d.boxMin[0] = unity_SpecCube0_BoxMin;</span></span>
<span class="line"><span>    d.probePosition[0] = unity_SpecCube0_ProbePosition;</span></span>
<span class="line"><span>    d.probeHDR[0] = unity_SpecCube0_HDR;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    d.boxMax[1] = unity_SpecCube1_BoxMax;</span></span>
<span class="line"><span>    d.boxMin[1] = unity_SpecCube1_BoxMin;</span></span>
<span class="line"><span>    d.probePosition[1] = unity_SpecCube1_ProbePosition;</span></span>
<span class="line"><span>    d.probeHDR[1] = unity_SpecCube1_HDR;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (reflections)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        Unity_GlossyEnvironmentData g;</span></span>
<span class="line"><span>        g.roughness = 1 - s.oneMinusRoughness;</span></span>
<span class="line"><span>#if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</span></span>
<span class="line"><span>        g.reflUVW = s.reflUVW;</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>        g.reflUVW = reflect(s.eyeVec, s.normalWorld);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return UnityGlobalIllumination(d, occlusion, s.normalWorld, g);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        return UnityGlobalIllumination(d, occlusion, s.normalWorld);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    return FragmentGI(s, occlusion, i_ambientOrLightmapUV, atten, light, true);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>UnityLight MainLight(half3 normalWorld)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    UnityLight l;</span></span>
<span class="line"><span>#ifdef LIGHTMAP_OFF</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    l.color = _LightColor0.rgb;</span></span>
<span class="line"><span>    l.dir = _WorldSpaceLightPos0.xyz;</span></span>
<span class="line"><span>    l.ndotl = LambertTerm(normalWorld, l.dir);</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>    // no light specified by the engine</span></span>
<span class="line"><span>    // analytical light might be extracted from Lightmap data later on in the shader depending on the Lightmap type</span></span>
<span class="line"><span>    l.color = half3(0.f, 0.f, 0.f);</span></span>
<span class="line"><span>    l.ndotl = 0.f;</span></span>
<span class="line"><span>    l.dir = half3(0.f, 0.f, 0.f);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return l;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half4 fragForwardBaseInternal(VertexOutputForwardBase i)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    FRAGMENT_SETUP(s)</span></span>
<span class="line"><span>#if UNITY_OPTIMIZE_TEXCUBELOD</span></span>
<span class="line"><span>        s.reflUVW = i.reflUVW;</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    UnityLight mainLight = MainLight(s.normalWorld);</span></span>
<span class="line"><span>    half atten = SHADOW_ATTENUATION(i);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half occlusion = Occlusion(i.tex.xy);</span></span>
<span class="line"><span>    UnityGI gi = FragmentGI(s, occlusion, i.ambientOrLightmapUV, atten, mainLight);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    half4 c = UNITY_BRDF_PBS(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, gi.light, gi.indirect);</span></span>
<span class="line"><span>    c.rgb += UNITY_BRDF_GI(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, occlusion, gi);</span></span>
<span class="line"><span>    c.rgb += Emission(i.tex.xy);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    UNITY_APPLY_FOG(i.fogCoord, c.rgb);</span></span>
<span class="line"><span>    c.a = s.alpha;</span></span>
<span class="line"><span>    return c;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>half4 fragBase(VertexOutputForwardBase i) : SV_Target{ return fragForwardBaseInternal(i); }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1パスでいいんじゃないの？</span></span>
<span class="line"><span>UsePassを展開したことによってZWrite Onできるようになったw。Oh…</span></span>
<span class="line"><span>Shader "Transparent/Diffuse ZWrite" {</span></span>
<span class="line"><span>    Properties{</span></span>
<span class="line"><span>        _Color("Main Color", Color) = (1,1,1,1)</span></span>
<span class="line"><span>        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    SubShader{</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Tags{ "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" }</span></span>
<span class="line"><span>        LOD 200</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // paste in forward rendering passes from Transparent/Diffuse</span></span>
<span class="line"><span>        //UsePass "Legacy Shaders/Transparent/Diffuse/FORWARD"</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Pass{</span></span>
<span class="line"><span>            Name "FORWARD"</span></span>
<span class="line"><span>            Tags{ "LightMode" = "ForwardBase" }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            ZWrite On</span></span>
<span class="line"><span>            ColorMask RGB</span></span>
<span class="line"><span>            Blend SrcAlpha OneMinusSrcAlpha</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            CGPROGRAM</span></span>
<span class="line"><span>            #pragma target 2.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            #pragma skip_variants SHADOWS_SOFT DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            // これは要るっぽい</span></span>
<span class="line"><span>            #pragma multi_compile_fwdbase</span></span>
<span class="line"><span>            #pragma multi_compile_fog</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            #pragma vertex vertBase</span></span>
<span class="line"><span>            #pragma fragment fragBase</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            #include "TransparentDiffuseWithZwrite_FORWARD.cginc"</span></span>
<span class="line"><span>            ENDCG</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    } // SubShader</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //Fallback "Transparent/VertexLit"</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>よし、スクラッチでシェーダーを書こうw</span></span>
<span class="line"><span>multi_compile_fwdbase</span></span>
<span class="line"><span>FrameDebuggerで見たところシェーダーのdefineがまとめて変わっていた。LIGHTMAP_OFF等に依存していると影響がある。</span></span>
<span class="line"><span>まとめてmulti_compileを定義しているだけっぽい。</span></span>
<span class="line"><span>まとめ</span></span>
<span class="line"><span></span></span>
<span class="line"><span>surfaceシェーダーでは無い(shaderのinspectorにも書いてあった)</span></span>
<span class="line"><span>UsePassでsurfaceシェーダーのPASSを指定することもできる</span></span>
<span class="line"><span>それ故大変分かりにくい(可読性とコード量とのトレードオフが大きい)</span></span>
<span class="line"><span>surfaceシェーダーも何らかの形でvertexとfragmentを含むPassの集合に展開されている(どう展開されるのか知りたいんだけど)</span></span></code></pre></article></main><footer data-astro-cid-sz7xmlte>
&copy; 2023 ousttrue. All rights reserved.
<div class="social-links" data-astro-cid-sz7xmlte><a href="https://github.com/ousttrue/" target="_blank" data-astro-cid-sz7xmlte><svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/github" data-astro-cid-sz7xmlte><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-sz7xmlte></path></svg></a></div></footer></body></html>