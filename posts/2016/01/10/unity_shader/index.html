<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="generator" content="Nikola (getnikola.com)">
<meta name="viewport" content="width=device-width">
<script src="../../../../../assets/js/all-nocdn.js"></script><title>UnityのUsePassを追う | 三次元日誌</title>
<link href="../../../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
</head>
<body>
    <h1 id="brand">
        <a href="../../../../../" title="三次元日誌" rel="home">
            <span id="blog-title">三次元日誌</span>
        </a>
    </h1>

    <nav id="menu"><ul>
<li><a href="../../../../../archive.html">Archives</a></li>
<li><a href="../../../../../categories/index.html">Tags</a></li>
<li><a href="../../../../../rss.xml">RSS feed</a></li>
<li><a href="../../../../../about">About</a></li>
<li><a href="../../../../../books">MemoBooks</a></li>

            
            
            
        </ul></nav><hr>
<main id="content"><h1 class="p-name entry-title" itemprop="headline name">
    <h1 class="p-name entry-title" itemprop="headline name">
    <a href="." class="u-url">UnityのUsePassを追う
    </a>
</h1>
<ul itemprop="keywords" class="tags">
<li>
        <time datetime="2016-01-10T00:00:00+09:00" title="2016-01-10">2016-01-10</time>
</li>
</ul>
</h1>

<div>
<p>下記のUnityの半透明シェーダーがいったいどういうメカニズムなのかを調べる。
Shaderの元ネタはこちら</p>
<p>Unity で Transparent/Diffuse で描画順が崩れてしまう際の対処法</p>
<p>Shader "Transparent/Diffuse ZWrite" {
    Properties{
        _Color("Main Color", Color) = (1,1,1,1)
        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
    }</p>
<pre class="code literal-block"><span></span>SubShader{
    Tags{ "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" }
    LOD 200

    // extra pass that renders to depth buffer only
    Pass{
        ZWrite On
        ColorMask 0
    }

    // paste in forward rendering passes from Transparent/Diffuse
    UsePass "Transparent/Diffuse/FORWARD"
}

Fallback "Transparent/VertexLit"
</pre>

<p>}</p>
<p>２パス描画になる。
パス1: 深度バッファのみの描画
Pass{
    ZWrite On
    ColorMask 0
}</p>
<p>これは、ShaderLab ：旧ライティングというものらしく
Fixed function
という機能らしい。
レガシーとか旧呼ばわりされているけどサンプルコードにしれっと出てくるので知っている必要がある。
次のようなコードが生成されていた。
ShaderのInspector: Fixed function. Show generated codeの該当部分
 Pass {
  Tags { "QUEUE"="Transparent" "IGNOREPROJECTOR"="true" "RenderType"="Transparent" }
  ColorMask 0
CGPROGRAM</p>
<h2>pragma vertex vert</h2>
<h2>pragma fragment frag</h2>
<h2>include "UnityShaderVariables.cginc"</h2>
<h2>pragma multi_compile_fog</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>define USING_FOG (defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2))</h2>
<p>// uniforms</p>
<p>// vertex shader input data
struct appdata {
  float3 pos : POSITION;
  half4 color : COLOR;
};</p>
<p>// vertex-to-fragment interpolators
struct v2f {
  fixed4 color : COLOR0;
  #if USING_FOG
    fixed fog : TEXCOORD0;
  #endif
  float4 pos : SV_POSITION;
};</p>
<p>// vertex shader
v2f vert (appdata IN) {
  v2f o;
  half4 color = IN.color;
  float3 eyePos = mul (UNITY_MATRIX_MV, float4(IN.pos,1)).xyz;
  half3 viewDir = 0.0;
  o.color = saturate(color);
  // compute texture coordinates
  // fog
  #if USING_FOG
    float fogCoord = length(eyePos.xyz); // radial fog distance
    UNITY_CALC_FOG_FACTOR(fogCoord);
    o.fog = saturate(unityFogFactor);
  #endif
  // transform position
  o.pos = mul(UNITY_MATRIX_MVP, float4(IN.pos,1));
  return o;
}</p>
<p>// fragment shader
fixed4 frag (v2f IN) : SV_Target {
  fixed4 col;
  col = IN.color;
  // fog
  #if USING_FOG
    col.rgb = lerp (unity_FogColor.rgb, col.rgb, IN.fog);
  #endif
  return col;
}
ENDCG
 }</p>
<p>単に頂点カラーをそのまま描画しているようだが、ColorMaskが0なので色は変わらずということらしい。
パス2: カラーバッファ
Transparent/Diffuse
UsePass "Transparent/Diffuse/FORWARD"</p>
<p>は何なのか。
https://unity3d.com/jp/get-unity/download/archive
からビルトインシェーダーをDownloadして観察してみる。
探してみると”Transparent/Diffuse”という名のシェーダーは無くて、
“Legacy Shaders/Transparent/Diffuse”が見つかる。
DefaultResourceExtra/Alpha-Diffuse.shader
Shader "Legacy Shaders/Transparent/Diffuse" {
Properties {
    _Color ("Main Color", Color) = (1,1,1,1)
    _MainTex ("Base (RGB) Trans (A)", 2D) = "white" {}
}</p>
<p>SubShader {
    Tags {"Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent"}
    LOD 200</p>
<p>CGPROGRAM</p>
<h2>pragma surface surf Lambert alpha:fade</h2>
<p>sampler2D _MainTex;
fixed4 _Color;</p>
<p>struct Input {
    float2 uv_MainTex;
};</p>
<p>void surf (Input IN, inout SurfaceOutput o) {
    fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
    o.Albedo = c.rgb;
    o.Alpha = c.a;
}
ENDCG
}</p>
<p>Fallback "Legacy Shaders/Transparent/VertexLit"
}</p>
<p>surfaceシェーダーらしい。
surfaceシェーダーが如何なるPassに展開されるのかがまったくわからないが(LightMode等が関係ある？)
FORWARDパスはどこで定義されているのか。
Transparent/Diffuse/FORWARD
DefaultResourcesExtra/Standard.shader
    SubShader
    {
        Tags { "RenderType"="Opaque" "PerformanceChecks"="False" }
        LOD 300</p>
<pre class="code literal-block"><span></span>    <span class="c1">// ------------------------------------------------------------------</span>
    <span class="c1">//  Base forward pass (directional light, emission, lightmaps, ...)</span>
    <span class="n">Pass</span>
    <span class="p">{</span>
        <span class="n">Name</span> <span class="s">"FORWARD"</span> 
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardBase"</span> <span class="p">}</span>

        <span class="n">Blend</span> <span class="p">[</span><span class="n">_SrcBlend</span><span class="p">]</span> <span class="p">[</span><span class="n">_DstBlend</span><span class="p">]</span>
        <span class="n">ZWrite</span> <span class="p">[</span><span class="n">_ZWrite</span><span class="p">]</span>

        <span class="n">CGPROGRAM</span>
        <span class="cp">#pragma target 3.0</span>
        <span class="c1">// TEMPORARY: GLES2.0 temporarily disabled to prevent errors spam on devices without textureCubeLodEXT</span>
        <span class="cp">#pragma exclude_renderers gles</span>

        <span class="c1">// -------------------------------------</span>

        <span class="cp">#pragma shader_feature _NORMALMAP</span>
        <span class="cp">#pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON</span>
        <span class="cp">#pragma shader_feature _EMISSION</span>
        <span class="cp">#pragma shader_feature _METALLICGLOSSMAP </span>
        <span class="cp">#pragma shader_feature ___ _DETAIL_MULX2</span>
        <span class="cp">#pragma shader_feature _PARALLAXMAP</span>

        <span class="cp">#pragma multi_compile_fwdbase</span>
        <span class="cp">#pragma multi_compile_fog</span>

        <span class="cp">#pragma vertex vertBase</span>
        <span class="cp">#pragma fragment fragBase</span>
        <span class="cp">#include</span> <span class="cpf">"UnityStandardCoreForward.cginc"</span><span class="cp"></span>

        <span class="n">ENDCG</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>

<p>vertBaseとfragBaseという関数に辿り着く。
vertBaseとfragBase
CGIncludes/UnityStandardCoreForward.cginc</p>
<h2>ifndef UNITY_STANDARD_CORE_FORWARD_INCLUDED</h2>
<h2>define UNITY_STANDARD_CORE_FORWARD_INCLUDED</h2>
<h2>if defined(UNITY_NO_FULL_STANDARD_SHADER)</h2>
<h2>define UNITY_STANDARD_SIMPLE 1</h2>
<h2>endif</h2>
<h2>include "UnityStandardConfig.cginc"</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span><span class="cp">#include</span> <span class="cpf">"UnityStandardCoreForwardSimple.cginc"</span><span class="cp"></span>
<span class="n">VertexOutputBaseSimple</span> <span class="nf">vertBase</span> <span class="p">(</span><span class="n">VertexInput</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vertForwardBaseSimple</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span>
<span class="n">VertexOutputForwardAddSimple</span> <span class="nf">vertAdd</span> <span class="p">(</span><span class="n">VertexInput</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vertForwardAddSimple</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span>
<span class="n">half4</span> <span class="nf">fragBase</span> <span class="p">(</span><span class="n">VertexOutputBaseSimple</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fragForwardBaseSimpleInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
<span class="n">half4</span> <span class="nf">fragAdd</span> <span class="p">(</span><span class="n">VertexOutputForwardAddSimple</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fragForwardAddSimpleInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span><span class="cp">#include</span> <span class="cpf">"UnityStandardCore.cginc"</span><span class="cp"></span>
<span class="n">VertexOutputForwardBase</span> <span class="nf">vertBase</span> <span class="p">(</span><span class="n">VertexInput</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vertForwardBase</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span>
<span class="n">VertexOutputForwardAdd</span> <span class="nf">vertAdd</span> <span class="p">(</span><span class="n">VertexInput</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">vertForwardAdd</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span>
<span class="n">half4</span> <span class="nf">fragBase</span> <span class="p">(</span><span class="n">VertexOutputForwardBase</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fragForwardBaseInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
<span class="n">half4</span> <span class="nf">fragAdd</span> <span class="p">(</span><span class="n">VertexOutputForwardAdd</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span> <span class="p">{</span> <span class="k">return</span> <span class="n">fragForwardAddInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">}</span>
</pre>

<h2>endif</h2>
<h2>endif // UNITY_STANDARD_CORE_FORWARD_INCLUDED</h2>
<p>シンプルとノットシンプルの振り分けをしている。
vertBase
    VertexOutputForwardBase vertBase (VertexInput v) { return vertForwardBase(v); }</p>
<p>CGInlucdes/UnityStandardCore.cginc
VertexOutputForwardBase vertForwardBase (VertexInput v)
{
    VertexOutputForwardBase o;
    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</p>
<pre class="code literal-block"><span></span><span class="n">float4</span> <span class="n">posWorld</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">_Object2World</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
<span class="cp">#if UNITY_SPECCUBE_BOX_PROJECTION</span>
    <span class="n">o</span><span class="p">.</span><span class="n">posWorld</span> <span class="o">=</span> <span class="n">posWorld</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
<span class="n">o</span><span class="p">.</span><span class="n">tex</span> <span class="o">=</span> <span class="n">TexCoords</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="n">o</span><span class="p">.</span><span class="n">eyeVec</span> <span class="o">=</span> <span class="n">NormalizePerVertexNormal</span><span class="p">(</span><span class="n">posWorld</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">_WorldSpaceCameraPos</span><span class="p">);</span>
<span class="n">float3</span> <span class="n">normalWorld</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
<span class="cp">#ifdef _TANGENT_TO_WORLD</span>
    <span class="n">float4</span> <span class="n">tangentWorld</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">UnityObjectToWorldDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">),</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>

    <span class="n">float3x3</span> <span class="n">tangentToWorld</span> <span class="o">=</span> <span class="n">CreateTangentToWorldPerVertex</span><span class="p">(</span><span class="n">normalWorld</span><span class="p">,</span> <span class="n">tangentWorld</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">tangentWorld</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">tangentToWorld</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">tangentToWorld</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">tangentToWorld</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="cp">#else</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">normalWorld</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="c1">//We need this for shadow receving</span>
<span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>

<span class="n">o</span><span class="p">.</span><span class="n">ambientOrLightmapUV</span> <span class="o">=</span> <span class="n">VertexGIForward</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">posWorld</span><span class="p">,</span> <span class="n">normalWorld</span><span class="p">);</span>

<span class="cp">#ifdef _PARALLAXMAP</span>
    <span class="n">TANGENT_SPACE_ROTATION</span><span class="p">;</span>
    <span class="n">half3</span> <span class="n">viewDirForParallax</span> <span class="o">=</span> <span class="n">mul</span> <span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">ObjSpaceViewDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">));</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">viewDirForParallax</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">viewDirForParallax</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">viewDirForParallax</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#if UNITY_OPTIMIZE_TEXCUBELOD</span>
    <span class="n">o</span><span class="p">.</span><span class="n">reflUVW</span>         <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">eyeVec</span><span class="p">,</span> <span class="n">normalWorld</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="n">UNITY_TRANSFER_FOG</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">o</span><span class="p">.</span><span class="n">pos</span><span class="p">);</span>
<span class="k">return</span> <span class="n">o</span><span class="p">;</span>
</pre>

<p>}</p>
<p>普通に頂点シェーダー。たぶん
fragBase
    half4 fragBase (VertexOutputForwardBase i) : SV_Target { return fragForwardBaseInternal(i); }</p>
<p>CGInlucdes/UnityStandardCore.cginc
#define FRAGMENT_SETUP(x) FragmentCommonData x = \
    FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</p>
<p>struct FragmentCommonData
{
    half3 diffColor, specColor;
    // Note: oneMinusRoughness &amp; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.
    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.
    half oneMinusReflectivity, oneMinusRoughness;
    half3 normalWorld, eyeVec, posWorld;
    half alpha;</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 reflUVW;
</pre>

<h2>endif</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 tangentSpaceNormal;
</pre>

<h2>endif</h2>
<p>};</p>
<p>half4 OutputForward (half4 output, half alphaFromSurface)
{
    #if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON)
        output.a = alphaFromSurface;
    #else
        UNITY_OPAQUE_ALPHA(output.a);
    #endif
    return output;
}</p>
<p>half4 fragForwardBaseInternal (VertexOutputForwardBase i)
{
    FRAGMENT_SETUP(s)</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<pre class="code literal-block"><span></span>s.reflUVW        = i.reflUVW;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UnityLight mainLight = MainLight (s.normalWorld);
half atten = SHADOW_ATTENUATION(i);


half occlusion = Occlusion(i.tex.xy);
UnityGI gi = FragmentGI (s, occlusion, i.ambientOrLightmapUV, atten, mainLight);

half4 c = UNITY_BRDF_PBS (s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, gi.light, gi.indirect);
c.rgb += UNITY_BRDF_GI (s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, occlusion, gi);
c.rgb += Emission(i.tex.xy);

UNITY_APPLY_FOG(i.fogCoord, c.rgb);
return OutputForward (c, s.alpha);
</pre>

<p>}</p>
<p>普通にピクセルシェーダーで便利関数がいっぱい定義済みという感じか。
しかし、#ifの類がたくさんありどのルートが使われるか不明瞭。
includeを展開してみる
UsePassの代わりに自前のファイルにシェーダーのコードをコピーしてそっちを使ってみる。
DefaultResourcesExtra/Standard.shaderから切り張り
        Pass{
            Name "FORWARD"
            Tags{ "LightMode" = "ForwardBase" }</p>
<pre class="code literal-block"><span></span>        <span class="n">ZWrite</span> <span class="n">Off</span>
        <span class="n">ColorMask</span> <span class="n">RGB</span>
        <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>

        <span class="n">CGPROGRAM</span>
        <span class="cp">#pragma target 2.0</span>

        <span class="cp">#pragma shader_feature _NORMALMAP</span>
        <span class="cp">#pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON</span>
        <span class="cp">#pragma shader_feature _EMISSION </span>
        <span class="cp">#pragma shader_feature _METALLICGLOSSMAP </span>
        <span class="cp">#pragma shader_feature ___ _DETAIL_MULX2</span>
        <span class="c1">// SM2.0: NOT SUPPORTED shader_feature _PARALLAXMAP</span>

        <span class="cp">#pragma skip_variants SHADOWS_SOFT DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE</span>

        <span class="cp">#pragma multi_compile_fwdbase</span>
        <span class="cp">#pragma multi_compile_fog</span>

        <span class="cp">#pragma vertex vertBase</span>
        <span class="cp">#pragma fragment fragBase</span>

        <span class="cp">#include</span> <span class="cpf">"TransparentDiffuseWithZwrite_FORWARD.cginc"</span><span class="cp"></span>
        <span class="n">ENDCG</span>
    <span class="p">}</span>
</pre>

<p>UnityStandardCore.cgincから使うところだけ収集。
TransparentDiffuseWithZwrite_FORWARD.cginc</p>
<h2>include "UnityStandardConfig.cginc"</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>include "UnityStandardInput.cginc"</h2>
<h2>include "AutoLight.cginc"</h2>
<p>struct VertexOutputForwardBase
{
    float4 pos                            : SV_POSITION;
    float4 tex                            : TEXCOORD0;
    half3 eyeVec                         : TEXCOORD1;
    half4 tangentToWorldAndParallax[3]    : TEXCOORD2;    // [3x3:tangentToWorld | 1x3:viewDirForParallax]
    half4 ambientOrLightmapUV            : TEXCOORD5;    // SH or Lightmap UV
    SHADOW_COORDS(6)
        UNITY_FOG_COORDS(7)</p>
<pre class="code literal-block"><span></span>    // next ones would not fit into SM2.0 limits, but they are always for SM3.0+
</pre>

<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<pre class="code literal-block"><span></span>    float3 posWorld                    : TEXCOORD8;
</pre>

<h2>endif</h2>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<pre class="code literal-block"><span></span>half3 reflUVW                : TEXCOORD9;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>half3 reflUVW                : TEXCOORD8;
</pre>

<h2>endif</h2>
<h2>endif</h2>
<p>};</p>
<p>half3 NormalizePerVertexNormal(half3 n)
{</p>
<h2>if (SHADER_TARGET &lt; 30) || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>return normalize(n);
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>return n; // will normalize per-pixel instead
</pre>

<h2>endif</h2>
<p>}</p>
<p>half3 NormalizePerPixelNormal(half3 n)
{</p>
<h2>if (SHADER_TARGET &lt; 30) || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>return n;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>return normalize(n);
</pre>

<h2>endif</h2>
<p>}</p>
<p>UnityLight MainLight(half3 normalWorld)
{
    UnityLight l;</p>
<h2>ifdef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>l.color = _LightColor0.rgb;
l.dir = _WorldSpaceLightPos0.xyz;
l.ndotl = LambertTerm(normalWorld, l.dir);
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>// no light specified by the engine
// analytical light might be extracted from Lightmap data later on in the shader depending on the Lightmap type
l.color = half3(0.f, 0.f, 0.f);
l.ndotl = 0.f;
l.dir = half3(0.f, 0.f, 0.f);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return l;
</pre>

<p>}</p>
<p>inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)
{
    half4 ambientOrLightmapUV = 0;
    // Static lightmaps</p>
<h2>ifndef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
ambientOrLightmapUV.zw = 0;
// Sample light probe for Dynamic objects only (no static or dynamic lightmaps)
</pre>

<h2>elif UNITY_SHOULD_SAMPLE_SH</h2>
<h2>ifdef VERTEXLIGHT_ON</h2>
<pre class="code literal-block"><span></span>// Approximated illumination from non-important point lights
ambientOrLightmapUV.rgb = Shade4PointLights(
        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
        unity_4LightAtten0, posWorld, normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.rgb = ShadeSHPerVertex(normalWorld, ambientOrLightmapUV.rgb);
</pre>

<h2>endif</h2>
<h2>ifdef DYNAMICLIGHTMAP_ON</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return ambientOrLightmapUV;
</pre>

<p>}</p>
<p>VertexOutputForwardBase vertForwardBase(VertexInput v)
{
    VertexOutputForwardBase o;
    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</p>
<pre class="code literal-block"><span></span>float4 posWorld = mul(_Object2World, v.vertex);
</pre>

<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<pre class="code literal-block"><span></span>o.posWorld = posWorld.xyz;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
o.tex = TexCoords(v);
o.eyeVec = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);
float3 normalWorld = UnityObjectToWorldNormal(v.normal);
</pre>

<h2>ifdef _TANGENT_TO_WORLD</h2>
<pre class="code literal-block"><span></span>float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);

float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);
o.tangentToWorldAndParallax[0].xyz = tangentToWorld[0];
o.tangentToWorldAndParallax[1].xyz = tangentToWorld[1];
o.tangentToWorldAndParallax[2].xyz = tangentToWorld[2];
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>o.tangentToWorldAndParallax[0].xyz = 0;
o.tangentToWorldAndParallax[1].xyz = 0;
o.tangentToWorldAndParallax[2].xyz = normalWorld;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>//We need this for shadow receving
TRANSFER_SHADOW(o);

o.ambientOrLightmapUV = VertexGIForward(v, posWorld, normalWorld);
</pre>

<h2>ifdef _PARALLAXMAP</h2>
<pre class="code literal-block"><span></span>TANGENT_SPACE_ROTATION;
half3 viewDirForParallax = mul(rotation, ObjSpaceViewDir(v.vertex));
o.tangentToWorldAndParallax[0].w = viewDirForParallax.x;
o.tangentToWorldAndParallax[1].w = viewDirForParallax.y;
o.tangentToWorldAndParallax[2].w = viewDirForParallax.z;
</pre>

<h2>endif</h2>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<pre class="code literal-block"><span></span>o.reflUVW = reflect(o.eyeVec, normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UNITY_TRANSFER_FOG(o,o.pos);
return o;
</pre>

<p>}</p>
<p>VertexOutputForwardBase vertBase(VertexInput v) { return vertForwardBase(v); }
//VertexOutputForwardAdd vertAdd(VertexInput v) { return vertForwardAdd(v); }</p>
<h2>ifdef _PARALLAXMAP</h2>
<h2>define IN_VIEWDIR4PARALLAX(i) NormalizePerPixelNormal(half3(i.tangentToWorldAndParallax[0].w,i.tangentToWorldAndParallax[1].w,i.tangentToWorldAndParallax[2].w))</h2>
<h2>define IN_VIEWDIR4PARALLAX_FWDADD(i) NormalizePerPixelNormal(i.viewDirForParallax.xyz)</h2>
<h2>else</h2>
<h2>define IN_VIEWDIR4PARALLAX(i) half3(0,0,0)</h2>
<h2>define IN_VIEWDIR4PARALLAX_FWDADD(i) half3(0,0,0)</h2>
<h2>endif</h2>
<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<h2>define IN_WORLDPOS(i) i.posWorld</h2>
<h2>else</h2>
<h2>define IN_WORLDPOS(i) half3(0,0,0)</h2>
<h2>endif</h2>
<p>struct FragmentCommonData
{
    half3 diffColor, specColor;
    // Note: oneMinusRoughness &amp; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.
    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.
    half oneMinusReflectivity, oneMinusRoughness;
    half3 normalWorld, eyeVec, posWorld;
    half alpha;</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 reflUVW;
</pre>

<h2>endif</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 tangentSpaceNormal;
</pre>

<h2>endif</h2>
<p>};</p>
<p>inline FragmentCommonData MetallicSetup(float4 i_tex)
{
    half2 metallicGloss = MetallicGloss(i_tex.xy);
    half metallic = metallicGloss.x;
    half oneMinusRoughness = metallicGloss.y;        // this is 1 minus the square root of real roughness m.</p>
<pre class="code literal-block"><span></span>half oneMinusReflectivity;
half3 specColor;
half3 diffColor = DiffuseAndSpecularFromMetallic(Albedo(i_tex), metallic, /*out*/ specColor, /*out*/ oneMinusReflectivity);

FragmentCommonData o = (FragmentCommonData)0;
o.diffColor = diffColor;
o.specColor = specColor;
o.oneMinusReflectivity = oneMinusReflectivity;
o.oneMinusRoughness = oneMinusRoughness;
return o;
</pre>

<p>}</p>
<h2>ifndef UNITY_SETUP_BRDF_INPUT</h2>
<h2>define UNITY_SETUP_BRDF_INPUT SpecularSetup</h2>
<h2>endif</h2>
<p>inline FragmentCommonData SpecularSetup(float4 i_tex)
{
    half4 specGloss = SpecularGloss(i_tex.xy);
    half3 specColor = specGloss.rgb;
    half oneMinusRoughness = specGloss.a;</p>
<pre class="code literal-block"><span></span>half oneMinusReflectivity;
half3 diffColor = EnergyConservationBetweenDiffuseAndSpecular(Albedo(i_tex), specColor, /*out*/ oneMinusReflectivity);

FragmentCommonData o = (FragmentCommonData)0;
o.diffColor = diffColor;
o.specColor = specColor;
o.oneMinusReflectivity = oneMinusReflectivity;
o.oneMinusRoughness = oneMinusRoughness;
return o;
</pre>

<p>}</p>
<p>half3 PerPixelWorldNormal(float4 i_tex, half4 tangentToWorld[3])
{</p>
<h2>ifdef _NORMALMAP</h2>
<pre class="code literal-block"><span></span>half3 tangent = tangentToWorld[0].xyz;
half3 binormal = tangentToWorld[1].xyz;
half3 normal = tangentToWorld[2].xyz;
</pre>

<h2>if UNITY_TANGENT_ORTHONORMALIZE</h2>
<pre class="code literal-block"><span></span>normal = NormalizePerPixelNormal(normal);

// ortho-normalize Tangent
tangent = normalize(tangent - normal * dot(tangent, normal));

// recalculate Binormal
half3 newB = cross(normal, tangent);
binormal = newB * sign(dot(newB, binormal));
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>half3 normalTangent = NormalInTangentSpace(i_tex);
half3 normalWorld = NormalizePerPixelNormal(tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z); // @TODO: see if we can squeeze this normalize on SM2.0 as well
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>half3 normalWorld = normalize(tangentToWorld[2].xyz);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return normalWorld;
</pre>

<p>}</p>
<p>#define FRAGMENT_SETUP(x) FragmentCommonData x = \
                                                 FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</p>
<p>inline FragmentCommonData FragmentSetup(float4 i_tex, half3 i_eyeVec, half3 i_viewDirForParallax, half4 tangentToWorld[3], half3 i_posWorld)
{
    i_tex = Parallax(i_tex, i_viewDirForParallax);</p>
<pre class="code literal-block"><span></span>half alpha = Alpha(i_tex.xy);
</pre>

<h2>if defined(_ALPHATEST_ON)</h2>
<pre class="code literal-block"><span></span>clip(alpha - _Cutoff);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>FragmentCommonData o = UNITY_SETUP_BRDF_INPUT(i_tex);
o.normalWorld = PerPixelWorldNormal(i_tex, tangentToWorld);
o.eyeVec = NormalizePerPixelNormal(i_eyeVec);
o.posWorld = i_posWorld;

// NOTE: shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)
o.diffColor = PreMultiplyAlpha(o.diffColor, alpha, o.oneMinusReflectivity, /*out*/ o.alpha);
return o;
</pre>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light, bool reflections)
{
    UnityGIInput d;
    d.light = light;
    d.worldPos = s.posWorld;
    d.worldViewDir = -s.eyeVec;
    d.atten = atten;</p>
<h2>if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)</h2>
<pre class="code literal-block"><span></span>d.ambient = 0;
d.lightmapUV = i_ambientOrLightmapUV;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>d.ambient = i_ambientOrLightmapUV.rgb;
d.lightmapUV = 0;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>d.boxMax[0] = unity_SpecCube0_BoxMax;
d.boxMin[0] = unity_SpecCube0_BoxMin;
d.probePosition[0] = unity_SpecCube0_ProbePosition;
d.probeHDR[0] = unity_SpecCube0_HDR;

d.boxMax[1] = unity_SpecCube1_BoxMax;
d.boxMin[1] = unity_SpecCube1_BoxMin;
d.probePosition[1] = unity_SpecCube1_ProbePosition;
d.probeHDR[1] = unity_SpecCube1_HDR;

if (reflections)
{
    Unity_GlossyEnvironmentData g;
    g.roughness = 1 - s.oneMinusRoughness;
</pre>

<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>    g.reflUVW = s.reflUVW;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>    g.reflUVW = reflect(s.eyeVec, s.normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>    return UnityGlobalIllumination(d, occlusion, s.normalWorld, g);
}
else
{
    return UnityGlobalIllumination(d, occlusion, s.normalWorld);
}
</pre>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light)
{
    return FragmentGI(s, occlusion, i_ambientOrLightmapUV, atten, light, true);
}</p>
<p>half4 OutputForward(half4 output, half alphaFromSurface)
{</p>
<h2>if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON)</h2>
<pre class="code literal-block"><span></span>output.a = alphaFromSurface;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>UNITY_OPAQUE_ALPHA(output.a);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return output;
</pre>

<p>}</p>
<p>half4 fragForwardBaseInternal(VertexOutputForwardBase i)
{
    FRAGMENT_SETUP(s)</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<pre class="code literal-block"><span></span>    s.reflUVW = i.reflUVW;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UnityLight mainLight = MainLight(s.normalWorld);
half atten = SHADOW_ATTENUATION(i);


half occlusion = Occlusion(i.tex.xy);
UnityGI gi = FragmentGI(s, occlusion, i.ambientOrLightmapUV, atten, mainLight);

half4 c = UNITY_BRDF_PBS(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, gi.light, gi.indirect);
c.rgb += UNITY_BRDF_GI(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, occlusion, gi);
c.rgb += Emission(i.tex.xy);

UNITY_APPLY_FOG(i.fogCoord, c.rgb);
return OutputForward(c, s.alpha);
</pre>

<p>}</p>
<p>half4 fragBase(VertexOutputForwardBase i) : SV_Target{ return fragForwardBaseInternal(i); }
//half4 fragAdd(VertexOutputForwardAdd i) : SV_Target{ return fragForwardAddInternal(i); }</p>
<p>ある程度#includeを除いてシンプル化した。しかし、アルファブレンディングがなかなか有効にならずに悩んだ。
原因は、</p>
<h2>pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON</h2>
<p>で、このShaderキーワードの_ALPHABLEND_ONをEnableにしてやる必要があった。
material.EnableKeyword("_ALPHABLEND_ON");</p>
<p>ビルトインシェーダーでは何故自動で”_ALPHABLEND_ON”になるのか
DefaultResourcesExtra/Standard.shaderの末尾
    CustomEditor "StandardShaderGUI"</p>
<p>でカスタムエディタが指定してありこれを経由してマテリアルに介入してたのであった・・・。わかりにくいw
shader_featureとmulti_compileを剥がす
少しコード整理。
shader_featureとmulti_compileを剥がした。
ピクセルシェーダーは、GIとか書いてあってわりと複雑なのでその辺には手を触れず。</p>
<h2>include "UnityStandardConfig.cginc"</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>include "UnityStandardInput.cginc"</h2>
<h2>include "AutoLight.cginc"</h2>
<p>//////////////////////////////////////////////////////////////////////////////
// vertBase
//////////////////////////////////////////////////////////////////////////////
struct VertexOutputForwardBase
{
    float4 pos                            : SV_POSITION;
    float4 tex                            : TEXCOORD0;
    half3 eyeVec                         : TEXCOORD1;
    half4 tangentToWorldAndParallax[3]    : TEXCOORD2;    // [3x3:tangentToWorld | 1x3:viewDirForParallax]
    half4 ambientOrLightmapUV            : TEXCOORD5;    // SH or Lightmap UV
    SHADOW_COORDS(6)
    UNITY_FOG_COORDS(7)
};</p>
<p>inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)
{
    half4 ambientOrLightmapUV = 0;
    // Static lightmaps</p>
<h2>ifndef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.xy = v.uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
ambientOrLightmapUV.zw = 0;
// Sample light probe for Dynamic objects only (no static or dynamic lightmaps)
</pre>

<h2>elif UNITY_SHOULD_SAMPLE_SH</h2>
<h2>ifdef VERTEXLIGHT_ON</h2>
<pre class="code literal-block"><span></span>// Approximated illumination from non-important point lights
ambientOrLightmapUV.rgb = Shade4PointLights(
        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
        unity_4LightAtten0, posWorld, normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.rgb = ShadeSHPerVertex(normalWorld, ambientOrLightmapUV.rgb);
</pre>

<h2>endif</h2>
<h2>ifdef DYNAMICLIGHTMAP_ON</h2>
<pre class="code literal-block"><span></span>ambientOrLightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return ambientOrLightmapUV;
</pre>

<p>}</p>
<p>half3 NormalizePerVertexNormal(half3 n)
{
    return normalize(n);
}</p>
<p>VertexOutputForwardBase vertForwardBase(VertexInput v)
{
    VertexOutputForwardBase o;
    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</p>
<pre class="code literal-block"><span></span>float4 posWorld = mul(_Object2World, v.vertex);
</pre>

<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<pre class="code literal-block"><span></span>o.posWorld = posWorld.xyz;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
o.tex = TexCoords(v);
o.eyeVec = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);
float3 normalWorld = UnityObjectToWorldNormal(v.normal);
</pre>

<h2>ifdef _TANGENT_TO_WORLD</h2>
<pre class="code literal-block"><span></span>float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);

float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);
o.tangentToWorldAndParallax[0].xyz = tangentToWorld[0];
o.tangentToWorldAndParallax[1].xyz = tangentToWorld[1];
o.tangentToWorldAndParallax[2].xyz = tangentToWorld[2];
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>o.tangentToWorldAndParallax[0].xyz = 0;
o.tangentToWorldAndParallax[1].xyz = 0;
o.tangentToWorldAndParallax[2].xyz = normalWorld;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>//We need this for shadow receving
TRANSFER_SHADOW(o);

o.ambientOrLightmapUV = VertexGIForward(v, posWorld, normalWorld);
</pre>

<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<pre class="code literal-block"><span></span>o.reflUVW = reflect(o.eyeVec, normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UNITY_TRANSFER_FOG(o,o.pos);
return o;
</pre>

<p>}</p>
<p>VertexOutputForwardBase vertBase(VertexInput v) { return vertForwardBase(v); }</p>
<p>//////////////////////////////////////////////////////////////////////////////
// fragBase
//////////////////////////////////////////////////////////////////////////////</p>
<h2>define IN_VIEWDIR4PARALLAX(i) half3(0,0,0)</h2>
<h2>define IN_VIEWDIR4PARALLAX_FWDADD(i) half3(0,0,0)</h2>
<h2>define IN_WORLDPOS(i) half3(0,0,0)</h2>
<p>struct FragmentCommonData
{
    half3 diffColor, specColor;
    // Note: oneMinusRoughness &amp; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.
    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.
    half oneMinusReflectivity, oneMinusRoughness;
    half3 normalWorld, eyeVec, posWorld;
    half alpha;</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 reflUVW;
</pre>

<h2>endif</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>half3 tangentSpaceNormal;
</pre>

<h2>endif</h2>
<p>};</p>
<h2>ifndef UNITY_SETUP_BRDF_INPUT</h2>
<h2>define UNITY_SETUP_BRDF_INPUT SpecularSetup</h2>
<h2>endif</h2>
<p>inline FragmentCommonData SpecularSetup(float4 i_tex)
{
    half4 specGloss = SpecularGloss(i_tex.xy);
    half3 specColor = specGloss.rgb;
    half oneMinusRoughness = specGloss.a;</p>
<pre class="code literal-block"><span></span>half oneMinusReflectivity;
half3 diffColor = EnergyConservationBetweenDiffuseAndSpecular(Albedo(i_tex), specColor, /*out*/ oneMinusReflectivity);

FragmentCommonData o = (FragmentCommonData)0;
o.diffColor = diffColor;
o.specColor = specColor;
o.oneMinusReflectivity = oneMinusReflectivity;
o.oneMinusRoughness = oneMinusRoughness;
return o;
</pre>

<p>}</p>
<p>half3 PerPixelWorldNormal(float4 i_tex, half4 tangentToWorld[3])
{
    half3 normalWorld = normalize(tangentToWorld[2].xyz);
    return normalWorld;
}</p>
<p>#define FRAGMENT_SETUP(x) FragmentCommonData x = \
                                                 FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</p>
<p>inline FragmentCommonData FragmentSetup(float4 i_tex, half3 i_eyeVec, half3 i_viewDirForParallax, half4 tangentToWorld[3], half3 i_posWorld)
{
    i_tex = Parallax(i_tex, i_viewDirForParallax);</p>
<pre class="code literal-block"><span></span>half alpha = Alpha(i_tex.xy);

FragmentCommonData o = UNITY_SETUP_BRDF_INPUT(i_tex);
o.normalWorld = PerPixelWorldNormal(i_tex, tangentToWorld);
o.eyeVec = i_eyeVec;
o.posWorld = i_posWorld;

// NOTE: shader relies on pre-multiply alpha-blend (_SrcBlend = One, _DstBlend = OneMinusSrcAlpha)
o.diffColor = PreMultiplyAlpha(o.diffColor, alpha, o.oneMinusReflectivity, /*out*/ o.alpha);
return o;
</pre>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light, bool reflections)
{
    UnityGIInput d;
    d.light = light;
    d.worldPos = s.posWorld;
    d.worldViewDir = -s.eyeVec;
    d.atten = atten;</p>
<h2>if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)</h2>
<pre class="code literal-block"><span></span>d.ambient = 0;
d.lightmapUV = i_ambientOrLightmapUV;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>d.ambient = i_ambientOrLightmapUV.rgb;
d.lightmapUV = 0;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>d.boxMax[0] = unity_SpecCube0_BoxMax;
d.boxMin[0] = unity_SpecCube0_BoxMin;
d.probePosition[0] = unity_SpecCube0_ProbePosition;
d.probeHDR[0] = unity_SpecCube0_HDR;

d.boxMax[1] = unity_SpecCube1_BoxMax;
d.boxMin[1] = unity_SpecCube1_BoxMin;
d.probePosition[1] = unity_SpecCube1_ProbePosition;
d.probeHDR[1] = unity_SpecCube1_HDR;

if (reflections)
{
    Unity_GlossyEnvironmentData g;
    g.roughness = 1 - s.oneMinusRoughness;
</pre>

<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<pre class="code literal-block"><span></span>    g.reflUVW = s.reflUVW;
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>    g.reflUVW = reflect(s.eyeVec, s.normalWorld);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>    return UnityGlobalIllumination(d, occlusion, s.normalWorld, g);
}
else
{
    return UnityGlobalIllumination(d, occlusion, s.normalWorld);
}
</pre>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light)
{
    return FragmentGI(s, occlusion, i_ambientOrLightmapUV, atten, light, true);
}</p>
<p>UnityLight MainLight(half3 normalWorld)
{
    UnityLight l;</p>
<h2>ifdef LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span></span>l.color = _LightColor0.rgb;
l.dir = _WorldSpaceLightPos0.xyz;
l.ndotl = LambertTerm(normalWorld, l.dir);
</pre>

<h2>else</h2>
<pre class="code literal-block"><span></span>// no light specified by the engine
// analytical light might be extracted from Lightmap data later on in the shader depending on the Lightmap type
l.color = half3(0.f, 0.f, 0.f);
l.ndotl = 0.f;
l.dir = half3(0.f, 0.f, 0.f);
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>return l;
</pre>

<p>}</p>
<p>half4 fragForwardBaseInternal(VertexOutputForwardBase i)
{
    FRAGMENT_SETUP(s)</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<pre class="code literal-block"><span></span>    s.reflUVW = i.reflUVW;
</pre>

<h2>endif</h2>
<pre class="code literal-block"><span></span>UnityLight mainLight = MainLight(s.normalWorld);
half atten = SHADOW_ATTENUATION(i);

half occlusion = Occlusion(i.tex.xy);
UnityGI gi = FragmentGI(s, occlusion, i.ambientOrLightmapUV, atten, mainLight);

half4 c = UNITY_BRDF_PBS(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, gi.light, gi.indirect);
c.rgb += UNITY_BRDF_GI(s.diffColor, s.specColor, s.oneMinusReflectivity, s.oneMinusRoughness, s.normalWorld, -s.eyeVec, occlusion, gi);
c.rgb += Emission(i.tex.xy);

UNITY_APPLY_FOG(i.fogCoord, c.rgb);
c.a = s.alpha;
return c;
</pre>

<p>}</p>
<p>half4 fragBase(VertexOutputForwardBase i) : SV_Target{ return fragForwardBaseInternal(i); }</p>
<p>1パスでいいんじゃないの？
UsePassを展開したことによってZWrite Onできるようになったw。Oh…
Shader "Transparent/Diffuse ZWrite" {
    Properties{
        _Color("Main Color", Color) = (1,1,1,1)
        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
    }</p>
<pre class="code literal-block"><span></span><span class="n">SubShader</span><span class="p">{</span>

    <span class="n">Tags</span><span class="p">{</span> <span class="s">"Queue"</span> <span class="o">=</span> <span class="s">"Transparent"</span> <span class="s">"IgnoreProjector"</span> <span class="o">=</span> <span class="s">"True"</span> <span class="s">"RenderType"</span> <span class="o">=</span> <span class="s">"Transparent"</span> <span class="p">}</span>
    <span class="n">LOD</span> <span class="mi">200</span>

    <span class="c1">// paste in forward rendering passes from Transparent/Diffuse</span>
    <span class="c1">//UsePass "Legacy Shaders/Transparent/Diffuse/FORWARD"</span>

    <span class="n">Pass</span><span class="p">{</span>
        <span class="n">Name</span> <span class="s">"FORWARD"</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardBase"</span> <span class="p">}</span>

        <span class="n">ZWrite</span> <span class="n">On</span>
        <span class="n">ColorMask</span> <span class="n">RGB</span>
        <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>

        <span class="n">CGPROGRAM</span>
        <span class="cp">#pragma target 2.0</span>

        <span class="cp">#pragma skip_variants SHADOWS_SOFT DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE</span>

        <span class="c1">// これは要るっぽい</span>
        <span class="cp">#pragma multi_compile_fwdbase</span>
        <span class="cp">#pragma multi_compile_fog</span>

        <span class="cp">#pragma vertex vertBase</span>
        <span class="cp">#pragma fragment fragBase</span>

        <span class="cp">#include</span> <span class="cpf">"TransparentDiffuseWithZwrite_FORWARD.cginc"</span><span class="cp"></span>
        <span class="n">ENDCG</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// SubShader</span>

<span class="c1">//Fallback "Transparent/VertexLit"</span>
</pre>

<p>}</p>
<p>よし、スクラッチでシェーダーを書こうw
multi_compile_fwdbase
FrameDebuggerで見たところシェーダーのdefineがまとめて変わっていた。LIGHTMAP_OFF等に依存していると影響がある。
まとめてmulti_compileを定義しているだけっぽい。
まとめ</p>
<p>surfaceシェーダーでは無い(shaderのinspectorにも書いてあった)
UsePassでsurfaceシェーダーのPASSを指定することもできる
それ故大変分かりにくい(可読性とコード量とのトレードオフが大きい)
surfaceシェーダーも何らかの形でvertexとfragmentを含むPassの集合に展開されている(どう展開されるのか知りたいんだけど)</p>
</div>

<ul class="pager hidden-print">
<li class="previous">
        <a href="../../../../2015/12/30/unity_webgl/" rel="prev" title="Unity5.3でWebGL">
            Unity5.3でWebGL 👈
        </a>
    </li>
    <li style="flex-grow: 1">
    <li class="next">
        <a href="../../11/unity_write_shader/" rel="next" title="UnityのShaderを書いてみる">
            👉 UnityのShaderを書いてみる
        </a>
    </li>
</ul></main><footer id="footer"><p>
            Powered by
            <a href="https://getnikola.com" rel="nofollow">Nikola</a>
        </p>
    </footer>
</body>
</html>
