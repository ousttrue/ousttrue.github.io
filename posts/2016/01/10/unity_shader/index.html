<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="generator" content="Nikola (getnikola.com)">
<meta name="viewport" content="width=device-width">
<script src="../../../../../assets/js/all-nocdn.js"></script><title>UnityのUsePassを追う | 三次元日誌</title>
<link href="../../../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
</head>
<body>
    <h1 id="brand">
        <a href="../../../../../" title="三次元日誌" rel="home">
            <span id="blog-title">三次元日誌</span>
        </a>
    </h1>

    <nav id="menu"><ul>
<li><a href="../../../../../archive.html">Archives</a></li>
<li><a href="../../../../../categories/index.html">Tags</a></li>
<li><a href="../../../../../rss.xml">RSS feed</a></li>
<li><a href="../../../../../about">About</a></li>
<li><a href="../../../../../books">MemoBooks</a></li>

            
            
            
        </ul></nav><hr>
<main id="content"><h1 class="p-name entry-title" itemprop="headline name">
    <h1 class="p-name entry-title" itemprop="headline name">
    <a href="." class="u-url">UnityのUsePassを追う
    </a>
</h1>
<ul itemprop="keywords" class="tags">
<li>
        <time datetime="2016-01-10T00:00:00+09:00" title="2016-01-10">2016-01-10</time>
</li>
    <li><a class="tag p-category" href="../../../../../categories/unity/" rel="tag">unity</a></li>
</ul>
</h1>

<p>下記のUnityの半透明シェーダーがいったいどういうメカニズムなのかを調べる。
Shaderの元ネタはこちら</p>
<p>Unity で Transparent/Diffuse で描画順が崩れてしまう際の対処法</p>
<p>Shader "Transparent/Diffuse ZWrite" {
    Properties{
        _Color("Main Color", Color) = (1,1,1,1)
        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
    }</p>
<div class="code"><pre class="code literal-block">SubShader{
    Tags{ "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" }
    LOD 200

    // extra pass that renders to depth buffer only
    Pass{
        ZWrite On
        ColorMask 0
    }

    // paste in forward rendering passes from Transparent/Diffuse
    UsePass "Transparent/Diffuse/FORWARD"
}

Fallback "Transparent/VertexLit"
</pre></div>

<p>}</p>
<p>２パス描画になる。
パス1: 深度バッファのみの描画
Pass{
    ZWrite On
    ColorMask 0
}</p>
<p>これは、ShaderLab ：旧ライティングというものらしく
Fixed function
という機能らしい。
レガシーとか旧呼ばわりされているけどサンプルコードにしれっと出てくるので知っている必要がある。
次のようなコードが生成されていた。
ShaderのInspector: Fixed function. Show generated codeの該当部分
 Pass {
  Tags { "QUEUE"="Transparent" "IGNOREPROJECTOR"="true" "RenderType"="Transparent" }
  ColorMask 0
CGPROGRAM</p>
<h2>pragma vertex vert</h2>
<h2>pragma fragment frag</h2>
<h2>include "UnityShaderVariables.cginc"</h2>
<h2>pragma multi_compile_fog</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>define USING_FOG (defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2))</h2>
<p>// uniforms</p>
<p>// vertex shader input data
struct appdata {
  float3 pos : POSITION;
  half4 color : COLOR;
};</p>
<p>// vertex-to-fragment interpolators
struct v2f {
  fixed4 color : COLOR0;
  #if USING_FOG
    fixed fog : TEXCOORD0;
  #endif
  float4 pos : SV_POSITION;
};</p>
<p>// vertex shader
v2f vert (appdata IN) {
  v2f o;
  half4 color = IN.color;
  float3 eyePos = mul (UNITY_MATRIX_MV, float4(IN.pos,1)).xyz;
  half3 viewDir = 0.0;
  o.color = saturate(color);
  // compute texture coordinates
  // fog
  #if USING_FOG
    float fogCoord = length(eyePos.xyz); // radial fog distance
    UNITY_CALC_FOG_FACTOR(fogCoord);
    o.fog = saturate(unityFogFactor);
  #endif
  // transform position
  o.pos = mul(UNITY_MATRIX_MVP, float4(IN.pos,1));
  return o;
}</p>
<p>// fragment shader
fixed4 frag (v2f IN) : SV_Target {
  fixed4 col;
  col = IN.color;
  // fog
  #if USING_FOG
    col.rgb = lerp (unity_FogColor.rgb, col.rgb, IN.fog);
  #endif
  return col;
}
ENDCG
 }</p>
<p>単に頂点カラーをそのまま描画しているようだが、ColorMaskが0なので色は変わらずということらしい。
パス2: カラーバッファ
Transparent/Diffuse
UsePass "Transparent/Diffuse/FORWARD"</p>
<p>は何なのか。
https://unity3d.com/jp/get-unity/download/archive
からビルトインシェーダーをDownloadして観察してみる。
探してみると”Transparent/Diffuse”という名のシェーダーは無くて、
“Legacy Shaders/Transparent/Diffuse”が見つかる。
DefaultResourceExtra/Alpha-Diffuse.shader
Shader "Legacy Shaders/Transparent/Diffuse" {
Properties {
    _Color ("Main Color", Color) = (1,1,1,1)
    _MainTex ("Base (RGB) Trans (A)", 2D) = "white" {}
}</p>
<p>SubShader {
    Tags {"Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent"}
    LOD 200</p>
<p>CGPROGRAM</p>
<h2>pragma surface surf Lambert alpha:fade</h2>
<p>sampler2D _MainTex;
fixed4 _Color;</p>
<p>struct Input {
    float2 uv_MainTex;
};</p>
<p>void surf (Input IN, inout SurfaceOutput o) {
    fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
    o.Albedo = c.rgb;
    o.Alpha = c.a;
}
ENDCG
}</p>
<p>Fallback "Legacy Shaders/Transparent/VertexLit"
}</p>
<p>surfaceシェーダーらしい。
surfaceシェーダーが如何なるPassに展開されるのかがまったくわからないが(LightMode等が関係ある？)
FORWARDパスはどこで定義されているのか。
Transparent/Diffuse/FORWARD
DefaultResourcesExtra/Standard.shader
    SubShader
    {
        Tags { "RenderType"="Opaque" "PerformanceChecks"="False" }
        LOD 300</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="o">------------------------------------------------------------------</span><span class="w"></span>
<span class="w">    </span><span class="o">//</span><span class="w">  </span><span class="n">Base</span><span class="w"> </span><span class="n">forward</span><span class="w"> </span><span class="n">pass</span><span class="w"> </span><span class="p">(</span><span class="n">directional</span><span class="w"> </span><span class="n">light</span><span class="p">,</span><span class="w"> </span><span class="n">emission</span><span class="p">,</span><span class="w"> </span><span class="n">lightmaps</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="w">    </span><span class="n">Pass</span><span class="w"></span>
<span class="w">    </span><span class="err">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Name</span><span class="w"> </span><span class="ss">"FORWARD"</span><span class="w"> </span>
<span class="w">        </span><span class="n">Tags</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="ss">"LightMode"</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">"ForwardBase"</span><span class="w"> </span><span class="err">}</span><span class="w"></span>

<span class="w">        </span><span class="n">Blend</span><span class="w"> </span><span class="o">[</span><span class="n">_SrcBlend</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">_DstBlend</span><span class="o">]</span><span class="w"></span>
<span class="w">        </span><span class="n">ZWrite</span><span class="w"> </span><span class="o">[</span><span class="n">_ZWrite</span><span class="o">]</span><span class="w"></span>

<span class="w">        </span><span class="n">CGPROGRAM</span><span class="w"></span>
<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="mf">3.0</span><span class="w"></span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="k">TEMPORARY</span><span class="err">:</span><span class="w"> </span><span class="n">GLES2</span><span class="mf">.0</span><span class="w"> </span><span class="n">temporarily</span><span class="w"> </span><span class="n">disabled</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">prevent</span><span class="w"> </span><span class="n">errors</span><span class="w"> </span><span class="n">spam</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">devices</span><span class="w"> </span><span class="k">without</span><span class="w"> </span><span class="n">textureCubeLodEXT</span><span class="w"></span>
<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">exclude_renderers</span><span class="w"> </span><span class="n">gles</span><span class="w"></span>

<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="o">-------------------------------------</span><span class="w"></span>

<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">shader_feature</span><span class="w"> </span><span class="n">_NORMALMAP</span><span class="w"></span>
<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">shader_feature</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_ALPHATEST_ON</span><span class="w"> </span><span class="n">_ALPHABLEND_ON</span><span class="w"> </span><span class="n">_ALPHAPREMULTIPLY_ON</span><span class="w"></span>
<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">shader_feature</span><span class="w"> </span><span class="n">_EMISSION</span><span class="w"></span>
<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">shader_feature</span><span class="w"> </span><span class="n">_METALLICGLOSSMAP</span><span class="w"> </span>
<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">shader_feature</span><span class="w"> </span><span class="n">___</span><span class="w"> </span><span class="n">_DETAIL_MULX2</span><span class="w"></span>
<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">shader_feature</span><span class="w"> </span><span class="n">_PARALLAXMAP</span><span class="w"></span>

<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">multi_compile_fwdbase</span><span class="w"></span>
<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">multi_compile_fog</span><span class="w"></span>

<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="n">vertBase</span><span class="w"></span>
<span class="w">        </span><span class="n">#pragma</span><span class="w"> </span><span class="n">fragment</span><span class="w"> </span><span class="n">fragBase</span><span class="w"></span>
<span class="w">        </span><span class="n">#include</span><span class="w"> </span><span class="ss">"UnityStandardCoreForward.cginc"</span><span class="w"></span>

<span class="w">        </span><span class="n">ENDCG</span><span class="w"></span>
<span class="w">    </span><span class="err">}</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</pre></div>

<p>vertBaseとfragBaseという関数に辿り着く。
vertBaseとfragBase
CGIncludes/UnityStandardCoreForward.cginc</p>
<h2>ifndef UNITY_STANDARD_CORE_FORWARD_INCLUDED</h2>
<h2>define UNITY_STANDARD_CORE_FORWARD_INCLUDED</h2>
<h2>if defined(UNITY_NO_FULL_STANDARD_SHADER)</h2>
<h2>define UNITY_STANDARD_SIMPLE 1</h2>
<h2>endif</h2>
<h2>include "UnityStandardConfig.cginc"</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">"UnityStandardCoreForwardSimple.cginc"</span><span class="cp"></span>
<span class="n">VertexOutputBaseSimple</span><span class="w"> </span><span class="nf">vertBase</span><span class="w"> </span><span class="p">(</span><span class="n">VertexInput</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">vertForwardBaseSimple</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">VertexOutputForwardAddSimple</span><span class="w"> </span><span class="nf">vertAdd</span><span class="w"> </span><span class="p">(</span><span class="n">VertexInput</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">vertForwardAddSimple</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">half4</span><span class="w"> </span><span class="nf">fragBase</span><span class="w"> </span><span class="p">(</span><span class="n">VertexOutputBaseSimple</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SV_Target</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">fragForwardBaseSimpleInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">half4</span><span class="w"> </span><span class="nf">fragAdd</span><span class="w"> </span><span class="p">(</span><span class="n">VertexOutputForwardAddSimple</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SV_Target</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">fragForwardAddSimpleInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">"UnityStandardCore.cginc"</span><span class="cp"></span>
<span class="n">VertexOutputForwardBase</span><span class="w"> </span><span class="nf">vertBase</span><span class="w"> </span><span class="p">(</span><span class="n">VertexInput</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">vertForwardBase</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">VertexOutputForwardAdd</span><span class="w"> </span><span class="nf">vertAdd</span><span class="w"> </span><span class="p">(</span><span class="n">VertexInput</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">vertForwardAdd</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">half4</span><span class="w"> </span><span class="nf">fragBase</span><span class="w"> </span><span class="p">(</span><span class="n">VertexOutputForwardBase</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SV_Target</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">fragForwardBaseInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">half4</span><span class="w"> </span><span class="nf">fragAdd</span><span class="w"> </span><span class="p">(</span><span class="n">VertexOutputForwardAdd</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SV_Target</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">fragForwardAddInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>

<h2>endif</h2>
<h2>endif // UNITY_STANDARD_CORE_FORWARD_INCLUDED</h2>
<p>シンプルとノットシンプルの振り分けをしている。
vertBase
    VertexOutputForwardBase vertBase (VertexInput v) { return vertForwardBase(v); }</p>
<p>CGInlucdes/UnityStandardCore.cginc
VertexOutputForwardBase vertForwardBase (VertexInput v)
{
    VertexOutputForwardBase o;
    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</p>
<div class="code"><pre class="code literal-block"><span class="n">float4</span><span class="w"> </span><span class="n">posWorld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">_Object2World</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if UNITY_SPECCUBE_BOX_PROJECTION</span>
<span class="w">    </span><span class="n">o</span><span class="p">.</span><span class="n">posWorld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">posWorld</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="n">o</span><span class="p">.</span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span><span class="w"></span>
<span class="n">o</span><span class="p">.</span><span class="n">tex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TexCoords</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="n">o</span><span class="p">.</span><span class="n">eyeVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NormalizePerVertexNormal</span><span class="p">(</span><span class="n">posWorld</span><span class="p">.</span><span class="n">xyz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">_WorldSpaceCameraPos</span><span class="p">);</span><span class="w"></span>
<span class="n">float3</span><span class="w"> </span><span class="n">normalWorld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span><span class="w"></span>
<span class="cp">#ifdef _TANGENT_TO_WORLD</span>
<span class="w">    </span><span class="n">float4</span><span class="w"> </span><span class="n">tangentWorld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float4</span><span class="p">(</span><span class="n">UnityObjectToWorldDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">float3x3</span><span class="w"> </span><span class="n">tangentToWorld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateTangentToWorldPerVertex</span><span class="p">(</span><span class="n">normalWorld</span><span class="p">,</span><span class="w"> </span><span class="n">tangentWorld</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span><span class="w"> </span><span class="n">tangentWorld</span><span class="p">.</span><span class="n">w</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">xyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tangentToWorld</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">xyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tangentToWorld</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tangentToWorld</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">xyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">xyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalWorld</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="c1">//We need this for shadow receving</span>
<span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">o</span><span class="p">);</span><span class="w"></span>

<span class="n">o</span><span class="p">.</span><span class="n">ambientOrLightmapUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VertexGIForward</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">posWorld</span><span class="p">,</span><span class="w"> </span><span class="n">normalWorld</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef _PARALLAXMAP</span>
<span class="w">    </span><span class="n">TANGENT_SPACE_ROTATION</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">half3</span><span class="w"> </span><span class="n">viewDirForParallax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="w"> </span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span><span class="w"> </span><span class="n">ObjSpaceViewDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewDirForParallax</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewDirForParallax</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">o</span><span class="p">.</span><span class="n">tangentToWorldAndParallax</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewDirForParallax</span><span class="p">.</span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="cp">#if UNITY_OPTIMIZE_TEXCUBELOD</span>
<span class="w">    </span><span class="n">o</span><span class="p">.</span><span class="n">reflUVW</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">reflect</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">eyeVec</span><span class="p">,</span><span class="w"> </span><span class="n">normalWorld</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="n">UNITY_TRANSFER_FOG</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">o</span><span class="p">.</span><span class="n">pos</span><span class="p">);</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">o</span><span class="p">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>普通に頂点シェーダー。たぶん
fragBase
    half4 fragBase (VertexOutputForwardBase i) : SV_Target { return fragForwardBaseInternal(i); }</p>
<p>CGInlucdes/UnityStandardCore.cginc
#define FRAGMENT_SETUP(x) FragmentCommonData x = \
    FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</p>
<p>struct FragmentCommonData
{
    half3 diffColor, specColor;
    // Note: oneMinusRoughness &amp; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.
    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.
    half oneMinusReflectivity, oneMinusRoughness;
    half3 normalWorld, eyeVec, posWorld;
    half alpha;</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<div class="code"><pre class="code literal-block">half3 reflUVW;
</pre></div>

<h2>endif</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<div class="code"><pre class="code literal-block">half3 tangentSpaceNormal;
</pre></div>

<h2>endif</h2>
<p>};</p>
<p>half4 OutputForward (half4 output, half alphaFromSurface)
{
    #if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON)
        output.a = alphaFromSurface;
    #else
        UNITY_OPAQUE_ALPHA(output.a);
    #endif
    return output;
}</p>
<p>half4 fragForwardBaseInternal (VertexOutputForwardBase i)
{
    FRAGMENT_SETUP(s)</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<div class="code"><pre class="code literal-block">s.reflUVW        = i.reflUVW;
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="nv">UnityLight</span><span class="w"> </span><span class="nv">mainLight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">MainLight</span><span class="w"> </span><span class="ss">(</span><span class="nv">s</span>.<span class="nv">normalWorld</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">half</span><span class="w"> </span><span class="nv">atten</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">SHADOW_ATTENUATION</span><span class="ss">(</span><span class="nv">i</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>


<span class="nv">half</span><span class="w"> </span><span class="nv">occlusion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Occlusion</span><span class="ss">(</span><span class="nv">i</span>.<span class="nv">tex</span>.<span class="nv">xy</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">UnityGI</span><span class="w"> </span><span class="nv">gi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">FragmentGI</span><span class="w"> </span><span class="ss">(</span><span class="nv">s</span>,<span class="w"> </span><span class="nv">occlusion</span>,<span class="w"> </span><span class="nv">i</span>.<span class="nv">ambientOrLightmapUV</span>,<span class="w"> </span><span class="nv">atten</span>,<span class="w"> </span><span class="nv">mainLight</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">half4</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">UNITY_BRDF_PBS</span><span class="w"> </span><span class="ss">(</span><span class="nv">s</span>.<span class="nv">diffColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">specColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusReflectivity</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusRoughness</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">normalWorld</span>,<span class="w"> </span><span class="o">-</span><span class="nv">s</span>.<span class="nv">eyeVec</span>,<span class="w"> </span><span class="nv">gi</span>.<span class="nv">light</span>,<span class="w"> </span><span class="nv">gi</span>.<span class="nv">indirect</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">c</span>.<span class="nv">rgb</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nv">UNITY_BRDF_GI</span><span class="w"> </span><span class="ss">(</span><span class="nv">s</span>.<span class="nv">diffColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">specColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusReflectivity</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusRoughness</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">normalWorld</span>,<span class="w"> </span><span class="o">-</span><span class="nv">s</span>.<span class="nv">eyeVec</span>,<span class="w"> </span><span class="nv">occlusion</span>,<span class="w"> </span><span class="nv">gi</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">c</span>.<span class="nv">rgb</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nv">Emission</span><span class="ss">(</span><span class="nv">i</span>.<span class="nv">tex</span>.<span class="nv">xy</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">UNITY_APPLY_FOG</span><span class="ss">(</span><span class="nv">i</span>.<span class="nv">fogCoord</span>,<span class="w"> </span><span class="nv">c</span>.<span class="nv">rgb</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="nv">OutputForward</span><span class="w"> </span><span class="ss">(</span><span class="nv">c</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">alpha</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>普通にピクセルシェーダーで便利関数がいっぱい定義済みという感じか。
しかし、#ifの類がたくさんありどのルートが使われるか不明瞭。
includeを展開してみる
UsePassの代わりに自前のファイルにシェーダーのコードをコピーしてそっちを使ってみる。
DefaultResourcesExtra/Standard.shaderから切り張り
        Pass{
            Name "FORWARD"
            Tags{ "LightMode" = "ForwardBase" }</p>
<div class="code"><pre class="code literal-block"><span class="w">        </span><span class="n">ZWrite</span><span class="w"> </span><span class="n">Off</span><span class="w"></span>
<span class="w">        </span><span class="n">ColorMask</span><span class="w"> </span><span class="n">RGB</span><span class="w"></span>
<span class="w">        </span><span class="n">Blend</span><span class="w"> </span><span class="n">SrcAlpha</span><span class="w"> </span><span class="n">OneMinusSrcAlpha</span><span class="w"></span>

<span class="w">        </span><span class="n">CGPROGRAM</span><span class="w"></span>
<span class="w">        </span><span class="c1">#pragma target 2.0</span><span class="w"></span>

<span class="w">        </span><span class="c1">#pragma shader_feature _NORMALMAP</span><span class="w"></span>
<span class="w">        </span><span class="c1">#pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON</span><span class="w"></span>
<span class="w">        </span><span class="c1">#pragma shader_feature _EMISSION </span><span class="w"></span>
<span class="w">        </span><span class="c1">#pragma shader_feature _METALLICGLOSSMAP </span><span class="w"></span>
<span class="w">        </span><span class="c1">#pragma shader_feature ___ _DETAIL_MULX2</span><span class="w"></span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">SM2</span><span class="o">.</span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="n">NOT</span><span class="w"> </span><span class="n">SUPPORTED</span><span class="w"> </span><span class="n">shader_feature</span><span class="w"> </span><span class="n">_PARALLAXMAP</span><span class="w"></span>

<span class="w">        </span><span class="c1">#pragma skip_variants SHADOWS_SOFT DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE</span><span class="w"></span>

<span class="w">        </span><span class="c1">#pragma multi_compile_fwdbase</span><span class="w"></span>
<span class="w">        </span><span class="c1">#pragma multi_compile_fog</span><span class="w"></span>

<span class="w">        </span><span class="c1">#pragma vertex vertBase</span><span class="w"></span>
<span class="w">        </span><span class="c1">#pragma fragment fragBase</span><span class="w"></span>

<span class="w">        </span><span class="c1">#include "TransparentDiffuseWithZwrite_FORWARD.cginc"</span><span class="w"></span>
<span class="w">        </span><span class="n">ENDCG</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>

<p>UnityStandardCore.cgincから使うところだけ収集。
TransparentDiffuseWithZwrite_FORWARD.cginc</p>
<h2>include "UnityStandardConfig.cginc"</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>include "UnityStandardInput.cginc"</h2>
<h2>include "AutoLight.cginc"</h2>
<p>struct VertexOutputForwardBase
{
    float4 pos                            : SV_POSITION;
    float4 tex                            : TEXCOORD0;
    half3 eyeVec                         : TEXCOORD1;
    half4 tangentToWorldAndParallax[3]    : TEXCOORD2;    // [3x3:tangentToWorld | 1x3:viewDirForParallax]
    half4 ambientOrLightmapUV            : TEXCOORD5;    // SH or Lightmap UV
    SHADOW_COORDS(6)
        UNITY_FOG_COORDS(7)</p>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="k">next</span><span class="w"> </span><span class="nv">ones</span><span class="w"> </span><span class="nv">would</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">fit</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">SM2</span>.<span class="mi">0</span><span class="w"> </span><span class="nv">limits</span>,<span class="w"> </span><span class="nv">but</span><span class="w"> </span><span class="nv">they</span><span class="w"> </span><span class="nv">are</span><span class="w"> </span><span class="nv">always</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">SM3</span>.<span class="mi">0</span><span class="o">+</span><span class="w"></span>
</pre></div>

<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<div class="code"><pre class="code literal-block">    float3 posWorld                    : TEXCOORD8;
</pre></div>

<h2>endif</h2>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<div class="code"><pre class="code literal-block">half3 reflUVW                : TEXCOORD9;
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block">half3 reflUVW                : TEXCOORD8;
</pre></div>

<h2>endif</h2>
<h2>endif</h2>
<p>};</p>
<p>half3 NormalizePerVertexNormal(half3 n)
{</p>
<h2>if (SHADER_TARGET &lt; 30) || UNITY_STANDARD_SIMPLE</h2>
<div class="code"><pre class="code literal-block"><span class="k">return</span><span class="w"> </span><span class="nv">normalize</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block"><span class="k">return</span><span class="w"> </span><span class="nv">n</span><span class="c1">; // will normalize per-pixel instead</span><span class="w"></span>
</pre></div>

<h2>endif</h2>
<p>}</p>
<p>half3 NormalizePerPixelNormal(half3 n)
{</p>
<h2>if (SHADER_TARGET &lt; 30) || UNITY_STANDARD_SIMPLE</h2>
<div class="code"><pre class="code literal-block"><span class="k">return</span><span class="w"> </span><span class="nv">n</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block"><span class="k">return</span><span class="w"> </span><span class="nv">normalize</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<h2>endif</h2>
<p>}</p>
<p>UnityLight MainLight(half3 normalWorld)
{
    UnityLight l;</p>
<h2>ifdef LIGHTMAP_OFF</h2>
<div class="code"><pre class="code literal-block">l.color = _LightColor0.rgb;
l.dir = _WorldSpaceLightPos0.xyz;
l.ndotl = LambertTerm(normalWorld, l.dir);
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block">// no light specified by the engine
// analytical light might be extracted from Lightmap data later on in the shader depending on the Lightmap type
l.color = half3(0.f, 0.f, 0.f);
l.ndotl = 0.f;
l.dir = half3(0.f, 0.f, 0.f);
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="k">return</span><span class="w"> </span><span class="nv">l</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)
{
    half4 ambientOrLightmapUV = 0;
    // Static lightmaps</p>
<h2>ifndef LIGHTMAP_OFF</h2>
<div class="code"><pre class="code literal-block"><span class="nv">ambientOrLightmapUV</span>.<span class="nv">xy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">v</span>.<span class="nv">uv1</span>.<span class="nv">xy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nv">unity_LightmapST</span>.<span class="nv">xy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">unity_LightmapST</span>.<span class="nv">zw</span><span class="c1">;</span><span class="w"></span>
<span class="nv">ambientOrLightmapUV</span>.<span class="nv">zw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="nv">Sample</span><span class="w"> </span><span class="nv">light</span><span class="w"> </span><span class="nv">probe</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">Dynamic</span><span class="w"> </span><span class="nv">objects</span><span class="w"> </span><span class="nv">only</span><span class="w"> </span><span class="ss">(</span><span class="nv">no</span><span class="w"> </span><span class="nv">static</span><span class="w"> </span><span class="nv">or</span><span class="w"> </span><span class="nv">dynamic</span><span class="w"> </span><span class="nv">lightmaps</span><span class="ss">)</span><span class="w"></span>
</pre></div>

<h2>elif UNITY_SHOULD_SAMPLE_SH</h2>
<h2>ifdef VERTEXLIGHT_ON</h2>
<div class="code"><pre class="code literal-block">// Approximated illumination from non-important point lights
ambientOrLightmapUV.rgb = Shade4PointLights(
        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
        unity_4LightAtten0, posWorld, normalWorld);
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block">ambientOrLightmapUV.rgb = ShadeSHPerVertex(normalWorld, ambientOrLightmapUV.rgb);
</pre></div>

<h2>endif</h2>
<h2>ifdef DYNAMICLIGHTMAP_ON</h2>
<div class="code"><pre class="code literal-block">ambientOrLightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="k">return</span><span class="w"> </span><span class="nv">ambientOrLightmapUV</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>VertexOutputForwardBase vertForwardBase(VertexInput v)
{
    VertexOutputForwardBase o;
    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</p>
<div class="code"><pre class="code literal-block">float4 posWorld = mul(_Object2World, v.vertex);
</pre></div>

<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<div class="code"><pre class="code literal-block">o.posWorld = posWorld.xyz;
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block">o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
o.tex = TexCoords(v);
o.eyeVec = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);
float3 normalWorld = UnityObjectToWorldNormal(v.normal);
</pre></div>

<h2>ifdef _TANGENT_TO_WORLD</h2>
<div class="code"><pre class="code literal-block">float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);

float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);
o.tangentToWorldAndParallax[0].xyz = tangentToWorld[0];
o.tangentToWorldAndParallax[1].xyz = tangentToWorld[1];
o.tangentToWorldAndParallax[2].xyz = tangentToWorld[2];
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block">o.tangentToWorldAndParallax[0].xyz = 0;
o.tangentToWorldAndParallax[1].xyz = 0;
o.tangentToWorldAndParallax[2].xyz = normalWorld;
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="nv">We</span><span class="w"> </span><span class="nv">need</span><span class="w"> </span><span class="nv">this</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">shadow</span><span class="w"> </span><span class="nv">receving</span><span class="w"></span>
<span class="nv">TRANSFER_SHADOW</span><span class="ss">(</span><span class="nv">o</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">o</span>.<span class="nv">ambientOrLightmapUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">VertexGIForward</span><span class="ss">(</span><span class="nv">v</span>,<span class="w"> </span><span class="nv">posWorld</span>,<span class="w"> </span><span class="nv">normalWorld</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<h2>ifdef _PARALLAXMAP</h2>
<div class="code"><pre class="code literal-block">TANGENT_SPACE_ROTATION;
half3 viewDirForParallax = mul(rotation, ObjSpaceViewDir(v.vertex));
o.tangentToWorldAndParallax[0].w = viewDirForParallax.x;
o.tangentToWorldAndParallax[1].w = viewDirForParallax.y;
o.tangentToWorldAndParallax[2].w = viewDirForParallax.z;
</pre></div>

<h2>endif</h2>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<div class="code"><pre class="code literal-block">o.reflUVW = reflect(o.eyeVec, normalWorld);
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="nv">UNITY_TRANSFER_FOG</span><span class="ss">(</span><span class="nv">o</span>,<span class="nv">o</span>.<span class="nv">pos</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="nv">o</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>VertexOutputForwardBase vertBase(VertexInput v) { return vertForwardBase(v); }
//VertexOutputForwardAdd vertAdd(VertexInput v) { return vertForwardAdd(v); }</p>
<h2>ifdef _PARALLAXMAP</h2>
<h2>define IN_VIEWDIR4PARALLAX(i) NormalizePerPixelNormal(half3(i.tangentToWorldAndParallax[0].w,i.tangentToWorldAndParallax[1].w,i.tangentToWorldAndParallax[2].w))</h2>
<h2>define IN_VIEWDIR4PARALLAX_FWDADD(i) NormalizePerPixelNormal(i.viewDirForParallax.xyz)</h2>
<h2>else</h2>
<h2>define IN_VIEWDIR4PARALLAX(i) half3(0,0,0)</h2>
<h2>define IN_VIEWDIR4PARALLAX_FWDADD(i) half3(0,0,0)</h2>
<h2>endif</h2>
<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<h2>define IN_WORLDPOS(i) i.posWorld</h2>
<h2>else</h2>
<h2>define IN_WORLDPOS(i) half3(0,0,0)</h2>
<h2>endif</h2>
<p>struct FragmentCommonData
{
    half3 diffColor, specColor;
    // Note: oneMinusRoughness &amp; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.
    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.
    half oneMinusReflectivity, oneMinusRoughness;
    half3 normalWorld, eyeVec, posWorld;
    half alpha;</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<div class="code"><pre class="code literal-block">half3 reflUVW;
</pre></div>

<h2>endif</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<div class="code"><pre class="code literal-block">half3 tangentSpaceNormal;
</pre></div>

<h2>endif</h2>
<p>};</p>
<p>inline FragmentCommonData MetallicSetup(float4 i_tex)
{
    half2 metallicGloss = MetallicGloss(i_tex.xy);
    half metallic = metallicGloss.x;
    half oneMinusRoughness = metallicGloss.y;        // this is 1 minus the square root of real roughness m.</p>
<div class="code"><pre class="code literal-block"><span class="nv">half</span><span class="w"> </span><span class="nv">oneMinusReflectivity</span><span class="c1">;</span><span class="w"></span>
<span class="nv">half3</span><span class="w"> </span><span class="nv">specColor</span><span class="c1">;</span><span class="w"></span>
<span class="nv">half3</span><span class="w"> </span><span class="nv">diffColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">DiffuseAndSpecularFromMetallic</span><span class="ss">(</span><span class="nv">Albedo</span><span class="ss">(</span><span class="nv">i_tex</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">metallic</span>,<span class="w"> </span><span class="cm">/*out*/</span><span class="w"> </span><span class="nv">specColor</span>,<span class="w"> </span><span class="cm">/*out*/</span><span class="w"> </span><span class="nv">oneMinusReflectivity</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">FragmentCommonData</span><span class="w"> </span><span class="nv">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">(</span><span class="nv">FragmentCommonData</span><span class="ss">)</span><span class="mi">0</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">diffColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">diffColor</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">specColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">specColor</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">oneMinusReflectivity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">oneMinusReflectivity</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">oneMinusRoughness</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">oneMinusRoughness</span><span class="c1">;</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="nv">o</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<h2>ifndef UNITY_SETUP_BRDF_INPUT</h2>
<h2>define UNITY_SETUP_BRDF_INPUT SpecularSetup</h2>
<h2>endif</h2>
<p>inline FragmentCommonData SpecularSetup(float4 i_tex)
{
    half4 specGloss = SpecularGloss(i_tex.xy);
    half3 specColor = specGloss.rgb;
    half oneMinusRoughness = specGloss.a;</p>
<div class="code"><pre class="code literal-block"><span class="nv">half</span><span class="w"> </span><span class="nv">oneMinusReflectivity</span><span class="c1">;</span><span class="w"></span>
<span class="nv">half3</span><span class="w"> </span><span class="nv">diffColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">EnergyConservationBetweenDiffuseAndSpecular</span><span class="ss">(</span><span class="nv">Albedo</span><span class="ss">(</span><span class="nv">i_tex</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">specColor</span>,<span class="w"> </span><span class="cm">/*out*/</span><span class="w"> </span><span class="nv">oneMinusReflectivity</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">FragmentCommonData</span><span class="w"> </span><span class="nv">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">(</span><span class="nv">FragmentCommonData</span><span class="ss">)</span><span class="mi">0</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">diffColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">diffColor</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">specColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">specColor</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">oneMinusReflectivity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">oneMinusReflectivity</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">oneMinusRoughness</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">oneMinusRoughness</span><span class="c1">;</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="nv">o</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>half3 PerPixelWorldNormal(float4 i_tex, half4 tangentToWorld[3])
{</p>
<h2>ifdef _NORMALMAP</h2>
<div class="code"><pre class="code literal-block">half3 tangent = tangentToWorld[0].xyz;
half3 binormal = tangentToWorld[1].xyz;
half3 normal = tangentToWorld[2].xyz;
</pre></div>

<h2>if UNITY_TANGENT_ORTHONORMALIZE</h2>
<div class="code"><pre class="code literal-block">normal = NormalizePerPixelNormal(normal);

// ortho-normalize Tangent
tangent = normalize(tangent - normal * dot(tangent, normal));

// recalculate Binormal
half3 newB = cross(normal, tangent);
binormal = newB * sign(dot(newB, binormal));
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="n">half3</span><span class="w"> </span><span class="n">normalTangent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NormalInTangentSpace</span><span class="p">(</span><span class="n">i_tex</span><span class="p">);</span><span class="w"></span>
<span class="n">half3</span><span class="w"> </span><span class="n">normalWorld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NormalizePerPixelNormal</span><span class="p">(</span><span class="n">tangent</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normalTangent</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">binormal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normalTangent</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">normalTangent</span><span class="p">.</span><span class="n">z</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nv">@TODO</span><span class="err">:</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">squeeze</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">normalize</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">SM2</span><span class="mf">.0</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">well</span><span class="w"></span>
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block">half3 normalWorld = normalize(tangentToWorld[2].xyz);
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="k">return</span><span class="w"> </span><span class="nv">normalWorld</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>#define FRAGMENT_SETUP(x) FragmentCommonData x = \
                                                 FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</p>
<p>inline FragmentCommonData FragmentSetup(float4 i_tex, half3 i_eyeVec, half3 i_viewDirForParallax, half4 tangentToWorld[3], half3 i_posWorld)
{
    i_tex = Parallax(i_tex, i_viewDirForParallax);</p>
<div class="code"><pre class="code literal-block">half alpha = Alpha(i_tex.xy);
</pre></div>

<h2>if defined(_ALPHATEST_ON)</h2>
<div class="code"><pre class="code literal-block">clip(alpha - _Cutoff);
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="nt">FragmentCommonData</span><span class="w"> </span><span class="nt">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">UNITY_SETUP_BRDF_INPUT</span><span class="o">(</span><span class="nt">i_tex</span><span class="o">);</span><span class="w"></span>
<span class="nt">o</span><span class="p">.</span><span class="nc">normalWorld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">PerPixelWorldNormal</span><span class="o">(</span><span class="nt">i_tex</span><span class="o">,</span><span class="w"> </span><span class="nt">tangentToWorld</span><span class="o">);</span><span class="w"></span>
<span class="nt">o</span><span class="p">.</span><span class="nc">eyeVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">NormalizePerPixelNormal</span><span class="o">(</span><span class="nt">i_eyeVec</span><span class="o">);</span><span class="w"></span>
<span class="nt">o</span><span class="p">.</span><span class="nc">posWorld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">i_posWorld</span><span class="o">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="nt">NOTE</span><span class="o">:</span><span class="w"> </span><span class="nt">shader</span><span class="w"> </span><span class="nt">relies</span><span class="w"> </span><span class="nt">on</span><span class="w"> </span><span class="nt">pre-multiply</span><span class="w"> </span><span class="nt">alpha-blend</span><span class="w"> </span><span class="o">(</span><span class="nt">_SrcBlend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">One</span><span class="o">,</span><span class="w"> </span><span class="nt">_DstBlend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">OneMinusSrcAlpha</span><span class="o">)</span><span class="w"></span>
<span class="nt">o</span><span class="p">.</span><span class="nc">diffColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">PreMultiplyAlpha</span><span class="o">(</span><span class="nt">o</span><span class="p">.</span><span class="nc">diffColor</span><span class="o">,</span><span class="w"> </span><span class="nt">alpha</span><span class="o">,</span><span class="w"> </span><span class="nt">o</span><span class="p">.</span><span class="nc">oneMinusReflectivity</span><span class="o">,</span><span class="w"> </span><span class="c">/*out*/</span><span class="w"> </span><span class="nt">o</span><span class="p">.</span><span class="nc">alpha</span><span class="o">);</span><span class="w"></span>
<span class="nt">return</span><span class="w"> </span><span class="nt">o</span><span class="o">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light, bool reflections)
{
    UnityGIInput d;
    d.light = light;
    d.worldPos = s.posWorld;
    d.worldViewDir = -s.eyeVec;
    d.atten = atten;</p>
<h2>if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)</h2>
<div class="code"><pre class="code literal-block">d.ambient = 0;
d.lightmapUV = i_ambientOrLightmapUV;
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block">d.ambient = i_ambientOrLightmapUV.rgb;
d.lightmapUV = 0;
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="nv">d</span>.<span class="nv">boxMax</span>[<span class="mi">0</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube0_BoxMax</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">boxMin</span>[<span class="mi">0</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube0_BoxMin</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">probePosition</span>[<span class="mi">0</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube0_ProbePosition</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">probeHDR</span>[<span class="mi">0</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube0_HDR</span><span class="c1">;</span><span class="w"></span>

<span class="nv">d</span>.<span class="nv">boxMax</span>[<span class="mi">1</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube1_BoxMax</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">boxMin</span>[<span class="mi">1</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube1_BoxMin</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">probePosition</span>[<span class="mi">1</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube1_ProbePosition</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">probeHDR</span>[<span class="mi">1</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube1_HDR</span><span class="c1">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">reflections</span><span class="ss">)</span><span class="w"></span>
{<span class="w"></span>
<span class="w">    </span><span class="nv">Unity_GlossyEnvironmentData</span><span class="w"> </span><span class="nv">g</span><span class="c1">;</span><span class="w"></span>
<span class="w">    </span><span class="nv">g</span>.<span class="nv">roughness</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusRoughness</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<div class="code"><pre class="code literal-block">    g.reflUVW = s.reflUVW;
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block">    g.reflUVW = reflect(s.eyeVec, s.normalWorld);
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">UnityGlobalIllumination</span><span class="ss">(</span><span class="nv">d</span>,<span class="w"> </span><span class="nv">occlusion</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">normalWorld</span>,<span class="w"> </span><span class="nv">g</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
}<span class="w"></span>
<span class="k">else</span><span class="w"></span>
{<span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">UnityGlobalIllumination</span><span class="ss">(</span><span class="nv">d</span>,<span class="w"> </span><span class="nv">occlusion</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">normalWorld</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
}<span class="w"></span>
</pre></div>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light)
{
    return FragmentGI(s, occlusion, i_ambientOrLightmapUV, atten, light, true);
}</p>
<p>half4 OutputForward(half4 output, half alphaFromSurface)
{</p>
<h2>if defined(_ALPHABLEND_ON) || defined(_ALPHAPREMULTIPLY_ON)</h2>
<div class="code"><pre class="code literal-block">output.a = alphaFromSurface;
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block">UNITY_OPAQUE_ALPHA(output.a);
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="k">return</span><span class="w"> </span><span class="nv">output</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>half4 fragForwardBaseInternal(VertexOutputForwardBase i)
{
    FRAGMENT_SETUP(s)</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<div class="code"><pre class="code literal-block">    s.reflUVW = i.reflUVW;
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="nv">UnityLight</span><span class="w"> </span><span class="nv">mainLight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">MainLight</span><span class="ss">(</span><span class="nv">s</span>.<span class="nv">normalWorld</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">half</span><span class="w"> </span><span class="nv">atten</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">SHADOW_ATTENUATION</span><span class="ss">(</span><span class="nv">i</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>


<span class="nv">half</span><span class="w"> </span><span class="nv">occlusion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Occlusion</span><span class="ss">(</span><span class="nv">i</span>.<span class="nv">tex</span>.<span class="nv">xy</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">UnityGI</span><span class="w"> </span><span class="nv">gi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">FragmentGI</span><span class="ss">(</span><span class="nv">s</span>,<span class="w"> </span><span class="nv">occlusion</span>,<span class="w"> </span><span class="nv">i</span>.<span class="nv">ambientOrLightmapUV</span>,<span class="w"> </span><span class="nv">atten</span>,<span class="w"> </span><span class="nv">mainLight</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">half4</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">UNITY_BRDF_PBS</span><span class="ss">(</span><span class="nv">s</span>.<span class="nv">diffColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">specColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusReflectivity</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusRoughness</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">normalWorld</span>,<span class="w"> </span><span class="o">-</span><span class="nv">s</span>.<span class="nv">eyeVec</span>,<span class="w"> </span><span class="nv">gi</span>.<span class="nv">light</span>,<span class="w"> </span><span class="nv">gi</span>.<span class="nv">indirect</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">c</span>.<span class="nv">rgb</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nv">UNITY_BRDF_GI</span><span class="ss">(</span><span class="nv">s</span>.<span class="nv">diffColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">specColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusReflectivity</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusRoughness</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">normalWorld</span>,<span class="w"> </span><span class="o">-</span><span class="nv">s</span>.<span class="nv">eyeVec</span>,<span class="w"> </span><span class="nv">occlusion</span>,<span class="w"> </span><span class="nv">gi</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">c</span>.<span class="nv">rgb</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nv">Emission</span><span class="ss">(</span><span class="nv">i</span>.<span class="nv">tex</span>.<span class="nv">xy</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">UNITY_APPLY_FOG</span><span class="ss">(</span><span class="nv">i</span>.<span class="nv">fogCoord</span>,<span class="w"> </span><span class="nv">c</span>.<span class="nv">rgb</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="nv">OutputForward</span><span class="ss">(</span><span class="nv">c</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">alpha</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>half4 fragBase(VertexOutputForwardBase i) : SV_Target{ return fragForwardBaseInternal(i); }
//half4 fragAdd(VertexOutputForwardAdd i) : SV_Target{ return fragForwardAddInternal(i); }</p>
<p>ある程度#includeを除いてシンプル化した。しかし、アルファブレンディングがなかなか有効にならずに悩んだ。
原因は、</p>
<h2>pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON</h2>
<p>で、このShaderキーワードの_ALPHABLEND_ONをEnableにしてやる必要があった。
material.EnableKeyword("_ALPHABLEND_ON");</p>
<p>ビルトインシェーダーでは何故自動で”_ALPHABLEND_ON”になるのか
DefaultResourcesExtra/Standard.shaderの末尾
    CustomEditor "StandardShaderGUI"</p>
<p>でカスタムエディタが指定してありこれを経由してマテリアルに介入してたのであった・・・。わかりにくいw
shader_featureとmulti_compileを剥がす
少しコード整理。
shader_featureとmulti_compileを剥がした。
ピクセルシェーダーは、GIとか書いてあってわりと複雑なのでその辺には手を触れず。</p>
<h2>include "UnityStandardConfig.cginc"</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>include "UnityStandardInput.cginc"</h2>
<h2>include "AutoLight.cginc"</h2>
<p>//////////////////////////////////////////////////////////////////////////////
// vertBase
//////////////////////////////////////////////////////////////////////////////
struct VertexOutputForwardBase
{
    float4 pos                            : SV_POSITION;
    float4 tex                            : TEXCOORD0;
    half3 eyeVec                         : TEXCOORD1;
    half4 tangentToWorldAndParallax[3]    : TEXCOORD2;    // [3x3:tangentToWorld | 1x3:viewDirForParallax]
    half4 ambientOrLightmapUV            : TEXCOORD5;    // SH or Lightmap UV
    SHADOW_COORDS(6)
    UNITY_FOG_COORDS(7)
};</p>
<p>inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)
{
    half4 ambientOrLightmapUV = 0;
    // Static lightmaps</p>
<h2>ifndef LIGHTMAP_OFF</h2>
<div class="code"><pre class="code literal-block"><span class="nv">ambientOrLightmapUV</span>.<span class="nv">xy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">v</span>.<span class="nv">uv1</span>.<span class="nv">xy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nv">unity_LightmapST</span>.<span class="nv">xy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">unity_LightmapST</span>.<span class="nv">zw</span><span class="c1">;</span><span class="w"></span>
<span class="nv">ambientOrLightmapUV</span>.<span class="nv">zw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="nv">Sample</span><span class="w"> </span><span class="nv">light</span><span class="w"> </span><span class="nv">probe</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">Dynamic</span><span class="w"> </span><span class="nv">objects</span><span class="w"> </span><span class="nv">only</span><span class="w"> </span><span class="ss">(</span><span class="nv">no</span><span class="w"> </span><span class="nv">static</span><span class="w"> </span><span class="nv">or</span><span class="w"> </span><span class="nv">dynamic</span><span class="w"> </span><span class="nv">lightmaps</span><span class="ss">)</span><span class="w"></span>
</pre></div>

<h2>elif UNITY_SHOULD_SAMPLE_SH</h2>
<h2>ifdef VERTEXLIGHT_ON</h2>
<div class="code"><pre class="code literal-block">// Approximated illumination from non-important point lights
ambientOrLightmapUV.rgb = Shade4PointLights(
        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
        unity_4LightAtten0, posWorld, normalWorld);
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block">ambientOrLightmapUV.rgb = ShadeSHPerVertex(normalWorld, ambientOrLightmapUV.rgb);
</pre></div>

<h2>endif</h2>
<h2>ifdef DYNAMICLIGHTMAP_ON</h2>
<div class="code"><pre class="code literal-block">ambientOrLightmapUV.zw = v.uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="k">return</span><span class="w"> </span><span class="nv">ambientOrLightmapUV</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>half3 NormalizePerVertexNormal(half3 n)
{
    return normalize(n);
}</p>
<p>VertexOutputForwardBase vertForwardBase(VertexInput v)
{
    VertexOutputForwardBase o;
    UNITY_INITIALIZE_OUTPUT(VertexOutputForwardBase, o);</p>
<div class="code"><pre class="code literal-block">float4 posWorld = mul(_Object2World, v.vertex);
</pre></div>

<h2>if UNITY_SPECCUBE_BOX_PROJECTION</h2>
<div class="code"><pre class="code literal-block">o.posWorld = posWorld.xyz;
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block">o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
o.tex = TexCoords(v);
o.eyeVec = NormalizePerVertexNormal(posWorld.xyz - _WorldSpaceCameraPos);
float3 normalWorld = UnityObjectToWorldNormal(v.normal);
</pre></div>

<h2>ifdef _TANGENT_TO_WORLD</h2>
<div class="code"><pre class="code literal-block">float4 tangentWorld = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);

float3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w);
o.tangentToWorldAndParallax[0].xyz = tangentToWorld[0];
o.tangentToWorldAndParallax[1].xyz = tangentToWorld[1];
o.tangentToWorldAndParallax[2].xyz = tangentToWorld[2];
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block">o.tangentToWorldAndParallax[0].xyz = 0;
o.tangentToWorldAndParallax[1].xyz = 0;
o.tangentToWorldAndParallax[2].xyz = normalWorld;
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="o">//</span><span class="nv">We</span><span class="w"> </span><span class="nv">need</span><span class="w"> </span><span class="nv">this</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">shadow</span><span class="w"> </span><span class="nv">receving</span><span class="w"></span>
<span class="nv">TRANSFER_SHADOW</span><span class="ss">(</span><span class="nv">o</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">o</span>.<span class="nv">ambientOrLightmapUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">VertexGIForward</span><span class="ss">(</span><span class="nv">v</span>,<span class="w"> </span><span class="nv">posWorld</span>,<span class="w"> </span><span class="nv">normalWorld</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<div class="code"><pre class="code literal-block">o.reflUVW = reflect(o.eyeVec, normalWorld);
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="nv">UNITY_TRANSFER_FOG</span><span class="ss">(</span><span class="nv">o</span>,<span class="nv">o</span>.<span class="nv">pos</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="nv">o</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>VertexOutputForwardBase vertBase(VertexInput v) { return vertForwardBase(v); }</p>
<p>//////////////////////////////////////////////////////////////////////////////
// fragBase
//////////////////////////////////////////////////////////////////////////////</p>
<h2>define IN_VIEWDIR4PARALLAX(i) half3(0,0,0)</h2>
<h2>define IN_VIEWDIR4PARALLAX_FWDADD(i) half3(0,0,0)</h2>
<h2>define IN_WORLDPOS(i) half3(0,0,0)</h2>
<p>struct FragmentCommonData
{
    half3 diffColor, specColor;
    // Note: oneMinusRoughness &amp; oneMinusReflectivity for optimization purposes, mostly for DX9 SM2.0 level.
    // Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.
    half oneMinusReflectivity, oneMinusRoughness;
    half3 normalWorld, eyeVec, posWorld;
    half alpha;</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<div class="code"><pre class="code literal-block">half3 reflUVW;
</pre></div>

<h2>endif</h2>
<h2>if UNITY_STANDARD_SIMPLE</h2>
<div class="code"><pre class="code literal-block">half3 tangentSpaceNormal;
</pre></div>

<h2>endif</h2>
<p>};</p>
<h2>ifndef UNITY_SETUP_BRDF_INPUT</h2>
<h2>define UNITY_SETUP_BRDF_INPUT SpecularSetup</h2>
<h2>endif</h2>
<p>inline FragmentCommonData SpecularSetup(float4 i_tex)
{
    half4 specGloss = SpecularGloss(i_tex.xy);
    half3 specColor = specGloss.rgb;
    half oneMinusRoughness = specGloss.a;</p>
<div class="code"><pre class="code literal-block"><span class="nv">half</span><span class="w"> </span><span class="nv">oneMinusReflectivity</span><span class="c1">;</span><span class="w"></span>
<span class="nv">half3</span><span class="w"> </span><span class="nv">diffColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">EnergyConservationBetweenDiffuseAndSpecular</span><span class="ss">(</span><span class="nv">Albedo</span><span class="ss">(</span><span class="nv">i_tex</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">specColor</span>,<span class="w"> </span><span class="cm">/*out*/</span><span class="w"> </span><span class="nv">oneMinusReflectivity</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">FragmentCommonData</span><span class="w"> </span><span class="nv">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">(</span><span class="nv">FragmentCommonData</span><span class="ss">)</span><span class="mi">0</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">diffColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">diffColor</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">specColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">specColor</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">oneMinusReflectivity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">oneMinusReflectivity</span><span class="c1">;</span><span class="w"></span>
<span class="nv">o</span>.<span class="nv">oneMinusRoughness</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">oneMinusRoughness</span><span class="c1">;</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="nv">o</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>half3 PerPixelWorldNormal(float4 i_tex, half4 tangentToWorld[3])
{
    half3 normalWorld = normalize(tangentToWorld[2].xyz);
    return normalWorld;
}</p>
<p>#define FRAGMENT_SETUP(x) FragmentCommonData x = \
                                                 FragmentSetup(i.tex, i.eyeVec, IN_VIEWDIR4PARALLAX(i), i.tangentToWorldAndParallax, IN_WORLDPOS(i));</p>
<p>inline FragmentCommonData FragmentSetup(float4 i_tex, half3 i_eyeVec, half3 i_viewDirForParallax, half4 tangentToWorld[3], half3 i_posWorld)
{
    i_tex = Parallax(i_tex, i_viewDirForParallax);</p>
<div class="code"><pre class="code literal-block"><span class="nt">half</span><span class="w"> </span><span class="nt">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">Alpha</span><span class="o">(</span><span class="nt">i_tex</span><span class="p">.</span><span class="nc">xy</span><span class="o">);</span><span class="w"></span>

<span class="nt">FragmentCommonData</span><span class="w"> </span><span class="nt">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">UNITY_SETUP_BRDF_INPUT</span><span class="o">(</span><span class="nt">i_tex</span><span class="o">);</span><span class="w"></span>
<span class="nt">o</span><span class="p">.</span><span class="nc">normalWorld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">PerPixelWorldNormal</span><span class="o">(</span><span class="nt">i_tex</span><span class="o">,</span><span class="w"> </span><span class="nt">tangentToWorld</span><span class="o">);</span><span class="w"></span>
<span class="nt">o</span><span class="p">.</span><span class="nc">eyeVec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">i_eyeVec</span><span class="o">;</span><span class="w"></span>
<span class="nt">o</span><span class="p">.</span><span class="nc">posWorld</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">i_posWorld</span><span class="o">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="nt">NOTE</span><span class="o">:</span><span class="w"> </span><span class="nt">shader</span><span class="w"> </span><span class="nt">relies</span><span class="w"> </span><span class="nt">on</span><span class="w"> </span><span class="nt">pre-multiply</span><span class="w"> </span><span class="nt">alpha-blend</span><span class="w"> </span><span class="o">(</span><span class="nt">_SrcBlend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">One</span><span class="o">,</span><span class="w"> </span><span class="nt">_DstBlend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">OneMinusSrcAlpha</span><span class="o">)</span><span class="w"></span>
<span class="nt">o</span><span class="p">.</span><span class="nc">diffColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">PreMultiplyAlpha</span><span class="o">(</span><span class="nt">o</span><span class="p">.</span><span class="nc">diffColor</span><span class="o">,</span><span class="w"> </span><span class="nt">alpha</span><span class="o">,</span><span class="w"> </span><span class="nt">o</span><span class="p">.</span><span class="nc">oneMinusReflectivity</span><span class="o">,</span><span class="w"> </span><span class="c">/*out*/</span><span class="w"> </span><span class="nt">o</span><span class="p">.</span><span class="nc">alpha</span><span class="o">);</span><span class="w"></span>
<span class="nt">return</span><span class="w"> </span><span class="nt">o</span><span class="o">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light, bool reflections)
{
    UnityGIInput d;
    d.light = light;
    d.worldPos = s.posWorld;
    d.worldViewDir = -s.eyeVec;
    d.atten = atten;</p>
<h2>if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)</h2>
<div class="code"><pre class="code literal-block">d.ambient = 0;
d.lightmapUV = i_ambientOrLightmapUV;
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block">d.ambient = i_ambientOrLightmapUV.rgb;
d.lightmapUV = 0;
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="nv">d</span>.<span class="nv">boxMax</span>[<span class="mi">0</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube0_BoxMax</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">boxMin</span>[<span class="mi">0</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube0_BoxMin</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">probePosition</span>[<span class="mi">0</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube0_ProbePosition</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">probeHDR</span>[<span class="mi">0</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube0_HDR</span><span class="c1">;</span><span class="w"></span>

<span class="nv">d</span>.<span class="nv">boxMax</span>[<span class="mi">1</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube1_BoxMax</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">boxMin</span>[<span class="mi">1</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube1_BoxMin</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">probePosition</span>[<span class="mi">1</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube1_ProbePosition</span><span class="c1">;</span><span class="w"></span>
<span class="nv">d</span>.<span class="nv">probeHDR</span>[<span class="mi">1</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">unity_SpecCube1_HDR</span><span class="c1">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">reflections</span><span class="ss">)</span><span class="w"></span>
{<span class="w"></span>
<span class="w">    </span><span class="nv">Unity_GlossyEnvironmentData</span><span class="w"> </span><span class="nv">g</span><span class="c1">;</span><span class="w"></span>
<span class="w">    </span><span class="nv">g</span>.<span class="nv">roughness</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusRoughness</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<h2>if UNITY_OPTIMIZE_TEXCUBELOD || UNITY_STANDARD_SIMPLE</h2>
<div class="code"><pre class="code literal-block">    g.reflUVW = s.reflUVW;
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block">    g.reflUVW = reflect(s.eyeVec, s.normalWorld);
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">UnityGlobalIllumination</span><span class="ss">(</span><span class="nv">d</span>,<span class="w"> </span><span class="nv">occlusion</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">normalWorld</span>,<span class="w"> </span><span class="nv">g</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
}<span class="w"></span>
<span class="k">else</span><span class="w"></span>
{<span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">UnityGlobalIllumination</span><span class="ss">(</span><span class="nv">d</span>,<span class="w"> </span><span class="nv">occlusion</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">normalWorld</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
}<span class="w"></span>
</pre></div>

<p>}</p>
<p>inline UnityGI FragmentGI(FragmentCommonData s, half occlusion, half4 i_ambientOrLightmapUV, half atten, UnityLight light)
{
    return FragmentGI(s, occlusion, i_ambientOrLightmapUV, atten, light, true);
}</p>
<p>UnityLight MainLight(half3 normalWorld)
{
    UnityLight l;</p>
<h2>ifdef LIGHTMAP_OFF</h2>
<div class="code"><pre class="code literal-block">l.color = _LightColor0.rgb;
l.dir = _WorldSpaceLightPos0.xyz;
l.ndotl = LambertTerm(normalWorld, l.dir);
</pre></div>

<h2>else</h2>
<div class="code"><pre class="code literal-block">// no light specified by the engine
// analytical light might be extracted from Lightmap data later on in the shader depending on the Lightmap type
l.color = half3(0.f, 0.f, 0.f);
l.ndotl = 0.f;
l.dir = half3(0.f, 0.f, 0.f);
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="k">return</span><span class="w"> </span><span class="nv">l</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>half4 fragForwardBaseInternal(VertexOutputForwardBase i)
{
    FRAGMENT_SETUP(s)</p>
<h2>if UNITY_OPTIMIZE_TEXCUBELOD</h2>
<div class="code"><pre class="code literal-block">    s.reflUVW = i.reflUVW;
</pre></div>

<h2>endif</h2>
<div class="code"><pre class="code literal-block"><span class="nv">UnityLight</span><span class="w"> </span><span class="nv">mainLight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">MainLight</span><span class="ss">(</span><span class="nv">s</span>.<span class="nv">normalWorld</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">half</span><span class="w"> </span><span class="nv">atten</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">SHADOW_ATTENUATION</span><span class="ss">(</span><span class="nv">i</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">half</span><span class="w"> </span><span class="nv">occlusion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Occlusion</span><span class="ss">(</span><span class="nv">i</span>.<span class="nv">tex</span>.<span class="nv">xy</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">UnityGI</span><span class="w"> </span><span class="nv">gi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">FragmentGI</span><span class="ss">(</span><span class="nv">s</span>,<span class="w"> </span><span class="nv">occlusion</span>,<span class="w"> </span><span class="nv">i</span>.<span class="nv">ambientOrLightmapUV</span>,<span class="w"> </span><span class="nv">atten</span>,<span class="w"> </span><span class="nv">mainLight</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">half4</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">UNITY_BRDF_PBS</span><span class="ss">(</span><span class="nv">s</span>.<span class="nv">diffColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">specColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusReflectivity</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusRoughness</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">normalWorld</span>,<span class="w"> </span><span class="o">-</span><span class="nv">s</span>.<span class="nv">eyeVec</span>,<span class="w"> </span><span class="nv">gi</span>.<span class="nv">light</span>,<span class="w"> </span><span class="nv">gi</span>.<span class="nv">indirect</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">c</span>.<span class="nv">rgb</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nv">UNITY_BRDF_GI</span><span class="ss">(</span><span class="nv">s</span>.<span class="nv">diffColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">specColor</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusReflectivity</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">oneMinusRoughness</span>,<span class="w"> </span><span class="nv">s</span>.<span class="nv">normalWorld</span>,<span class="w"> </span><span class="o">-</span><span class="nv">s</span>.<span class="nv">eyeVec</span>,<span class="w"> </span><span class="nv">occlusion</span>,<span class="w"> </span><span class="nv">gi</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">c</span>.<span class="nv">rgb</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nv">Emission</span><span class="ss">(</span><span class="nv">i</span>.<span class="nv">tex</span>.<span class="nv">xy</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>

<span class="nv">UNITY_APPLY_FOG</span><span class="ss">(</span><span class="nv">i</span>.<span class="nv">fogCoord</span>,<span class="w"> </span><span class="nv">c</span>.<span class="nv">rgb</span><span class="ss">)</span><span class="c1">;</span><span class="w"></span>
<span class="nv">c</span>.<span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">s</span>.<span class="nv">alpha</span><span class="c1">;</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="nv">c</span><span class="c1">;</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>half4 fragBase(VertexOutputForwardBase i) : SV_Target{ return fragForwardBaseInternal(i); }</p>
<p>1パスでいいんじゃないの？
UsePassを展開したことによってZWrite Onできるようになったw。Oh…
Shader "Transparent/Diffuse ZWrite" {
    Properties{
        _Color("Main Color", Color) = (1,1,1,1)
        _MainTex("Base (RGB) Trans (A)", 2D) = "white" {}
    }</p>
<div class="code"><pre class="code literal-block"><span class="n">SubShader</span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">Tags</span><span class="p">{</span><span class="w"> </span><span class="s2">"Queue"</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Transparent"</span><span class="w"> </span><span class="s2">"IgnoreProjector"</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"True"</span><span class="w"> </span><span class="s2">"RenderType"</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Transparent"</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">LOD</span><span class="w"> </span><span class="mi">200</span><span class="w"></span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">paste</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">forward</span><span class="w"> </span><span class="n">rendering</span><span class="w"> </span><span class="n">passes</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">Transparent</span><span class="o">/</span><span class="n">Diffuse</span><span class="w"></span>
<span class="w">    </span><span class="o">//</span><span class="n">UsePass</span><span class="w"> </span><span class="s2">"Legacy Shaders/Transparent/Diffuse/FORWARD"</span><span class="w"></span>

<span class="w">    </span><span class="n">Pass</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Name</span><span class="w"> </span><span class="s2">"FORWARD"</span><span class="w"></span>
<span class="w">        </span><span class="n">Tags</span><span class="p">{</span><span class="w"> </span><span class="s2">"LightMode"</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"ForwardBase"</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">ZWrite</span><span class="w"> </span><span class="n">On</span><span class="w"></span>
<span class="w">        </span><span class="n">ColorMask</span><span class="w"> </span><span class="n">RGB</span><span class="w"></span>
<span class="w">        </span><span class="n">Blend</span><span class="w"> </span><span class="n">SrcAlpha</span><span class="w"> </span><span class="n">OneMinusSrcAlpha</span><span class="w"></span>

<span class="w">        </span><span class="n">CGPROGRAM</span><span class="w"></span>
<span class="w">        </span><span class="c1">#pragma target 2.0</span><span class="w"></span>

<span class="w">        </span><span class="c1">#pragma skip_variants SHADOWS_SOFT DIRLIGHTMAP_COMBINED DIRLIGHTMAP_SEPARATE</span><span class="w"></span>

<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="err">これは要るっぽい</span><span class="w"></span>
<span class="w">        </span><span class="c1">#pragma multi_compile_fwdbase</span><span class="w"></span>
<span class="w">        </span><span class="c1">#pragma multi_compile_fog</span><span class="w"></span>

<span class="w">        </span><span class="c1">#pragma vertex vertBase</span><span class="w"></span>
<span class="w">        </span><span class="c1">#pragma fragment fragBase</span><span class="w"></span>

<span class="w">        </span><span class="c1">#include "TransparentDiffuseWithZwrite_FORWARD.cginc"</span><span class="w"></span>
<span class="w">        </span><span class="n">ENDCG</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">SubShader</span><span class="w"></span>

<span class="o">//</span><span class="n">Fallback</span><span class="w"> </span><span class="s2">"Transparent/VertexLit"</span><span class="w"></span>
</pre></div>

<p>}</p>
<p>よし、スクラッチでシェーダーを書こうw
multi_compile_fwdbase
FrameDebuggerで見たところシェーダーのdefineがまとめて変わっていた。LIGHTMAP_OFF等に依存していると影響がある。
まとめてmulti_compileを定義しているだけっぽい。
まとめ</p>
<p>surfaceシェーダーでは無い(shaderのinspectorにも書いてあった)
UsePassでsurfaceシェーダーのPASSを指定することもできる
それ故大変分かりにくい(可読性とコード量とのトレードオフが大きい)
surfaceシェーダーも何らかの形でvertexとfragmentを含むPassの集合に展開されている(どう展開されるのか知りたいんだけど)</p>

<hr>
<ul class="pager hidden-print">
<li class="previous">
        <a href="../../../../2015/12/30/unity_webgl/" rel="prev" title="Unity5.3でWebGL">
            Unity5.3でWebGL 👈
        </a>
    </li>
    <li style="flex-grow: 1">
    <li class="next">
        <a href="../../11/unity_write_shader/" rel="next" title="UnityのShaderを書いてみる">
            👉 UnityのShaderを書いてみる
        </a>
    </li>
</ul></main><footer id="footer"><p>
            Powered by
            <a href="https://getnikola.com" rel="nofollow">Nikola</a>
        </p>
    </footer>
</body>
</html>
