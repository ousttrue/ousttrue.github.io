<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>三次元日誌</title>

    

  <script src="https://ousttrue.github.io/plugins/elasticlunr.min.js" defer></script>
  <script src="https://ousttrue.github.io/search_index.en.js" defer></script>
  <script src="https://ousttrue.github.io/js/search.js" defer></script>

    

     
    <link rel="stylesheet" href="https://ousttrue.github.io/main.css">
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css"
      />
    
  </head>

  <body class="container">
    <a class="site_title" href="https:&#x2F;&#x2F;ousttrue.github.io&#x2F;">
      <div>三次元日誌</div>
    </a>

    <nav class="nav">
      <a class="item" href="/tags/">tags</a>
      <a class="item" href="https://github.com/ousttrue" aria-label="github">
        <i class="fab fa-github fa-lg"></i>
      </a>
      

        
            <form class="navbar-form">
                <input id="userinput" class="form-control is-search" type="search" placeholder="Search docs..."
                    aria-label="Search docs..." autocomplete="off">
                <div id="suggestions" class="shadow bg-white rounded"></div>
            </form>
        
    </nav>

    <main class="main">
<div class="page">
<div class="content">
  <div class="headline">
  
  

  
  <a class="headline_title" href="https:&#x2F;&#x2F;ousttrue.github.io&#x2F;posts&#x2F;2016&#x2F;01&#x2F;11&#x2F;unity-write-shader&#x2F;"> UnityのShaderを書いてみる 
  

  
  </a>

  

  <div>
    <ul class="tags">
      <li class="headline_date">
        <div class="year">2016</div>
        <div class="md">0111</div>
      </li>
      
      


    <li class="tag"><a href="https:&#x2F;&#x2F;ousttrue.github.io&#x2F;tags&#x2F;unity&#x2F;">unity</a></li>




    </ul>
  </div>
</div>
 <p>アルファブレンディング
シャドウキャスター
シャドウレシーバー</p>
<p>なシェーダー。</p>
<p>基本
新規作成
Create -&gt; Shader -&gt; UnLitShader
CustomShader</p>
<p>Shader &quot;CustomShader&quot;
{
Properties
{
_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
}
SubShader
{
Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
LOD 100</p>
<pre style="background-color:#2b303b;">
<code>    Pass
    {
        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        // make fog work
        #pragma multi_compile_fog
        
        #include &quot;UnityCG.cginc&quot;

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float2 uv : TEXCOORD0;
            UNITY_FOG_COORDS(1)
            float4 vertex : SV_POSITION;
        };

        sampler2D _MainTex;
        float4 _MainTex_ST;
        
        v2f vert (appdata v)
        {
            v2f o;
            o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);
            o.uv = TRANSFORM_TEX(v.uv, _MainTex);
            UNITY_TRANSFER_FOG(o,o.vertex);
            return o;
        }
        
        fixed4 frag (v2f i) : SV_Target
        {
            // sample the texture
            fixed4 col = tex2D(_MainTex, i.uv);
            // apply fog
            UNITY_APPLY_FOG(i.fogCoord, col);
            return col;
        }
        ENDCG
    }
}
</code></pre>
<p>}</p>
<p>この時点でテクスチャが表示できるけど一度無にしよう
Shader &quot;CustomShader&quot;
{
SubShader
{
Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
LOD 100
Pass
{
CGPROGRAM
#pragma vertex vert
#pragma fragment frag
float4 vert(float4 v:POSITION) : SV_POSITION{
return mul(UNITY_MATRIX_MVP, v);
}
fixed4 frag() : COLOR{
return fixed4(1.0,0.0,0.0,1.0);
}
ENDCG
}
}
}</p>
<p>頂点変形だけを適用して赤一色。
Color
べたにマテリアル色が出る。
Shader &quot;CustomShader&quot;
{
Properties
{
_Color(&quot;Color&quot;, Color) = (1,1,1,1)
}
SubShader
{
Tags{ &quot;RenderType&quot; = &quot;Opaque&quot; }
LOD 100</p>
<pre style="background-color:#2b303b;">
<code>Pass
{
    CGPROGRAM
</code></pre>
<p>#pragma target 3.0
#pragma vertex vert
#pragma fragment frag</p>
<pre style="background-color:#2b303b;">
<code>    uniform float4 _Color;

    float4 vert(float4 v:POSITION) : SV_POSITION{
        return mul(UNITY_MATRIX_MVP, v);
    }
    fixed4 frag() : COLOR{
        return _Color;
    }
    ENDCG
}

} // SurShader
</code></pre>
<p>}</p>
<p>_Colorプロパティを定義して、uniform変数_Colorを宣言し使う。
Texture
テクスチャ色を乗算
Shader &quot;CustomShader&quot;
{
Properties
{
_Color(&quot;Color&quot;, Color) = (1,1,1,1)
_MainTex(&quot;Base (RGB) Trans (A)&quot;, 2D) = &quot;white&quot; {}
}
SubShader
{
Tags{ &quot;RenderType&quot; = &quot;Opaque&quot; }
LOD 100</p>
<pre style="background-color:#2b303b;">
<code>Pass
{
    CGPROGRAM
</code></pre>
<p>#pragma target 3.0
#pragma vertex vert
#pragma fragment frag</p>
<pre style="background-color:#2b303b;">
<code>    struct appdata
    {
        float4 vertex : POSITION;
        float2 uv : TEXCOORD0;
    };
    struct v2f
    {
        float2 uv : TEXCOORD0;
        float4 vertex : SV_POSITION;
    };

    uniform float4 _Color;
    uniform sampler2D _MainTex;

    v2f vert(appdata v){
        v2f o;
        o.vertex= mul(UNITY_MATRIX_MVP, v.vertex);
        o.uv = v.uv;
        return o;
    }
    fixed4 frag(v2f i) : COLOR{
        fixed4 tex = tex2D(_MainTex, i.uv);
        return _Color * tex;
    }
    ENDCG
}

} // SurShader
</code></pre>
<p>}</p>
<p>シェーダーの入力に位置とUV、出力に変換済みの位置とUVが必要になったので構造体appdataとv2fを導入
_MainTexプロパティを導入し、サンプラー_MainTexを宣言してtex2D関数で使う</p>
<p>AlphaBlending
追加分
Shader &quot;CustomShader&quot;
{
SubShader
{
// 背景を含む不透明なものの後で描画する
Tags{ &quot;Queue&quot; = &quot;Transparent&quot; }</p>
<pre style="background-color:#2b303b;">
<code>Pass
{
    Blend SrcAlpha OneMinusSrcAlpha
}

} // SurShader
</code></pre>
<p>}</p>
<p>ここまでで照明の無い基本的なシェーダーができる。
UnityCG.cgincを使う
最初に新規作成したShaderにAplhaBlendingを追加した感じ。
uniform変数のuniformは省略できる。
Shader &quot;CustomShader&quot;
{
Properties
{
_Color(&quot;Color&quot;, Color) = (1,1,1,1)
_MainTex(&quot;Base (RGB) Trans (A)&quot;, 2D) = &quot;white&quot; {}
}
SubShader
{
Tags{ &quot;Queue&quot; = &quot;Transparent&quot; }
LOD 100</p>
<pre style="background-color:#2b303b;">
<code>Pass
{
    Blend SrcAlpha OneMinusSrcAlpha

    CGPROGRAM
    #pragma target 3.0
    #pragma vertex vert
    #pragma fragment frag

    // make fog work
    #pragma multi_compile_fog

    #include &quot;UnityCG.cginc&quot;

    struct appdata
    {
        float4 vertex : POSITION;
        float2 uv : TEXCOORD0;
    };

    struct v2f
    {
        float2 uv : TEXCOORD0;
        UNITY_FOG_COORDS(1)
        float4 vertex : SV_POSITION;
    };

    float4 _Color;
    sampler2D _MainTex;
    float4 _MainTex_ST;

    v2f vert(appdata v)
    {
        v2f o;
        o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);
        o.uv = TRANSFORM_TEX(v.uv, _MainTex);
        UNITY_TRANSFER_FOG(o,o.vertex);
        return o;
    }

    fixed4 frag(v2f i) : SV_Target
    {
        // sample the texture
        fixed4 col = tex2D(_MainTex, i.uv);
        // apply fog
        UNITY_APPLY_FOG(i.fogCoord, col);
        return col * _Color;
    }
    ENDCG
}

} // SurShader
</code></pre>
<p>}</p>
<p>Lighting導入
Vertex and Fragment Shader Examplesの後半Calculating Lighting
を参考にライティングをやってみる。
forward rendringを使うことで</p>
<p>DirectionalLight
ambient
lightmap
reflections</p>
<p>を扱える。
Tags {&quot;LightMode&quot;=&quot;ForwardBase&quot;}</p>
<p>を定義することでUnityの組み込み変数を通じて上記のシーンのライティング情報を得ることができるようになる。
頂点ライティングによるDiffuse &amp; Ambient</p>
<p>DirectionalLightによるDiffuse計算
appdata_base導入(UnityCG.cgincで定義)
v2fにdiffuse追加
vertでdiffuse計算</p>
<p>Shader &quot;CustomShader&quot;
{
Properties
{
_Color(&quot;Color&quot;, Color) = (1,1,1,1)
_MainTex(&quot;Base (RGB) Trans (A)&quot;, 2D) = &quot;white&quot; {}
}
SubShader
{
Tags{ &quot;Queue&quot; = &quot;Transparent&quot; }
LOD 100</p>
<pre style="background-color:#2b303b;">
<code>Pass
{
    Tags{ &quot;LightMode&quot; = &quot;ForwardBase&quot; }

    Blend SrcAlpha OneMinusSrcAlpha

    CGPROGRAM
    #pragma target 3.0
    #pragma vertex vert
    #pragma fragment frag

    // make fog work
    #pragma multi_compile_fog

    #include &quot;UnityCG.cginc&quot;
    #include &quot;UnityLightingCommon.cginc&quot; // for _LightColor0

    struct v2f
    {
        float2 uv : TEXCOORD0;
        fixed4 diffuse : COLOR0; // diffuse lighting color
        float4 vertex : SV_POSITION;
        UNITY_FOG_COORDS(1)
    };

    uniform float4 _Color;
    uniform sampler2D _MainTex;
    float4 _MainTex_ST;

    v2f vert(appdata_base v)
    {
        v2f o;
        o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);
        o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);

        // get vertex normal in world space
        half3 worldNormal = UnityObjectToWorldNormal(v.normal);
        // dot product between normal and light direction for
        // standard diffuse (Lambert) lighting
        half nl = max(0, dot(worldNormal, _WorldSpaceLightPos0.xyz));
        // factor in the light color
        o.diffuse = nl * _LightColor0;
        
        // the only difference from previous shader:
        // in addition to the diffuse lighting from the main light,
        // add illumination from ambient or light probes
        // ShadeSH9 function from UnityCG.cginc evaluates it,
        // using world space normal
        o.diffuse.rgb += ShadeSH9(half4(worldNormal,1));            

        UNITY_TRANSFER_FOG(o,o.vertex);
        return o;
    }

    fixed4 frag(v2f i) : SV_Target
    {
        // sample the texture
        fixed4 col = tex2D(_MainTex, i.uv) * _Color;
        // apply fog
        UNITY_APPLY_FOG(i.fogCoord, col);
        col.rgb *= i.diffuse;
        return col;
    }
    ENDCG
}

} // SurShader
</code></pre>
<p>}</p>
<p>Shadowキャスティング
ShadowMapに深度を描画するPassを追加する。
簡単なのは下記。
// pull in shadow caster from VertexLit built-in shader
UsePass &quot;Legacy Shaders/VertexLit/SHADOWCASTER&quot;</p>
<p>手作りもできる。</p>
<p>pragma multi_compile_shadowcasterがポイント</p>
<pre style="background-color:#2b303b;">
<code>// shadow caster rendering pass, implemented manually
// using macros from UnityCG.cginc
Pass
{
    Tags{ &quot;LightMode&quot; = &quot;ShadowCaster&quot; }

    CGPROGRAM
    #pragma vertex vert
    #pragma fragment frag
    #pragma multi_compile_shadowcaster
    #include &quot;UnityCG.cginc&quot;

    struct v2f {
        V2F_SHADOW_CASTER;
    };

    v2f vert(appdata_base v)
    {
        v2f o;
        TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
            return o;
    }

    float4 frag(v2f i) : SV_Target
    {
        SHADOW_CASTER_FRAGMENT(i)
    }
    ENDCG
}
</code></pre>
<p>ShadowReceiveing</p>
<p>pragma multi_compile_fwdbaseがポイント</p>
<p>Shader &quot;CustomShader&quot;
{
Properties
{
_Color(&quot;Color&quot;, Color) = (1,1,1,1)
_MainTex(&quot;Base (RGB) Trans (A)&quot;, 2D) = &quot;white&quot; {}
}
SubShader
{
Tags{ &quot;Queue&quot; = &quot;Geometry&quot; }
LOD 100</p>
<pre style="background-color:#2b303b;">
<code>Pass
{
    Tags{ &quot;LightMode&quot; = &quot;ForwardBase&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;PerformanceChecks&quot; = &quot;False&quot; }
    ZWrite On
    Blend SrcAlpha OneMinusSrcAlpha

    CGPROGRAM
    #pragma target 3.0
    #pragma vertex vert
    #pragma fragment frag

    // make fog work
    #pragma multi_compile_fog

    #include &quot;UnityCG.cginc&quot;
    #include &quot;UnityLightingCommon.cginc&quot; // for _LightColor0

    // compile shader into multiple variants, with and without shadows
    // (we don't care about any lightmaps yet, so skip these variants)
    #pragma multi_compile_fwdbase nolightmap nodirlightmap nodynlightmap novertexlight
    // shadow helper functions and macros
    #include &quot;AutoLight.cginc&quot;

    struct v2f
    {
        float2 uv : TEXCOORD0;
        float4 pos : SV_POSITION;
        fixed4 diff : COLOR0; // diffuse lighting color
        fixed3 ambient : COLOR1;
        SHADOW_COORDS(1) // put shadows data into TEXCOORD1
        UNITY_FOG_COORDS(1)
    };

    uniform float4 _Color;
    uniform sampler2D _MainTex;
    float4 _MainTex_ST;

    v2f vert(appdata_base v)
    {
        v2f o;
        o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
        o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);

        // get vertex normal in world space
        half3 worldNormal = UnityObjectToWorldNormal(v.normal);
        // dot product between normal and light direction for
        // standard diffuse (Lambert) lighting
        half nl = max(0, dot(worldNormal, _WorldSpaceLightPos0.xyz));
        // factor in the light color
        o.diff = nl * _LightColor0;

        // the only difference from previous shader:
        // in addition to the diffuse lighting from the main light,
        // add illumination from ambient or light probes
        // ShadeSH9 function from UnityCG.cginc evaluates it,
        // using world space normal
        o.ambient = ShadeSH9(half4(worldNormal, 1));

        // compute shadows data
        TRANSFER_SHADOW(o)

        UNITY_TRANSFER_FOG(o,o.vertex);
        return o;
    }

    fixed4 frag(v2f i) : SV_Target
    {
        // sample the texture
        fixed4 col = tex2D(_MainTex, i.uv) * _Color;

        fixed shadow = SHADOW_ATTENUATION(i);

        // darken light's illumination with shadow, keep ambient intact
        fixed3 lighting = i.diff * shadow + i.ambient;
        col.rgb *= lighting;

        // apply fog
        UNITY_APPLY_FOG(i.fogCoord, col);

        return col;
    }
    ENDCG
}

// shadow caster rendering pass, implemented manually
// using macros from UnityCG.cginc
Pass
{
    Tags{ &quot;LightMode&quot; = &quot;ShadowCaster&quot; }

    CGPROGRAM
    #pragma vertex vert
    #pragma fragment frag
    #pragma multi_compile_shadowcaster
    #include &quot;UnityCG.cginc&quot;

    struct v2f {
        V2F_SHADOW_CASTER;
    };

    v2f vert(appdata_base v)
    {
        v2f o;
        TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
            return o;
    }

    float4 frag(v2f i) : SV_Target
    {
        SHADOW_CASTER_FRAGMENT(i)
    }
    ENDCG
}

} // SurShader

Fallback &quot;Transparent/VertexLit&quot;
</code></pre>
<p>}</p>

</div>

<nav class="toc">


</nav>
</div>
</main>

    <footer class="footer">Powered by <a href="https://www.getzola.org/">Zola</a> <a href="https://github.com/ousttrue/zola/tree/custom">custom</a></footer>

  </body>
</html>
