<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="generator" content="Nikola (getnikola.com)">
<meta name="viewport" content="width=device-width">
<script src="../../../../../assets/js/all-nocdn.js"></script><title>UnityでToon | 三次元日誌</title>
<link href="../../../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
</head>
<body>
    <h1 id="brand">
        <a href="../../../../../" title="三次元日誌" rel="home">
            <span id="blog-title">三次元日誌</span>
        </a>
    </h1>

    <nav id="menu"><ul>
<li><a href="../../../../../archive.html">Archives</a></li>
<li><a href="../../../../../categories/index.html">Tags</a></li>
<li><a href="../../../../../rss.xml">RSS feed</a></li>
<li><a href="../../../../../about">About</a></li>
<li><a href="../../../../../books">MemoBooks</a></li>

            
            
            
        </ul></nav><hr>
<main id="content"><h1 class="p-name entry-title" itemprop="headline name">
    <h1 class="p-name entry-title" itemprop="headline name">
    <a href="." class="u-url">UnityでToon
    </a>
</h1>
<ul itemprop="keywords" class="tags">
<li>
        <time datetime="2016-01-12T00:00:00+09:00" title="2016-01-12">2016-01-12</time>
</li>
    <li><a class="tag p-category" href="../../../../../categories/unity/" rel="tag">unity</a></li>
</ul>
</h1>

<p>Toonシェーダーをやってみる。</p>
<p>メニューからインポートすると、
Assets &gt; Import Package &gt; Effects</p>
<p>Assetsが現れる。
Standard Assets/Effects/ToonShading</p>
<p>Toon/Lit
Standard Assets/Effects/ToonShadingのshaderを自分のフォルダにコピーして改造する。</p>
<h2>UsePassを展開して改造準備</h2>
<p>Shader "MyToon/Lit Outline" {
    Properties {
        _Color ("Main Color", Color) = (0.5,0.5,0.5,1)
        _OutlineColor ("Outline Color", Color) = (0,0,0,1)
        _Outline ("Outline width", Range (.002, 0.03)) = .005
        _MainTex ("Base (RGB)", 2D) = "white" {}
        _Ramp ("Toon Ramp (RGB)", 2D) = "gray" {} 
    }</p>
<pre class="code literal-block">SubShader {
    Tags { "RenderType"="Opaque" }
    UsePass "Toon/Lit/FORWARD"
    UsePass "Toon/Basic Outline/OUTLINE"
}

Fallback "Toon/Lit"
</pre>
<p>}</p>
<p>Toon/Litのinspectorの
Surface shader: Show generated code</p>
<p>から該当するFORWARD Passをコピペし、
Toon/Basic OutlineのOUTLINE Passをコピペする。
適当に整理する。
Shader "MyToon/Custom"
{
    Properties
    {
        _Color("Main Color", Color) = (0.5,0.5,0.5,1)
        _MainTex("Base (RGB)", 2D) = "white" {}
        _Ramp("Toon Ramp (RGB)", 2D) = "gray" {}</p>
<pre class="code literal-block">    _OutlineColor("Outline Color", Color) = (0,0,0,1)
    _Outline("Outline width", Range(.002, 0.03)) = .005
}
SubShader
{
    Tags { "RenderType"="Opaque" }
    LOD 100

    // ---- forward rendering base pass:
    Pass{
        Name "FORWARD"
        Tags{ "LightMode" = "ForwardBase" }

        CGPROGRAM
</pre>
<h2>pragma vertex vert_surf</h2>
<h2>pragma fragment frag_surf</h2>
<h2>pragma lighting ToonRamp exclude_path:prepass</h2>
<h2>pragma multi_compile_fog</h2>
<h2>pragma multi_compile_fwdbase</h2>
<h2>include "Custom.cginc"</h2>
<pre class="code literal-block">        <span class="n">ENDCG</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">outline</span>
    <span class="n">Pass</span><span class="p">{</span>
        <span class="n">Name</span> <span class="s">"OUTLINE"</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"Always"</span> <span class="p">}</span>
        <span class="n">Cull</span> <span class="n">Front</span>
        <span class="n">ZWrite</span> <span class="n">On</span>
        <span class="n">ColorMask</span> <span class="n">RGB</span>
        <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>

        <span class="n">CGPROGRAM</span>
</pre>
<h2>pragma vertex vert</h2>
<h2>pragma fragment frag</h2>
<h2>pragma multi_compile_fog</h2>
<h2>pragma multi_compile_fwdbase</h2>
<h2>include "Custom.cginc"</h2>
<pre class="code literal-block">        <span class="n">ENDCG</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">for</span> <span class="n">shadow</span> <span class="n">etc</span><span class="p">...</span>
<span class="n">Fallback</span> <span class="s">"Diffuse"</span>
</pre>
<p>}</p>
<p>*.shaderファイルのインデントが扱いずらいのでcgincと分割して手で整形。
気持ちよくindentできるエディタを見繕う必要があるな・・・
Custom.cginc</p>
<h2>include "HLSLSupport.cginc"</h2>
<h2>include "UnityShaderVariables.cginc"</h2>
<p>// Surface shader code generated based on:
// writes to per-pixel normal: no
// writes to emission: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: no
// needs world space view direction for lighting: no
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: no
// reads from normal: no
// 1 texcoords actually used
//   float2 _MainTex</p>
<h2>define UNITY_PASS_FORWARDBASE</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>include "Lighting.cginc"</h2>
<h2>include "AutoLight.cginc"</h2>
<h2>define INTERNAL_DATA</h2>
<h2>define WorldReflectionVector(data,normal) data.worldRefl</h2>
<h2>define WorldNormalVector(data,normal) normal</h2>
<p>// Original surface shader snippet:</p>
<h2>line 10 ""</h2>
<h2>ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING</h2>
<h2>endif</h2>
<p>//#pragma surface surf ToonRamp</p>
<p>sampler2D _Ramp;</p>
<p>// custom lighting function that uses a texture ramp based
// on angle between light direction and normal
//#pragma lighting ToonRamp exclude_path:prepass
inline half4 LightingToonRamp(SurfaceOutput s, half3 lightDir, half atten)
{</p>
<h2>ifndef USING_DIRECTIONAL_LIGHT</h2>
<pre class="code literal-block">lightDir = normalize(lightDir);
</pre>
<h2>endif</h2>
<pre class="code literal-block"><span class="nv">half</span> <span class="nv">d</span> <span class="o">=</span> <span class="nv">dot</span><span class="ss">(</span><span class="nv">s</span>.<span class="nv">Normal</span>, <span class="nv">lightDir</span><span class="ss">)</span><span class="o">*</span><span class="mi">0</span>.<span class="mi">5</span> <span class="o">+</span> <span class="mi">0</span>.<span class="mi">5</span><span class="c1">;</span>
<span class="nv">half3</span> <span class="nv">ramp</span> <span class="o">=</span> <span class="nv">tex2D</span><span class="ss">(</span><span class="nv">_Ramp</span>, <span class="nv">float2</span><span class="ss">(</span><span class="nv">d</span>, <span class="nv">d</span><span class="ss">))</span>.<span class="nv">rgb</span><span class="c1">;</span>

<span class="nv">half4</span> <span class="nv">c</span><span class="c1">;</span>
<span class="nv">c</span>.<span class="nv">rgb</span> <span class="o">=</span> <span class="nv">s</span>.<span class="nv">Albedo</span> <span class="o">*</span> <span class="nv">_LightColor0</span>.<span class="nv">rgb</span> <span class="o">*</span> <span class="nv">ramp</span> <span class="o">*</span> <span class="ss">(</span><span class="nv">atten</span> <span class="o">*</span> <span class="mi">2</span><span class="ss">)</span><span class="c1">;</span>
<span class="nv">c</span>.<span class="nv">a</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">;</span>
<span class="k">return</span> <span class="nv">c</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>sampler2D _MainTex;
float4 _Color;</p>
<p>struct Input {
    float2 uv_MainTex : TEXCOORD0;
};</p>
<p>void surf(Input IN, inout SurfaceOutput o) {
    half4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
    o.Albedo = c.rgb;
    o.Alpha = c.a;
}</p>
<p>// vertex-to-fragment interpolation data
// no lightmaps:</p>
<h2>ifdef LIGHTMAP_OFF</h2>
<p>struct v2f_surf {
    float4 pos : SV_POSITION;
    float2 pack0 : TEXCOORD0; // _MainTex
    half3 worldNormal : TEXCOORD1;
    fixed3 vlight : TEXCOORD2; // ambient/SH/vertexlights
    SHADOW_COORDS(3)
        UNITY_FOG_COORDS(4)</p>
<h2>if SHADER_TARGET &gt;= 30</h2>
<pre class="code literal-block">    float4 lmap : TEXCOORD5;
</pre>
<h2>endif</h2>
<p>};</p>
<h2>endif</h2>
<p>// with lightmaps:</p>
<h2>ifndef LIGHTMAP_OFF</h2>
<p>struct v2f_surf {
    float4 pos : SV_POSITION;
    float2 pack0 : TEXCOORD0; // _MainTex
    half3 worldNormal : TEXCOORD1;
    float4 lmap : TEXCOORD2;
    SHADOW_COORDS(3)
        UNITY_FOG_COORDS(4)</p>
<h2>ifdef DIRLIGHTMAP_COMBINED</h2>
<pre class="code literal-block">    fixed3 tSpace0 : TEXCOORD5;
fixed3 tSpace1 : TEXCOORD6;
fixed3 tSpace2 : TEXCOORD7;
</pre>
<h2>endif</h2>
<p>};</p>
<h2>endif</h2>
<p>float4 _MainTex_ST;</p>
<p>// vertex shader
v2f_surf vert_surf(appdata_full v) {
    v2f_surf o;
    UNITY_INITIALIZE_OUTPUT(v2f_surf, o);
    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
    o.pack0.xy = TRANSFORM_TEX(v.texcoord, _MainTex);
    float3 worldPos = mul(_Object2World, v.vertex).xyz;
    fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</p>
<h2>if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)</h2>
<pre class="code literal-block">fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
</pre>
<h2>endif</h2>
<h2>if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)</h2>
<pre class="code literal-block">o.tSpace0 = fixed3(worldTangent.x, worldBinormal.x, worldNormal.x);
o.tSpace1 = fixed3(worldTangent.y, worldBinormal.y, worldNormal.y);
o.tSpace2 = fixed3(worldTangent.z, worldBinormal.z, worldNormal.z);
</pre>
<h2>endif</h2>
<pre class="code literal-block">o.worldNormal = worldNormal;
</pre>
<h2>ifndef DYNAMICLIGHTMAP_OFF</h2>
<pre class="code literal-block">o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
</pre>
<h2>endif</h2>
<h2>ifndef LIGHTMAP_OFF</h2>
<pre class="code literal-block">o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
</pre>
<h2>endif</h2>
<pre class="code literal-block">// SH/ambient and vertex lights
</pre>
<h2>ifdef LIGHTMAP_OFF</h2>
<h2>if UNITY_SHOULD_SAMPLE_SH</h2>
<pre class="code literal-block">float3 shlight = ShadeSH9(float4(worldNormal, 1.0));
o.vlight = shlight;
</pre>
<h2>else</h2>
<pre class="code literal-block">o.vlight = 0.0;
</pre>
<h2>endif</h2>
<h2>ifdef VERTEXLIGHT_ON</h2>
<pre class="code literal-block">o.vlight += Shade4PointLights(
        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
        unity_4LightAtten0, worldPos, worldNormal);
</pre>
<h2>endif // VERTEXLIGHT_ON</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span class="nv">TRANSFER_SHADOW</span><span class="ss">(</span><span class="nv">o</span><span class="ss">)</span><span class="c1">; // pass shadow coordinates to pixel shader</span>
<span class="nv">UNITY_TRANSFER_FOG</span><span class="ss">(</span><span class="nv">o</span>, <span class="nv">o</span>.<span class="nv">pos</span><span class="ss">)</span><span class="c1">; // pass fog coordinates to pixel shader</span>
<span class="k">return</span> <span class="nv">o</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target{
    // prepare and unpack data
    Input surfIN;
    UNITY_INITIALIZE_OUTPUT(Input,surfIN);
    surfIN.uv_MainTex.x = 1.0;
    surfIN.uv_MainTex = IN.pack0.xy;
    float3 lightDir = _WorldSpaceLightPos0.xyz;</p>
<h2>ifdef UNITY_COMPILER_HLSL</h2>
<pre class="code literal-block">SurfaceOutput o = (SurfaceOutput)0;
</pre>
<h2>else</h2>
<pre class="code literal-block">SurfaceOutput o;
</pre>
<h2>endif</h2>
<pre class="code literal-block">o.Albedo = 0.0;
o.Emission = 0.0;
o.Specular = 0.0;
o.Alpha = 0.0;
o.Gloss = 0.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = IN.worldNormal;
normalWorldVertex = IN.worldNormal;

// call surface function
surf(surfIN, o);

// compute lighting &amp; shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
    fixed4 c = 0;
</pre>
<h2>ifdef LIGHTMAP_OFF</h2>
<pre class="code literal-block">c.rgb += o.Albedo * IN.vlight;
</pre>
<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block">// lightmaps
</pre>
<h2>ifndef LIGHTMAP_OFF</h2>
<h2>ifdef DIRLIGHTMAP_OFF</h2>
<pre class="code literal-block">// single lightmap
fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);
fixed3 lm = DecodeLightmap(lmtex);
</pre>
<h2>elif DIRLIGHTMAP_COMBINED</h2>
<pre class="code literal-block">// directional lightmaps
fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);
half3 lm = DecodeLightmap(lmtex);
</pre>
<h2>elif DIRLIGHTMAP_SEPARATE</h2>
<pre class="code literal-block">// directional with specular - no support
half4 lmtex = 0;
half3 lm = 0;
</pre>
<h2>endif // DIRLIGHTMAP_OFF</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block">// realtime lighting: call lighting function
</pre>
<h2>ifdef LIGHTMAP_OFF</h2>
<pre class="code literal-block">c += LightingToonRamp(o, lightDir, atten);
</pre>
<h2>else</h2>
<pre class="code literal-block">c.a = o.Alpha;
</pre>
<h2>endif</h2>
<h2>ifndef LIGHTMAP_OFF</h2>
<pre class="code literal-block">// combine lightmaps with realtime shadows
</pre>
<h2>ifdef SHADOWS_SCREEN</h2>
<h2>if defined(UNITY_NO_RGBM)</h2>
<pre class="code literal-block">c.rgb += o.Albedo * min(lm, atten * 2);
</pre>
<h2>else</h2>
<pre class="code literal-block">c.rgb += o.Albedo * max(min(lm,(atten * 2)*lmtex.rgb), lm*atten);
</pre>
<h2>endif</h2>
<h2>else // SHADOWS_SCREEN</h2>
<pre class="code literal-block">c.rgb += o.Albedo * lm;
</pre>
<h2>endif // SHADOWS_SCREEN</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<h2>ifndef DYNAMICLIGHTMAP_OFF</h2>
<pre class="code literal-block">fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);
c.rgb += o.Albedo * DecodeRealtimeLightmap(dynlmtex);
</pre>
<h2>endif</h2>
<pre class="code literal-block"><span class="nv">UNITY_APPLY_FOG</span><span class="ss">(</span><span class="nv">IN</span>.<span class="nv">fogCoord</span>, <span class="nv">c</span><span class="ss">)</span><span class="c1">; // apply fog</span>
<span class="nv">UNITY_OPAQUE_ALPHA</span><span class="ss">(</span><span class="nv">c</span>.<span class="nv">a</span><span class="ss">)</span><span class="c1">;</span>
<span class="k">return</span> <span class="nv">c</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>//////////////////////////////////////////////////////////////////////////////
// outline
//////////////////////////////////////////////////////////////////////////////</p>
<h2>include "UnityCG.cginc"</h2>
<p>struct appdata {
    float4 vertex : POSITION;
    float3 normal : NORMAL;
};</p>
<p>struct v2f {
    float4 pos : SV_POSITION;
    UNITY_FOG_COORDS(0)
        fixed4 color : COLOR;
};</p>
<p>uniform float _Outline;
uniform float4 _OutlineColor;</p>
<p>v2f vert(appdata v) {
    v2f o;
    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</p>
<pre class="code literal-block"><span class="nv">float3</span> <span class="nv">norm</span> <span class="o">=</span> <span class="nv">normalize</span><span class="ss">(</span><span class="nv">mul</span><span class="ss">((</span><span class="nv">float3x3</span><span class="ss">)</span><span class="nv">UNITY_MATRIX_IT_MV</span>, <span class="nv">v</span>.<span class="nv">normal</span><span class="ss">))</span><span class="c1">;</span>
<span class="nv">float2</span> <span class="nv">offset</span> <span class="o">=</span> <span class="nv">TransformViewToProjection</span><span class="ss">(</span><span class="nv">norm</span>.<span class="nv">xy</span><span class="ss">)</span><span class="c1">;</span>

<span class="nv">o</span>.<span class="nv">pos</span>.<span class="nv">xy</span> <span class="o">+=</span> <span class="nv">offset</span> <span class="o">*</span> <span class="nv">o</span>.<span class="nv">pos</span>.<span class="nv">z</span> <span class="o">*</span> <span class="nv">_Outline</span><span class="c1">;</span>
<span class="nv">o</span>.<span class="nv">color</span> <span class="o">=</span> <span class="nv">_OutlineColor</span><span class="c1">;</span>
<span class="nv">UNITY_TRANSFER_FOG</span><span class="ss">(</span><span class="nv">o</span>, <span class="nv">o</span>.<span class="nv">pos</span><span class="ss">)</span><span class="c1">;</span>
<span class="k">return</span> <span class="nv">o</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>fixed4 frag(v2f i) : SV_Target
{
    UNITY_APPLY_FOG(i.fogCoord, i.color);
    return i.color;
}</p>
<p>改造準備完了。
改造した</p>
<p>alpha blending
影と陰の合成とRampの適用法を改造</p>
<p>なかなか難しい。
顔は別光源にして影が落ちないようにする必要があるね。
顔にDiffuseは必要ない。</p>
<h2>include "HLSLSupport.cginc"</h2>
<h2>include "UnityShaderVariables.cginc"</h2>
<p>// Surface shader code generated based on:
// writes to per-pixel normal: no
// writes to emission: no
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: no
// needs world space view direction for lighting: no
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: no
// reads from normal: no
// 1 texcoords actually used
//   float2 _MainTex</p>
<h2>define UNITY_PASS_FORWARDBASE</h2>
<h2>include "UnityCG.cginc"</h2>
<h2>include "Lighting.cginc"</h2>
<h2>include "AutoLight.cginc"</h2>
<h2>define INTERNAL_DATA</h2>
<h2>define WorldReflectionVector(data,normal) data.worldRefl</h2>
<h2>define WorldNormalVector(data,normal) normal</h2>
<p>// Original surface shader snippet:</p>
<h2>line 10 ""</h2>
<h2>ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING</h2>
<h2>endif</h2>
<p>//#pragma surface surf ToonRamp</p>
<p>sampler2D _Ramp;</p>
<p>// custom lighting function that uses a texture ramp based
// on angle between light direction and normal
//#pragma lighting ToonRamp exclude_path:prepass
inline half3 LightingToonRamp(half3 rgb, half diffuse, half atten)
{
    float d = min(diffuse, atten);
    float3 ramp = tex2D(_Ramp, float2(d, d));
    return rgb * ramp;
}</p>
<p>sampler2D _MainTex;
float4 _Color;</p>
<p>struct Input {
    float2 uv_MainTex : TEXCOORD0;
};</p>
<p>void surf(Input IN, inout SurfaceOutput o) {
    half4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
    o.Albedo = c.rgb;
    o.Alpha = c.a;
}</p>
<p>// vertex-to-fragment interpolation data
// no lightmaps:</p>
<h2>ifdef LIGHTMAP_OFF</h2>
<p>struct v2f_surf {
    float4 pos : SV_POSITION;
    float2 pack0 : TEXCOORD0; // _MainTex
    half3 worldNormal : TEXCOORD1;
    fixed3 vlight : TEXCOORD2; // ambient/SH/vertexlights
    SHADOW_COORDS(3)
        UNITY_FOG_COORDS(4)</p>
<h2>if SHADER_TARGET &gt;= 30</h2>
<pre class="code literal-block">    float4 lmap : TEXCOORD5;
</pre>
<h2>endif</h2>
<p>};</p>
<h2>endif</h2>
<p>// with lightmaps:</p>
<h2>ifndef LIGHTMAP_OFF</h2>
<p>struct v2f_surf {
    float4 pos : SV_POSITION;
    float2 pack0 : TEXCOORD0; // _MainTex
    half3 worldNormal : TEXCOORD1;
    float4 lmap : TEXCOORD2;
    SHADOW_COORDS(3)
        UNITY_FOG_COORDS(4)</p>
<h2>ifdef DIRLIGHTMAP_COMBINED</h2>
<pre class="code literal-block">    fixed3 tSpace0 : TEXCOORD5;
fixed3 tSpace1 : TEXCOORD6;
fixed3 tSpace2 : TEXCOORD7;
</pre>
<h2>endif</h2>
<p>};</p>
<h2>endif</h2>
<p>float4 _MainTex_ST;</p>
<p>// vertex shader
v2f_surf vert_surf(appdata_full v) {
    v2f_surf o;
    UNITY_INITIALIZE_OUTPUT(v2f_surf, o);
    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
    o.pack0.xy = TRANSFORM_TEX(v.texcoord, _MainTex);
    float3 worldPos = mul(_Object2World, v.vertex).xyz;
    fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</p>
<h2>if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)</h2>
<pre class="code literal-block">fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
</pre>
<h2>endif</h2>
<h2>if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)</h2>
<pre class="code literal-block">o.tSpace0 = fixed3(worldTangent.x, worldBinormal.x, worldNormal.x);
o.tSpace1 = fixed3(worldTangent.y, worldBinormal.y, worldNormal.y);
o.tSpace2 = fixed3(worldTangent.z, worldBinormal.z, worldNormal.z);
</pre>
<h2>endif</h2>
<pre class="code literal-block">o.worldNormal = worldNormal;
</pre>
<h2>ifndef DYNAMICLIGHTMAP_OFF</h2>
<pre class="code literal-block">o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
</pre>
<h2>endif</h2>
<h2>ifndef LIGHTMAP_OFF</h2>
<pre class="code literal-block">o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
</pre>
<h2>endif</h2>
<pre class="code literal-block">// SH/ambient and vertex lights
</pre>
<h2>ifdef LIGHTMAP_OFF</h2>
<h2>if UNITY_SHOULD_SAMPLE_SH</h2>
<pre class="code literal-block">float3 shlight = ShadeSH9(float4(worldNormal, 1.0));
o.vlight = shlight;
</pre>
<h2>else</h2>
<pre class="code literal-block">o.vlight = 0.0;
</pre>
<h2>endif</h2>
<h2>ifdef VERTEXLIGHT_ON</h2>
<pre class="code literal-block">o.vlight += Shade4PointLights(
        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
        unity_4LightAtten0, worldPos, worldNormal);
</pre>
<h2>endif // VERTEXLIGHT_ON</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span class="nv">TRANSFER_SHADOW</span><span class="ss">(</span><span class="nv">o</span><span class="ss">)</span><span class="c1">; // pass shadow coordinates to pixel shader</span>
<span class="nv">UNITY_TRANSFER_FOG</span><span class="ss">(</span><span class="nv">o</span>, <span class="nv">o</span>.<span class="nv">pos</span><span class="ss">)</span><span class="c1">; // pass fog coordinates to pixel shader</span>
<span class="k">return</span> <span class="nv">o</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target{
    // prepare and unpack data
    Input surfIN;
    UNITY_INITIALIZE_OUTPUT(Input,surfIN);
    surfIN.uv_MainTex.x = 1.0;
    surfIN.uv_MainTex = IN.pack0.xy;
    float3 lightDir = _WorldSpaceLightPos0.xyz;</p>
<h2>ifdef UNITY_COMPILER_HLSL</h2>
<pre class="code literal-block">SurfaceOutput o = (SurfaceOutput)0;
</pre>
<h2>else</h2>
<pre class="code literal-block">SurfaceOutput o;
</pre>
<h2>endif</h2>
<pre class="code literal-block">o.Albedo = 0.0;
o.Emission = 0.0;
o.Specular = 0.0;
o.Alpha = 0.0;
o.Gloss = 0.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = IN.worldNormal;
normalWorldVertex = IN.worldNormal;

// call surface function
surf(surfIN, o);

// compute lighting &amp; shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
    fixed4 c = 0;
</pre>
<h2>ifdef LIGHTMAP_OFF</h2>
<pre class="code literal-block">c.rgb += o.Albedo * IN.vlight;
</pre>
<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block">// lightmaps
</pre>
<h2>ifndef LIGHTMAP_OFF</h2>
<h2>ifdef DIRLIGHTMAP_OFF</h2>
<pre class="code literal-block">// single lightmap
fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);
fixed3 lm = DecodeLightmap(lmtex);
</pre>
<h2>elif DIRLIGHTMAP_COMBINED</h2>
<pre class="code literal-block">// directional lightmaps
fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);
half3 lm = DecodeLightmap(lmtex);
</pre>
<h2>elif DIRLIGHTMAP_SEPARATE</h2>
<pre class="code literal-block">// directional with specular - no support
half4 lmtex = 0;
half3 lm = 0;
</pre>
<h2>endif // DIRLIGHTMAP_OFF</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<pre class="code literal-block"><span class="o">//</span> <span class="nt">realtime</span> <span class="nt">lighting</span><span class="o">:</span> <span class="nt">call</span> <span class="nt">lighting</span> <span class="nt">function</span>
<span class="nt">c</span><span class="p">.</span><span class="nc">a</span> <span class="o">=</span> <span class="nt">o</span><span class="p">.</span><span class="nc">Alpha</span><span class="o">;</span>
</pre>
<h2>ifdef LIGHTMAP_OFF</h2>
<h2>ifndef USING_DIRECTIONAL_LIGHT</h2>
<pre class="code literal-block">lightDir = normalize(lightDir);
</pre>
<h2>endif</h2>
<pre class="code literal-block">half diffuse = max(0, dot(o.Normal, lightDir));
c.rgb += LightingToonRamp(o.Albedo, diffuse, atten);
</pre>
<h2>else</h2>
<pre class="code literal-block">// combine lightmaps with realtime shadows
</pre>
<h2>ifdef SHADOWS_SCREEN</h2>
<h2>if defined(UNITY_NO_RGBM)</h2>
<pre class="code literal-block">c.rgb += o.Albedo * min(lm, atten * 2);
</pre>
<h2>else</h2>
<pre class="code literal-block">c.rgb += o.Albedo * max(min(lm,(atten * 2)*lmtex.rgb), lm*atten);
</pre>
<h2>endif</h2>
<h2>else // SHADOWS_SCREEN</h2>
<pre class="code literal-block">c.rgb += o.Albedo * lm;
</pre>
<h2>endif // SHADOWS_SCREEN</h2>
<h2>endif // LIGHTMAP_OFF</h2>
<h2>ifndef DYNAMICLIGHTMAP_OFF</h2>
<pre class="code literal-block">fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);
c.rgb += o.Albedo * DecodeRealtimeLightmap(dynlmtex);
</pre>
<h2>endif</h2>
<pre class="code literal-block"><span class="nv">UNITY_APPLY_FOG</span><span class="ss">(</span><span class="nv">IN</span>.<span class="nv">fogCoord</span>, <span class="nv">c</span><span class="ss">)</span><span class="c1">; // apply fog</span>

<span class="k">return</span> <span class="nv">c</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>//////////////////////////////////////////////////////////////////////////////
// outline
//////////////////////////////////////////////////////////////////////////////</p>
<h2>include "UnityCG.cginc"</h2>
<p>struct appdata {
    float4 vertex : POSITION;
    float3 normal : NORMAL;
};</p>
<p>struct v2f {
    float4 pos : SV_POSITION;
    UNITY_FOG_COORDS(0)
        fixed4 color : COLOR;
};</p>
<p>uniform float _Outline;
uniform float4 _OutlineColor;</p>
<p>v2f vert(appdata v) {
    v2f o;
    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</p>
<pre class="code literal-block"><span class="nv">float3</span> <span class="nv">norm</span> <span class="o">=</span> <span class="nv">normalize</span><span class="ss">(</span><span class="nv">mul</span><span class="ss">((</span><span class="nv">float3x3</span><span class="ss">)</span><span class="nv">UNITY_MATRIX_IT_MV</span>, <span class="nv">v</span>.<span class="nv">normal</span><span class="ss">))</span><span class="c1">;</span>
<span class="nv">float2</span> <span class="nv">offset</span> <span class="o">=</span> <span class="nv">TransformViewToProjection</span><span class="ss">(</span><span class="nv">norm</span>.<span class="nv">xy</span><span class="ss">)</span><span class="c1">;</span>

<span class="nv">o</span>.<span class="nv">pos</span>.<span class="nv">xy</span> <span class="o">+=</span> <span class="nv">offset</span> <span class="o">*</span> <span class="nv">min</span><span class="ss">(</span><span class="mi">1</span>, <span class="nv">o</span>.<span class="nv">pos</span>.<span class="nv">z</span><span class="ss">)</span> <span class="o">*</span> <span class="nv">_Outline</span><span class="c1">; // 太さ調整</span>
<span class="nv">o</span>.<span class="nv">color</span> <span class="o">=</span> <span class="nv">_OutlineColor</span><span class="c1">;</span>
<span class="nv">UNITY_TRANSFER_FOG</span><span class="ss">(</span><span class="nv">o</span>, <span class="nv">o</span>.<span class="nv">pos</span><span class="ss">)</span><span class="c1">;</span>
<span class="k">return</span> <span class="nv">o</span><span class="c1">;</span>
</pre>
<p>}</p>
<p>fixed4 frag(v2f i) : SV_Target
{
    UNITY_APPLY_FOG(i.fogCoord, i.color);
    return i.color;
}</p>

<hr>
<ul class="pager hidden-print">
<li class="previous">
        <a href="../../11/unity_write_shader/" rel="prev" title="UnityのShaderを書いてみる">
            UnityのShaderを書いてみる 👈
        </a>
    </li>
    <li style="flex-grow: 1">
    <li class="next">
        <a href="../../23/webpack/" rel="next" title="WebPackやってみる">
            👉 WebPackやってみる
        </a>
    </li>
</ul></main><footer id="footer"><p>
            Powered by
            <a href="https://getnikola.com" rel="nofollow">Nikola</a>
        </p>
    </footer>
</body>
</html>
