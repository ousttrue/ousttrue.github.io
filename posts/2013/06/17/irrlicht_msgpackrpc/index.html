<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>IrrlichtにMsgPackRPCを仕込む | 三次元日誌</title>
<link href="../../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ja" href="../../../../../rss.xml">
<link rel="canonical" href="https://ousttrue.github.io/posts/2013/06/17/irrlicht_msgpackrpc/">
<!--[if lt IE 9]><script src="../../../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="ousttrue">
<link rel="prev" href="../../02/gstreamer/" title="Gstreamerを始めてみた" type="text/html">
<link rel="next" href="../../22/irrlicht-vrpn/" title="IrrlichtにVRPNを合体する" type="text/html">
<meta property="og:site_name" content="三次元日誌">
<meta property="og:title" content="IrrlichtにMsgPackRPCを仕込む">
<meta property="og:url" content="https://ousttrue.github.io/posts/2013/06/17/irrlicht_msgpackrpc/">
<meta property="og:description" content="IrrlichtにMsgPackRPCを仕込む
Oculusの通販ステータスが早くもProcessingに変わって届くのが楽しみな今日この頃。
レンダリングエンジンにはIrrlichtを選択したのであるが、
そのままだとシーンを構築するとか諸々の作業がC++直叩きになる。
これだとさすがに大変なのでMsgPackRPCでラップして外部のツールから
操作しようと構想しておったのだが始めてみると早速問">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2013-06-17T00:00:00+09:00">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">本文を読み飛ばす</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href="../../../../../">

            <span id="blog-title">三次元日誌</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav">
<li class="nav-item">
    <a href="index.md" id="sourcelink" class="nav-link">ソース</a>
    </li>


                    
            </ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="../../../../../books" class="nav-link">MemoBooks</a>
                </li>
<li class="nav-item">
<a href="../../../../../archive.html" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="../../../../../categories/index.html" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../../../../rss.xml" class="nav-link">RSS feed</a>
                </li>
<li class="nav-item">
<a href="../../../../../about" class="nav-link">About</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">IrrlichtにMsgPackRPCを仕込む</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    ousttrue
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2013-06-17T00:00:00+09:00" itemprop="datePublished" title="2013-06-17 00:00">2013-06-17 00:00</time></a>
            </p>
            
        <p class="sourceline"><a href="index.md" class="sourcelink">ソース</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>IrrlichtにMsgPackRPCを仕込む
Oculusの通販ステータスが早くもProcessingに変わって届くのが楽しみな今日この頃。
レンダリングエンジンにはIrrlichtを選択したのであるが、
そのままだとシーンを構築するとか諸々の作業がC++直叩きになる。
これだとさすがに大変なのでMsgPackRPCでラップして外部のツールから
操作しようと構想しておったのだが始めてみると早速問題に突き当たった。
オブジェクトを生成してそのメソッドをコールするのにどうすればいいのか。
こういう場合だ。
IMesh *mesh=CreateMesh("miku.pmd");
mesh-&gt;SetPosition(0, 0, 5);</p>
<p>MsgPackRPC経由だと以下のような感じか。</p>
<h2>pythonとかそういうの</h2>
<p>client=msgpac.rpc.client()
mesh=client.call("CreateMesh", "miku.pmd")
client.call("Mesh_SetPosition", mesh, 0, 0, 5)</p>
<p>1つめのCreateMeshはグローバル関数かシングルトン的オブジェクトのメソッド呼び出しになるので特に問題は無い。
2つめはSetPositionのthisとしてmeshを送ってやる必要がある。
ここでmsgpack的にはIMesh<em>をシリアライズ/デシリアライズすることが必要になる。
案１ ポインタを整数値としてキャストすればいいじゃない
template <typename stream>
inline packer<stream>&amp; operator&lt;&lt; (packer<stream>&amp; o, IMesh </stream></stream></typename></em>v)
{
    // ポインタをintにキャスト
    o.pack((int)v);
    return o;
}</p>
<p>inline IMesh <em>v operator&gt;&gt; (object o, IMesh</em> v)
{
    unsigned int p;
    o.convert(&amp;p):</p>
<pre class="code literal-block"><span></span>// intをポインタにキャスト
v=(IMesh*)p;

return v;
</pre>

<p>}</p>
<p>さすがにワイルドすぎる。というかポインタが既に開放されている場合になすすべが無いので没
案２ 適当にユニークなIDを振る
template <typename stream>
inline packer<stream>&amp; operator&lt;&lt; (packer<stream>&amp; o, IMesh *v)
{
    // ポインタのuid値
    o.pack(v-&gt;uid());
    return o;
}</stream></stream></typename></p>
<p>inline IMesh <em>v operator&gt;&gt; (object o, IMesh</em> v)
{
    unsigned int uid;
    o.convert(&amp;uid):</p>
<pre class="code literal-block"><span></span><span class="o">//</span> <span class="nt">uid値からポインタを得る</span>
<span class="nt">v</span><span class="o">=</span><span class="nt">IMesh</span><span class="p">::</span><span class="nd">get_from_uid</span><span class="o">(</span><span class="nt">uid</span><span class="o">);</span>

<span class="nt">return</span> <span class="nt">v</span><span class="o">;</span>
</pre>

<p>}</p>
<p>Irrlichtだと本体側に改造が要るけどこれでいってみるか。
template<typename t>
class IDGenerator
{
    unsigned int m_uid;</typename></p>
<p>public:
    IDGenerator():m_uid(generate_uid())
    {
        m_uid_map.insert(std::make_pair(m_uid, this));
    }</p>
<pre class="code literal-block"><span></span>unsigned int uid()const 
{
    return m_uid;
}
</pre>

<p>////////////////////
// static
////////////////////
private:
    static unsigned int m_next_uid=1;
    static std::hash_map<unsigned int t> m_uid_map;
public:
    static unsigned int generate_uid(){ 
        return m_next_uid++; 
    }</unsigned></p>
<pre class="code literal-block"><span></span>statc T* get_from_uid(unsigned int uid){
    auto found=m_uid_map.find(uid);
    if(found==m_uid_map.end()){
        return 0;
    }
    return found-&gt;second;
}
</pre>

<p>};</p>
<p>// 継承階層のIReferenceCountedの下あたりにこんな感じで介入する予定
class IMesh : public virtual IReferenceCounted, public IDGenerator<imesh>
{
};</imesh></p>
<p>うまくいくかやってみるとしよう。
書いてみた
自由に書いてみたらこうなった。templateクラスのスタティックメンバ変数の書き方を学んだ。
http://d.hatena.ne.jp/higepon/20100803/1280834422
template<typename t>
class IDGenerator
{
    struct Deleter{
        unsigned int m_uid;</typename></p>
<pre class="code literal-block"><span></span>    Deleter(unsigned int uid): m_uid(uid){}
    ~Deleter(){ remove_from_map(m_uid); }
};
Deleter m_deleter;
unsigned int m_uid;
</pre>

<p>public:
    IDGenerator():m_uid(generate_uid()), m_deleter(m_uid)
    {
        s_uid_map[m_uid]=this;
    }</p>
<pre class="code literal-block"><span></span>unsigned int uid()const 
{
    return m_uid;
}

////////////////////
// static
////////////////////
</pre>

<p>private:
    static core::map<unsigned int idgenerator> s_uid_map;
public:
    static unsigned int generate_uid(){ 
        static unsigned int next_uid=1;
        return next_uid++; 
    }</unsigned></p>
<pre class="code literal-block"><span></span>static T* get_from_uid(unsigned int uid){
    return s_uid_map.find(uid);
}

static void remove_from_map(unsigned int uid){
    s_uid_map.remove(uid);
}
</pre>

<p>};
template <typename t> core::map<unsigned int idgenerator>*&gt; IDGenerator<t>::s_uid_map;</t></unsigned></typename></p>
<p>しかし、この設計だとstaticメンバがdll境界を越えて２つ存在してうまくいかない罠があった。没
案3 適当にユニークなIDを振る(非テンプレート)
irr::IReferenceCountedを改造する。
小賢しいtemplateをやめてべたにグローバル変数を隠蔽する方式を導入した。
class IReferenceCounted
{
public:</p>
<pre class="code literal-block"><span></span>//! Constructor.
IReferenceCounted()
    : DebugName(0), ReferenceCounter(1), UID(get_uid())
{
    register_uid(UID, this);
}

u32 uid(){ return UID; }

//! Destructor.
virtual ~IReferenceCounted()
{
    unregister_uid(UID);
}
</pre>

<p>// 省略</p>
<p>};</p>
<h2>include "IDGenerator.h"</h2>
<h2>include "IReferenceCounted.h"</h2>
<h2>include "irrMap.h"</h2>
<p>namespace irr {</p>
<pre class="code literal-block"><span></span><span class="nt">extern</span> <span class="s2">"C"</span> <span class="nt">IRRLICHT_API</span> <span class="nt">u32</span> <span class="nt">get_uid</span><span class="o">()</span>
<span class="p">{</span>
    <span class="err">static</span> <span class="err">u32</span> <span class="err">uid=1</span><span class="p">;</span>
    <span class="err">return</span> <span class="err">uid++</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">static</span> <span class="nt">core</span><span class="p">::</span><span class="nd">map</span><span class="o">&lt;</span><span class="nt">u32</span><span class="o">,</span> <span class="nt">IReferenceCounted</span><span class="o">*&gt;</span> <span class="nt">g_map</span><span class="o">;</span>

<span class="nt">extern</span> <span class="s2">"C"</span> <span class="nt">IRRLICHT_API</span> <span class="nt">void</span> <span class="nt">register_uid</span><span class="o">(</span><span class="nt">u32</span> <span class="nt">uid</span><span class="o">,</span> <span class="nt">IReferenceCounted</span> <span class="o">*</span><span class="nt">p</span><span class="o">)</span>
<span class="p">{</span>
    <span class="err">g_map.set(uid,</span> <span class="err">p)</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">extern</span> <span class="s2">"C"</span> <span class="nt">IRRLICHT_API</span> <span class="nt">void</span> <span class="nt">unregister_uid</span><span class="o">(</span><span class="nt">u32</span> <span class="nt">uid</span><span class="o">)</span>
<span class="p">{</span>
    <span class="err">auto</span> <span class="err">found=g_map.remove(uid)</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">extern</span> <span class="s2">"C"</span> <span class="nt">IRRLICHT_API</span> <span class="nt">IReferenceCounted</span><span class="o">*</span> <span class="nt">get_from_uid</span><span class="o">(</span><span class="nt">u32</span> <span class="nt">uid</span><span class="o">)</span>
<span class="p">{</span>
    <span class="err">auto</span> <span class="err">found=g_map.find(uid)</span><span class="p">;</span>
    <span class="err">if(!found){</span>
        <span class="err">return</span> <span class="err">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nt">return</span> <span class="nt">found-</span><span class="o">&gt;</span><span class="nt">getValue</span><span class="o">();</span>
<span class="err">}</span>
</pre>

<p>}</p>
<p>動作確認できた。
ここまでの作業でMsgPackRPCを使ったIrrlichtエクスポートについて見通しを得ることができた。
PythonやLuaから使えるようにするのと同じような作業でリモートから関数をコールできるようになるのでいい感じだ。
呼び出し側にPythonのMsgPackRPCを使えば違う言語からでも呼び出せるので一石二鳥というもの。
ということで引き続き作業を進める。
MsgPackRPCのリモート呼び出しを利用したシーンエディタを作りながら表示できるものを増やしていく。</p>
</div>
    </div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../../02/gstreamer/" rel="prev" title="Gstreamerを始めてみた">一つ前の記事</a>
            </li>
            <li class="next">
                <a href="../../22/irrlicht-vrpn/" rel="next" title="IrrlichtにVRPNを合体する">次の記事</a>
            </li>
        </ul></nav></aside></article><!--End of body content--><footer id="footer">
            Contents © 2021         <a href="mailto:ousttrue@gmail.com">ousttrue</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="../../../../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
