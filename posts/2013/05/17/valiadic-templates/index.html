<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="generator" content="Nikola (getnikola.com)">
<meta name="viewport" content="width=device-width">
<script src="../../../../../assets/js/all-nocdn.js"></script><title>可変長テンプレート引数 | 三次元日誌</title>
<link href="../../../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
</head>
<body>
    <h1 id="brand">
        <a href="../../../../../" title="三次元日誌" rel="home">
            <span id="blog-title">三次元日誌</span>
        </a>
    </h1>
    <hr>
<main id="content"><h1 class="p-name entry-title" itemprop="headline name">
    <a href="." class="u-url">可変長テンプレート引数</a>
</h1>
<div>
<p>可変長テンプレート引数
引き続きmsgpack-rpc-asioを実装しているのだが、可変長テンプレート引数(valiadic
template)を使うと関数登録のような場合にうまく書けることがわかった。
昨日は関数オブジェクトからstd::functionの型を得るのに下記のようにしていたのだけど、
```c++ // ret template Ret helper0(Ret (F::<em>)(Rest…));
template Ret helper0(Ret (F::</em>)(Rest…) const);
// 1 template A1 helper1(Ret (F::<em>)(A1, Rest…));
template A1 helper1(Ret (F::</em>)(A1, Rest…) const);
// 2 template A2 helper2(Ret (F::<em>)(A1, A2, Rest…));
template A2 helper2(Ret (F::</em>)(A1, A2, Rest…) const);
template void add_handler(F handler, const std::string &amp;method) {
typedef decltype(handler) functor; typedef
decltype(helper0(&amp;functor::operator())) R; typedef
decltype(helper1(&amp;functor::operator())) A1; typedef
decltype(helper2(&amp;functor::operator())) A2;
// register function...
std::function<r a2> func(handler);</r></p>
<p>} 次のように書けた。c++ template void add_handler(F handler,
R(C::*)(A1, A2)const) { // register function… std::function
func(handler); }
template void add_handler(F handler, const std::string &amp;method) {
add_handler(handler, &amp;decltype(handler)::operator()); }
昨日参照させてもらった
<a href="http://d.hatena.ne.jp/osyo-manga/20121205/1354674180">http://d.hatena.ne.jp/osyo-manga/20121205/1354674180</a>
のコードがやっとわかるようになってきた。</p>
<p>上記コードはさらに可変長テンプレート引数で</p>
<p>template void add_handler(F handler, R(C::*)(A…)const) { // register
function… std::function func(handler); }
<code>`と書けるのですごく便利になる。 msgpack-rpcの関数コールバック登録や、luaのような組み込み言語への関数公開の実装が楽になりそうだ。 上記サイトでも取り上げられているが&amp;decltype(functor)::operator()</code>を関数テンプレートの型推論に投げることで
関数オブジェクトから型情報を取れるらしい。
気をよくして各所を可変長テンプレート引数を使うように書き換えたのだが、
致命的な問題を発見。
vc2010はなんと可変長テンプレート引数を未実装だった。
c++0xの機能がわりと入っているのでできると思っていたのに。
msgpack-rpc-asioは、明瞭にvc2010をターゲットにしているので可変長テンプレート引数の使用を断念した。
２引数関数の操作までしか実装していない時点で気付いて良かった。
ライブラリの不足はboost使えば済むが言語機能が無いのは困るな・・・。
vc2012に乗り換えたくなった。</p>
</div>
    </main><footer id="footer"><p>
            Powered by
            <a href="https://getnikola.com" rel="nofollow">Nikola</a>
        </p>
    </footer>
</body>
</html>
