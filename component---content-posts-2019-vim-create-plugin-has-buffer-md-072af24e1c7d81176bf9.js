"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[11],{4039:function(e,n,l){l.r(n);var t=l(1151),a=l(7294);function r(e){const n=Object.assign({p:"p",h2:"h2",ul:"ul",li:"li",h3:"h3",pre:"pre",code:"code",h4:"h4",a:"a"},(0,t.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.p,null,"独自のバッファを持つpluginを作りたい"),"\n",a.createElement(n.h2,null,"BufferList読んでみる"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"https://github.com/vim-scripts/bufferlist.vim/blob/master/plugin/bufferlist.vim"),"\n"),"\n",a.createElement(n.p,null,"273行"),"\n",a.createElement(n.p,null,"この量なら読める。"),"\n",a.createElement(n.h3,null,"インクルードガード"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-vim"},"if exists('g:BufferListLoaded')\n  finish\nendif\nlet g:BufferListLoaded = 1\n")),"\n",a.createElement(n.h3,null,"初期値決め"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-vim"},"\" vimrcで先に値を決められるようにしている？\n\" vimrc より plugin の方が後に実行されるからか？\nif !exists('g:BufferListWidth')\n  let g:BufferListWidth = 20\nendif\n\nif !exists('g:BufferListMaxWidth')\n  let g:BufferListMaxWidth = 40\nendif\n")),"\n",a.createElement(n.h3,null,"BufferList関数"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"__BUFFERLIST__")," という Buffer を専用のバッファとして扱う。"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-vim"},'" toggled the buffer list on/off\nfunction! BufferList()\n  " if we get called and the list is open --\x3e close it\n  if bufexists(bufnr("__BUFFERLIST__"))\n    " 既に開いていたら閉じる\n    exec \':\' . bufnr("__BUFFERLIST__") . \'bwipeout\'\n    return\n  endif\n')),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"bufnr")," でバッファ名からバッファ番号を得て、",a.createElement(n.code,null,"bufexists")," で存在を確認する。\n",a.createElement(n.code,null,"bufnr")," には特別な名前を指定出来て以下のような効果があるようだ。"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-vim"},"  let l:bufcount = bufnr('$')\n  let l:activebuf = bufnr('')\n")),"\n",a.createElement(n.h4,null,"バッファを作る"),"\n",a.createElement(n.p,null,"作ったバッファがアクティブになり、以降の操作対象になる。"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-vim"},"  \" now, create the buffer & set it up\n  exec 'silent! ' . l:width . 'vne __BUFFERLIST__'\n")),"\n",a.createElement(n.h4,null,"色決め"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-vim"},'  " set up syntax highlighting\n  if has("syntax")\n    syn clear\n    syn match BufferNormal /  .*/\n    syn match BufferSelected /> .*/hs=s+1\n    hi def BufferNormal ctermfg=black ctermbg=white\n    hi def BufferSelected ctermfg=white ctermbg=black\n  endif\n')),"\n",a.createElement(n.h4,null,"Buffer構築"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"setlocal nomodifiable")," で編集不可に"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-vim"},'  setlocal modifiable\n  if l:displayedbufs > 0\n    " input the buffer list, delete the trailing newline, & fill with blank lines\n    put! =l:buflist\n    " is there any way to NOT delete into a register? bummer...\n    "norm Gdd$\n    norm GkJ\n    while winheight(0) > line(".")\n      put =l:fill\n    endwhile\n  else\n    let l:i = 0 | while l:i < winheight(0) | let l:i = l:i + 1\n      put! =l:fill\n    endwhile\n    norm 0\n  endif\n  setlocal nomodifiable\n')),"\n",a.createElement(n.h4,null,"操作を設定"),"\n",a.createElement(n.p,null,"バッファローカルに ",a.createElement(n.code,null,"map")," を設定する。\n",a.createElement(n.code,null,"map")," がキーボード・マウス入力へのコールバック設定になっているのか。なるほど。"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-vim"},'  " set up the keymap\n  noremap <silent> <buffer> <CR> :call LoadBuffer()<CR>\n  map <silent> <buffer> q :bwipeout<CR> \n  map <silent> <buffer> j :call BufferListMove("down")<CR>\n  map <silent> <buffer> k :call BufferListMove("up")<CR>\n  map <silent> <buffer> d :call BufferListDeleteBuffer()<CR>\n  map <silent> <buffer> <MouseDown> :call BufferListMove("up")<CR>\n  map <silent> <buffer> <MouseUp> :call BufferListMove("down")<CR>\n  map <silent> <buffer> <LeftDrag> <Nop>\n  map <silent> <buffer> <LeftRelease> :call BufferListMove("mouse")<CR>\n  map <silent> <buffer> <2-LeftMouse> :call BufferListMove("mouse")<CR>\n    \\:call LoadBuffer()<CR>\n  map <silent> <buffer> <Down> j\n  map <silent> <buffer> <Up> k\n')),"\n",a.createElement(n.p,null,"左右への動きを封じてある"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-vim"},"  map <buffer> h <Nop>\n  map <buffer> l <Nop>\n  map <buffer> <Left> <Nop>\n  map <buffer> <Right> <Nop>\n")),"\n",a.createElement(n.p,null,"その他編集系の機能を封じる"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-vim"},"  map <buffer> i <Nop>\n  map <buffer> a <Nop>\n  map <buffer> I <Nop>\n  map <buffer> A <Nop>\n  map <buffer> o <Nop>\n  map <buffer> O <Nop>\n")),"\n",a.createElement(n.p,null,"移動"),"\n",a.createElement(n.pre,null,a.createElement(n.code,null,'  map <silent> <buffer> <Home> :call BufferListMove(1)<CR>\n  map <silent> <buffer> <End> :call BufferListMove(line("$"))<CR>\n')),"\n",a.createElement(n.h2,null,"情報収集"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,":set nomodifiable")," で調べてみた"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"http://tyru.hatenablog.com/entry/20101107/modifiable_and_readonly"),"\n",a.createElement(n.li,null,"https://vimconf.org/2018/slides/Effective_Modern_Vim_scripting_at_vimconf2018_for_PDF.pdf"),"\n",a.createElement(n.li,null,"https://vi.stackexchange.com/questions/17140/how-to-create-a-buffer-like-a-fugitive-temporary-buffer"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,":set buftype=nofile")," が出てきた"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.a,{href:"http://leafcage.hateblo.jp/entry/2013/11/21/083830"},"'nobuflisted' なバッファの作り方")),"\n",a.createElement(n.li,null,"https://vi.stackexchange.com/questions/14832/how-to-create-a-buffer-with-customized-behavior-how-to-create-a-buffer-that-a"),"\n",a.createElement(n.li,null,"http://learnvimscriptthehardway.stevelosh.com/"),"\n"),"\n",a.createElement(n.h2,null,"NERDTree解読"),"\n",a.createElement(n.h3,null,"左側にどうやって ",a.createElement(n.code,null,"split")," して開くのか"),"\n",a.createElement(n.h3,null,"ファイルを選択して開くとき開き先をどうやって決めるのか"),"\n",a.createElement(n.h2,null,"pythonに移植できんやろか"),"\n",a.createElement(n.p,null,"つまり、Pythonでvimから見える関数を定義できれば勝つるのでは。"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"http://candidtim.github.io/vim/2017/08/11/write-vim-plugin-in-python.html"),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"vim.eval")," とかあるな・・・。いけるのでは？"),"\n",a.createElement(n.p,null,"慣れたら全部 ",a.createElement(n.code,null,"vim script")," で書くようになりそうだけど、練習に移植してみよか。"),"\n",a.createElement(n.p,null,"nvimで、"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,":py3 import sys; print(sys.version)")),"\n",a.createElement(n.p,null,"としたら"),"\n",a.createElement(n.p,null,a.createElement(n.code,null,"3.6.8 (tags/v3.6.8:3c6b436a57, Dec 23 2018, 23:31:17) [MSC v.1916 32 bit (Intel)]")),"\n",a.createElement(n.p,null,"と返ってきた。なるほど。"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"[Pythonでvim pluginを書く https://qiita.com/zakuro9715/items/98449dd4c6b9e1d61ef5]"),"\n"))}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)}},1151:function(e,n,l){l.d(n,{ah:function(){return r}});var t=l(7294);const a=t.createContext({});function r(e){const n=t.useContext(a);return t.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);
//# sourceMappingURL=component---content-posts-2019-vim-create-plugin-has-buffer-md-072af24e1c7d81176bf9.js.map