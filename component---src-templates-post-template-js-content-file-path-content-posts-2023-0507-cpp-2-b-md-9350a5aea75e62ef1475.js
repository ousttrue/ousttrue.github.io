"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7334],{1494:function(e,n,t){t.r(n),t.d(n,{default:function(){return d}});var l=t(1151),c=t(7294);function a(e){const n=Object.assign({p:"p",code:"code",h1:"h1",h2:"h2"},(0,l.ah)(),e.components);return c.createElement(c.Fragment,null,c.createElement(n.p,null,"最近、 ",c.createElement(n.code,null,"c++2b")," などの新しいめの機能を試している。\n機能ごとの感想など。\nコンパイラは、 ",c.createElement(n.code,null,"gcc12"),", ",c.createElement(n.code,null,"clang6"),", ",c.createElement(n.code,null,"vc2022")," あたり。"),"\n",c.createElement(n.h1,null,"meson"),"\n",c.createElement(n.p,null,c.createElement(n.code,null,"cpp_std=c++2b")," を指定できない w\n",c.createElement(n.code,null,".local/lib/python3.10/site-packages/mesonbuild/compilers/cpp.py")," を改造する必要があり、\n初手からつまずく。\nなお vc の場合は、 ",c.createElement(n.code,null,"c++latest")," 指定が通るので使えてしまう。\n使いわける必要があって不便。\n",c.createElement(n.code,null,"meson-1.1")," でまだ対応されていなかった。"),"\n",c.createElement(n.h1,null,"std::format(時期尚早)"),"\n",c.createElement(n.p,null,"vc は使えそう。 ",c.createElement(n.code,null,"clang-7?")," に来たら使ってみよう。\n来るまでは stringstream で細々と。"),"\n",c.createElement(n.h1,null,"std::expected"),"\n",c.createElement(n.p,null,"使えなくはないが、 and_then とかが来てなかった。\n",c.createElement(n.code,null,"std::optional")," は、 and_then, or_else, transform 使えそう。"),"\n",c.createElement(n.h2,null,"std::expected と std::optional の使いわけ"),"\n",c.createElement(n.p,null,"失敗しうる処理で、失敗の種類によってエラーハンドリングを分岐させる場合、\nもしくは失敗原因のログが見たい場合に std::expected を使う。\nそれ以外は std::optional で十分。"),"\n",c.createElement(n.h1,null,"concept"),"\n",c.createElement(n.p,null,"使えそう。"),"\n",c.createElement(n.h1,null,"LanguageServer(clangd-16)"),"\n",c.createElement(n.p,null,"ヘッダーに対するフォールバックが c++11 になることがある。\n発生条件が微妙によくわからない。\nあとは concept とか使うとうまく動かなくなりがち。"),"\n",c.createElement(n.h1,null,"charconv"),"\n",c.createElement(n.p,null,"vc は使えそう。\njson のパースとかで float を使いたい。"),"\n",c.createElement(n.h1,null,"module"),"\n",c.createElement(n.p,null,"ちょっと規模が大きくなるとコンパイルを通せなかった。大変そう。"),"\n",c.createElement(n.h1,null,"coawait"),"\n",c.createElement(n.p,null,"あまり試していない。動くっぽい？"),"\n",c.createElement(n.h1,null,"range"),"\n",c.createElement(n.p,null,"あまり試していない。動くっぽい？"),"\n",c.createElement(n.h1,null,"c++20 以前の"),"\n",c.createElement(n.p,null,"std::optional, std::span,\nstd::string_view, std::filesystem, std::u8string, std::u8string_view\nは使ってもよさそう。"),"\n",c.createElement(n.h1,null,"集成型の初期化"),"\n",c.createElement(n.p,null,"win32 や d3d とか、 vulkan, openxr のような API の使い勝手がよくなる。\n自作のちょっとした型の場合でも初期値の指定との合わせ技で、\nコンストラクターよりこっちの方がよさそうと思えることがでてきた。"),"\n",c.createElement(n.h1,null,"関数テンプレートの定数にlambda由来の関数ポインタのアドレスを渡す"),"\n",c.createElement(n.p,null,"vc でできたのだが怪しかった。"))}var r=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?c.createElement(n,e,c.createElement(a,e)):a(e)},m=t(8678),u=t(4160),o=t(8736);const s={code:e=>{let{children:n,className:t}=e;return t?c.createElement(o.Z,{className:t},n):c.createElement("code",null,n)}};function E(e){let{data:n,children:t}=e;const a=n.mdx.frontmatter;return c.createElement(m.Z,null,c.createElement("h1",null,a.title),c.createElement("div",{className:"tags-index"},a.tags&&a.tags.length>0&&a.tags.map((e=>c.createElement(u.rU,{to:"/tags/"+e+"/",itemProp:"url"},c.createElement("button",null,e))))),c.createElement(l.Zo,{components:s},t))}function d(e){return c.createElement(E,e,c.createElement(r,e))}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-content-posts-2023-0507-cpp-2-b-md-9350a5aea75e62ef1475.js.map