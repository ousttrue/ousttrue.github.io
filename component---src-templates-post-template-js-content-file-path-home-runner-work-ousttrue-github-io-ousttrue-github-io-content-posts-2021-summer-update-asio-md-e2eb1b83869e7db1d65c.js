"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5698],{6613:function(e,n,t){t.r(n),t.d(n,{default:function(){return i}});var a=t(1151),l=t(7294);function c(e){const n=Object.assign({p:"p",code:"code",ul:"ul",li:"li",h1:"h1",pre:"pre",h2:"h2",blockquote:"blockquote",a:"a"},(0,a.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.p,null,"非同期ライブラリ ASIO"),"\n",l.createElement(n.p,null,"http://think-async.com/Asio/index.html"),"\n",l.createElement(n.p,null,"の知識を ",l.createElement(n.code,null,"c++20")," 時代にアップデート。"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"https://github.com/chriskohlhoff/talking-async"),"\n"),"\n",l.createElement(n.p,null,"に動画と動画のサンプルコードが有る。"),"\n",l.createElement(n.h1,null,"compiler を最新にする"),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"ASIO_HAS_CO_AWAIT")," が必要でこれが有効になるには新しいコンパイラが必要。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-c++"},"// asio/detail/config.hpp`\n\n// Support the co_await keyword on compilers known to allow it.\n#if !defined(ASIO_HAS_CO_AWAIT)\n# if !defined(ASIO_DISABLE_CO_AWAIT)\n#  if defined(ASIO_MSVC)\n#   if (_MSC_VER >= 1928) && (_MSVC_LANG >= 201705) && !defined(__clang__)\n#    define ASIO_HAS_CO_AWAIT 1\n#   elif (_MSC_FULL_VER >= 190023506)\n#    if defined(_RESUMABLE_FUNCTIONS_SUPPORTED)\n#     define ASIO_HAS_CO_AWAIT 1\n#    endif // defined(_RESUMABLE_FUNCTIONS_SUPPORTED)\n#   endif // (_MSC_FULL_VER >= 190023506)\n#  elif defined(__clang__)\n#   if (__cplusplus >= 201703) && (__cpp_coroutines >= 201703)\n#    if __has_include(<experimental/coroutine>)\n#     define ASIO_HAS_CO_AWAIT 1\n#    endif // __has_include(<experimental/coroutine>)\n#   endif // (__cplusplus >= 201703) && (__cpp_coroutines >= 201703)\n#  elif defined(__GNUC__)\n#   if (__cplusplus >= 201709) && (__cpp_impl_coroutine >= 201902)\n#    if __has_include(<coroutine>)\n#     define ASIO_HAS_CO_AWAIT 1\n#    endif // __has_include(<coroutine>)\n#   endif // (__cplusplus >= 201709) && (__cpp_impl_coroutine >= 201902)\n#  endif // defined(__GNUC__)\n# endif // !defined(ASIO_DISABLE_CO_AWAIT)\n#endif // !defined(ASIO_HAS_CO_AWAIT)\n")),"\n",l.createElement(n.h2,null,"VC2019(20210818最新版いける)"),"\n",l.createElement(n.p,null,"https://devblogs.microsoft.com/cppblog/c-coroutines-in-visual-studio-2019-version-16-8/"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"C++20 coroutines in Visual Studio 2019 version 16.8."),"\n"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.code,null,"16.7.3")," だめ"),"\n",l.createElement(n.li,null,l.createElement(n.code,null,"16.11.1")," 動いた。"),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"# CMakeListx.txt\nset(TARGET_NAME pingpong)\nadd_executable(${TARGET_NAME} main.cpp)\ntarget_link_libraries(${TARGET_NAME} PRIVATE asio)\nset_property(TARGET ${TARGET_NAME} PROPERTY CXX_STANDARD 20) # 必要\ntarget_compile_options(${TARGET_NAME} PUBLIC $<$<C_COMPILER_ID:MSVC>:/await>) # 必要\ntarget_compile_definitions(asio INTERFACE ASIO_DISABLE_STD_COROUTINE) # 必要\n")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"#if defined(ASIO_HAS_STD_COROUTINE)\n# include <coroutine>\n#else // defined(ASIO_HAS_STD_COROUTINE)\n# include <experimental/coroutine>\n#endif // defined(ASIO_HAS_STD_COROUTINE)\n")),"\n",l.createElement(n.h2,null,"LLVM-12(うまくいかず。追加のコマンドライン引数か)"),"\n",l.createElement(n.p,null,"https://clang.llvm.org/cxx_status.html"),"\n",l.createElement(n.p,null,"LLVM-12 だと、"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null," 'C:\\Program Files\\LLVM\\bin\\clang.exe' -v\nclang version 12.0.1\nTarget: x86_64-pc-windows-msvc\nThread model: posix\nInstalledDir: C:\\Program Files\\LLVM\\bin\n")),"\n",l.createElement(n.p,null,"わからん。"),"\n",l.createElement(n.h1,null,"コード"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"#include <asio/awaitable.hpp>\n#include <asio/co_spawn.hpp>\n#include <asio/detached.hpp>\n#include <asio/experimental/as_tuple.hpp>\n#include <asio/io_context.hpp>\n#include <asio/ip/tcp.hpp>\n#include <asio/read.hpp>\n#include <asio/streambuf.hpp>\n#include <asio/system_timer.hpp>\n#include <asio/use_awaitable.hpp>\n#include <asio/use_future.hpp>\n#include <asio/write.hpp>\n")),"\n",l.createElement(n.h2,null,"co_spawn で awaitable を起動する"),"\n",l.createElement(n.p,null,"coroutine は 戻り値の型が ",l.createElement(n.code,null,"asio::awaitable<T>")," である必要がある。この関数の中で ",l.createElement(n.code,null,"co_await"),", ",l.createElement(n.code,null,"co_yield"),", ",l.createElement(n.code,null,"co_return")," が使える。\ncoroutine は lambda でもよいので、下記のようにできる。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},'  auto co = []() -> asio::awaitable<std::string> {\n    co_return "result";\n  };\n  auto result =\n      asio::co_spawn(client_context.get_executor(), co, asio::use_future); // coroutine 登録\n  client_context.run(); // ループを回す\n  auto pong = result.get(); // future から結果を得る\n  std::cout << "pong: " << pong << std::endl;\n')),"\n",l.createElement(n.p,null,"asio::use_future を使うことで返り値 ",l.createElement(n.code,null,"std::future")," になるので ",l.createElement(n.code,null,"co_return")," の値を得ることも可能。\n結果に興味がないときは、",l.createElement(n.code,null,"asio::detached")," でよい。\nCompletion Handler というコールバックなので、 promise に set_value する関数を自前で書いたりしてもよい様子。\n",l.createElement(n.code,null,"asio::use_awaitable")," で ",l.createElement(n.code,null,"co_await")," するのも可能。"),"\n",l.createElement(n.p,null,"返り値が ",l.createElement(n.code,null,"std::tuple<asio::error_code, RESULT>")," になるハンドラ。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"constexpr auto use_nothrow_awaitable =\n    asio::experimental::as_tuple(asio::use_awaitable);\n")),"\n",l.createElement(n.h2,null,"client side"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"timer"),"\n",l.createElement(n.li,null,"connect"),"\n",l.createElement(n.li,null,"send(ping)"),"\n",l.createElement(n.li,null,"receive(pong)"),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},'  auto co = [&context = client_context, ep]() -> asio::awaitable<std::string> {\n    std::cout << "[client]wait 1000ms..." << std::endl;\n    asio::system_timer timer(context);\n    timer.expires_from_now(1000ms);\n    co_await timer.async_wait(asio::use_awaitable);\n\n    std::cout << "[client]connect: " << ep << "..." << std::endl;\n    asio::ip::tcp::socket socket(context);\n    co_await socket.async_connect(ep, asio::use_awaitable);\n    std::cout << "[client]connected" << std::endl;\n\n    std::cout << "[client]ping..." << std::endl;\n    std::string ping("ping");\n    auto write_size = co_await asio::async_write(socket, asio::buffer(ping),\n                                                 asio::use_awaitable);\n    assert(write_size == 4);\n\n    std::cout << "[client]read..." << std::endl;\n    asio::streambuf buf;\n    auto read_size = co_await asio::async_read(\n        socket, buf, asio::transfer_at_least(1), asio::use_awaitable);\n    co_return to_string(buf);\n  };\n')),"\n",l.createElement(n.h2,null,"server side"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},'class server {\n\n  asio::io_context &_context;\n  asio::ip::tcp::acceptor _acceptor;\n\npublic:\n  server(asio::io_context &context) : _context(context), _acceptor(context) {}\n  ~server() {}\n\n  void listen(const asio::ip::tcp::endpoint &ep) {\n    std::cout << "[server]listen: " << ep << "..." << std::endl;\n    _acceptor.open(ep.protocol());\n    _acceptor.bind(ep);\n    _acceptor.listen();\n\n    // coroutineを起動する\n    auto ex = _context.get_executor();\n    asio::co_spawn(ex, accept_loop(), asio::detached);\n  }\n\n  asio::awaitable<void> accept_loop() {\n\n    // 単なるループになって再起が不要に\n    while (true) {\n\n      auto [e, socket] = co_await _acceptor.async_accept(use_nothrow_awaitable);\n      if (e) {\n        std::cout << "[server]accept error: " << e << std::endl;\n        break;\n      }\n      std::cout << "[server]accepted" << std::endl;\n\n      // coroutineを起動する\n      auto ex = _context.get_executor();\n      asio::co_spawn(ex, session(std::move(socket)), asio::detached);\n    }\n  }\n\n  asio::awaitable<void> session(asio::ip::tcp::socket socket) {\n\n    // echo server ぽい ping pong\n    asio::streambuf buf;\n    auto [e1, read_size] = co_await asio::async_read(\n        socket, buf, asio::transfer_at_least(1), use_nothrow_awaitable);\n\n    auto pong = to_string(buf);\n    std::cout << "[server]ping: " << pong << std::endl;\n    pong += "pong";\n    auto [e2, write_size] = co_await asio::async_write(\n        socket, asio::buffer(pong), use_nothrow_awaitable);\n    std::cout << "[server]pong: " << write_size << std::endl;\n  }\n};\n')),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},'  auto ep = asio::ip::tcp::endpoint(asio::ip::address::from_string("127.0.0.1"),\n                                    PORT);\n\n  // server\n  asio::io_context server_context;\n  server server(server_context);\n  server.listen(ep);\n  std::thread server_thread([&server_context]() { server_context.run(); }); // thread でループを回す。\n')),"\n",l.createElement(n.p,null,"ループ(io_context)が隠蔽されていないのが良いですね。"),"\n",l.createElement(n.h1,null,"asio api"),"\n",l.createElement(n.h2,null,"io_context"),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"c++23")," の ",l.createElement(n.code,null,"Networking TS")," に向けた変更？"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://amedama1x1.hatenablog.com/entry/2016/04/05/205340"},"Networking TS の Boost.Asio からの変更点 - その 1: Associated allocator")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://amedama1x1.hatenablog.com/entry/2016/08/20/222326"},"Networking TS の Boost.Asio からの変更点 - その 3: Executor")),"\n"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"io_service は Executor と ExecutionContext という概念に分割されたことで, io_context に名前が変わりました"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"Boost 1.66")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://amedama1x1.hatenablog.com/entry/2017/12/09/102405"},"Networking TS の Boost.Asio からの変更点 - その 4: Associated Executor")),"\n"),"\n",l.createElement(n.p,null,"単純に io_service を io_context に追きかえるだけで動いた。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"#include <asio.hpp>\n\nio_context context;\n\n// 全てのタスクが消化されるまでブロックする。\ncontext.run();\n\n// スレッド上で実行する例\nstd::thread run_thread([&context](){ context.run(); });\n\n// 止める\ncontext.stop();\nrun_thread.join();\n")),"\n",l.createElement(n.h2,null,"endpoint"),"\n",l.createElement(n.p,null,"ipaddress + port"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},'asip::ip::tcp::endpoint ep(asio::ip::address::from_string("127.0.0.1"), 1234);\n')),"\n",l.createElement(n.h2,null,"tcp connect"),"\n",l.createElement(n.p,null,"socket"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"io_context context;\nasio::ip::tcp::socket socket(coontext);\n")),"\n",l.createElement(n.p,null,"basic"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},'void connect(asio::ip::tcp::socket socket, const asio::ip::tcp::endpoint &ep)\n{\n  auto on_connect = [](const asio::error_code &ec)\n  {\n    if(ec)\n    {\n      std::cout << "error: " << ec << std::endl;\n    }\n    else{\n      std::cout << "connected" << std::endl;\n    }\n  };\n  socket.async_connect(ep, on_connect);\n}\n')),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"c++11 future")),"\n",l.createElement(n.p,null,"std::future に対して ",l.createElement(n.code,null,"continue_with")," する手段を用意しないと、これ単体では使いづらい"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"std::future<void> connect_future(asio::ip::tcp::socket socket, const asio::ip::tcp::endpoint &ep)\n{\n  // move するのが大変な場合があるので手抜き\n  auto p = std::make_shared<std::promise<void>>();\n  auto f = p->get_future();\n\n  socket.async_connect(ep, [p](asio::error_code ec){\n    if(ec)\n    {\n    }\n    else{\n      // future value\n      p->set_value();\n    }\n  });\n\n  return f;\n}\n")),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"c++20 coroutine")),"\n",l.createElement(n.p,null,"有望"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"asio::awaitable<void> co(asio::io_context &context, const asio::ip::tcp::endpoint &ep)\n{\n  asio::ip::tcp::socket socket(coontext);\n  co_await socket.async_connect(ep, asio::use_awaitable);\n}\n")),"\n",l.createElement(n.h2,null,"tcp listen"),"\n",l.createElement(n.h2,null,"raed_async"),"\n",l.createElement(n.h2,null,"write_async"),"\n",l.createElement(n.h1,null,"coroutine 詳細"),"\n",l.createElement(n.p,null,"asio の coroutine を学んでいたらできないことが出てきた。"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},'auto result = co_await rpc_call("add", 1, 2);\n')),"\n",l.createElement(n.h1,null,"自前の Awaiter が必要？"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"template<typename R, typename ...AS>\nasio::awaitable<R> rpc_call(const std::string &method, AS... as)\n{\n  asio::io_context context;\n  asio::ip::tcp::socket socket(context);\n\n  asio::ip::tcp::endpoint ep;\n\n  co_await socket.connect_async(ep, asio::use_awaitable);\n\n  // msgpack-rpc\n  std::vector<uint8_t> request = make_request(method, as...);\n  co_await asio::write_async(socket, request, asio::use_awaitable); \n\n  // ここで実行の流れが切れる\n\n  // ?\n  std::promise<R> p;\n  return p.get_future();\n}\n")),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"co_await std::future")," できるぽいが, ",l.createElement(n.code,null,"asio")," と混ぜてうまくいくのだろうか。"),"\n",l.createElement(n.h1,null,"c++20 coroutine"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"https://cpprefjp.github.io/lang/cpp20/coroutines.html"),"\n",l.createElement(n.li,null,"https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html"),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://qiita.com/tan-y/items/ae54153ec3eb42f80638"},"C++ でコルーチン (async/await 準備編)")),"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://qiita.com/tan-y/items/6033ab9e7298999bf214#await_ready"},"C++ で async/await をする")),"\n"),"\n",l.createElement(n.p,null,"内部で ",l.createElement(n.code,null,"co_await"),", ",l.createElement(n.code,null,"co_yield"),", ",l.createElement(n.code,null,"co_return")," の何れかを使う関数は coroutine になる。\n返り値の型から promise_type を得られるようにする必要がある。"),"\n",l.createElement(n.p,null,"初期化は ",l.createElement(n.code,null,"promise_type::get_return_object")," から始まるぽい。"),"\n",l.createElement(n.h2,null,"generator の例"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"struct generator {\n  struct promise_type;\n  using handle = std::coroutine_handle<promise_type>;  \n  struct promise_type {\n    auto get_return_object() { return generator{handle::from_promise(*this)}; }\n  };\n  using handle = std::coroutine_handle<promise_type>;\nprivate:\n  handle coro;\n  generator(handle h) : coro(h) {}\n};\n")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"promise_type promise;\n\n// 戻り値型オブジェクトの初期化\nauto result = promise.get_return_object();\n")),"\n",l.createElement(n.h1,null,"Asio の実装"),"\n",l.createElement(n.h2,null,"asio::awaitable"),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"asio::awaitable<T>")," が CoroutineTrait の実装。"),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"include/asio/awaitable.hpp")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"template <typename T, typename Executor = any_io_executor>\nclass ASIO_NODISCARD awaitable\n{\npublic:\n  /// The type of the awaited value.\n  typedef T value_type;\n\n  /// The executor type that will be used for the coroutine.\n  typedef Executor executor_type;\n\n  /// Default constructor.\n  constexpr awaitable() noexcept\n    : frame_(nullptr)\n  {\n  }\n\n  /// Move constructor.\n  awaitable(awaitable&& other) noexcept\n    : frame_(std::exchange(other.frame_, nullptr))\n  {\n  }\n\n  /// Destructor\n  ~awaitable()\n  {\n    if (frame_)\n      frame_->destroy();\n  }\n\n  /// Checks if the awaitable refers to a future result.\n  bool valid() const noexcept\n  {\n    return !!frame_;\n  }\n\n#if !defined(GENERATING_DOCUMENTATION)\n\n  // Support for co_await keyword.\n  bool await_ready() const noexcept\n  {\n    return false;\n  }\n\n  // Support for co_await keyword.\n  template <class U>\n  void await_suspend(\n      detail::coroutine_handle<detail::awaitable_frame<U, Executor>> h)\n  {\n    frame_->push_frame(&h.promise());\n  }\n\n  // Support for co_await keyword.\n  T await_resume()\n  {\n    return awaitable(static_cast<awaitable&&>(*this)).frame_->get();\n  }\n\n#endif // !defined(GENERATING_DOCUMENTATION)\n\nprivate:\n  template <typename> friend class detail::awaitable_thread;\n  template <typename, typename> friend class detail::awaitable_frame;\n\n  // Not copy constructible or copy assignable.\n  awaitable(const awaitable&) = delete;\n  awaitable& operator=(const awaitable&) = delete;\n\n  // Construct the awaitable from a coroutine's frame object.\n  explicit awaitable(detail::awaitable_frame<T, Executor>* a)\n    : frame_(a)\n  {\n  }\n\n  detail::awaitable_frame<T, Executor>* frame_;\n};\n")),"\n",l.createElement(n.h2,null,"promise_type"),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"include/asio/impl/awaitable.hpp")),"\n",l.createElement(n.p,null,"// promise_type"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"# if defined(ASIO_HAS_STD_COROUTINE)\n\nnamespace std {\n\ntemplate <typename T, typename Executor, typename... Args>\nstruct coroutine_traits<asio::awaitable<T, Executor>, Args...>\n{\n  typedef asio::detail::awaitable_frame<T, Executor> promise_type;\n};\n\n} // namespace std\n\n# else // defined(ASIO_HAS_STD_COROUTINE)\n\nnamespace std { namespace experimental {\n\ntemplate <typename T, typename Executor, typename... Args>\nstruct coroutine_traits<asio::awaitable<T, Executor>, Args...>\n{\n  typedef asio::detail::awaitable_frame<T, Executor> promise_type;\n};\n\n}} // namespace std::experimental\n\n# endif // defined(ASIO_HAS_STD_COROUTINE)\n")),"\n",l.createElement(n.h2,null,"asio::detail::awaitable_frame"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-cpp"},"template <typename Executor>\nclass awaitable_frame<void, Executor>\n  : public awaitable_frame_base<Executor>\n{\npublic:\n  awaitable<void, Executor> get_return_object()\n  {\n    this->coro_ = coroutine_handle<awaitable_frame>::from_promise(*this);\n    return awaitable<void, Executor>(this);\n  };\n\n  void return_void()\n  {\n  }\n\n  void get()\n  {\n    this->caller_ = nullptr;\n    this->rethrow_exception();\n  }\n};\n")))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?l.createElement(n,e,l.createElement(c,e)):c(e)};t(8678);function r(e){let{data:n,children:t}=e;return l.createElement(l.Fragment,null,l.createElement("h1",null,n.mdx.frontmatter.title),l.createElement(a.Zo,null,t))}function i(e){return l.createElement(r,e,l.createElement(o,e))}},8678:function(e,n,t){t(7294)},1151:function(e,n,t){t.d(n,{Zo:function(){return r},ah:function(){return c}});var a=t(7294);const l=a.createContext({});function c(e){const n=a.useContext(l);return a.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const o={};function r({components:e,children:n,disableParentContext:t}){let r;return r=t?"function"==typeof e?e({}):e||o:c(e),a.createElement(l.Provider,{value:r},n)}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2021-summer-update-asio-md-e2eb1b83869e7db1d65c.js.map