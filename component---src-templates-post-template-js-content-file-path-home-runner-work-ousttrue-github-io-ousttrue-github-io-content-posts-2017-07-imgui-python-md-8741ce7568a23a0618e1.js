"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8173],{6677:function(e,n,t){t.r(n),t.d(n,{default:function(){return _}});var i=t(1151),r=t(7294);function o(e){const n=Object.assign({p:"p",pre:"pre",code:"code",h1:"h1"},(0,i.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.p,null,"Python で ImGui するのがよさげな気がしたのでやってみた。"),"\n",r.createElement(n.p,null,"ImGui は c ではなく c++のライブラリなので Python の ctypes は使えぬ。\n本家の Bindings の項に２つの python binding が紹介されている。"),"\n",r.createElement(n.p,null,"https://github.com/chromy/cyimgui\nhttps://github.com/swistakm/pyimgui"),"\n",r.createElement(n.p,null,"なんかうまくいかなった。\nならば swig で自前でラップすればええやんということで、やってみる。"),"\n",r.createElement(n.p,null,"https://github.com/ousttrue/SwigImGui"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,'Swig\n%module swig_imgui\n\n%{\n/* Includes the header in the wrapper code */\n#include "imgui/imgui.h"\n%}\n\n/* Parse the header file to generate wrappers */\n%include "imgui/imgui.h"\n')),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"> swig -python -c++ imgui.i\n")),"\n",r.createElement(n.p,null,"imgui_wrap.cxx と”swig_imgui.py”を生成した。\nimgui_wrap.cxx から_swig_imgui.pyd をビルドする。\nビルドしてみる\npython の NativeModule をビルドするので setup.py を書いてみる。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-python"},"from distutils.core import setup, Extension\n\n\nimgui_module = Extension('_swig_imgui',\n        sources=[\n            'imgui_wrap.cxx',\n            'imgui/imgui.cpp',\n            'imgui/imgui_draw.cpp',\n            'imgui/imgui_demo.cpp',\n            ],\n        )\n\nsetup (name = 'swig_imgeui',\n        version = '0.1',\n        author      = \"ousttrue\",\n        description = \"\"\"imgui wrapper using swig\"\"\",\n        ext_modules = [imgui_module],\n        py_modules = [\"imgui\"],\n        )\n")),"\n",r.createElement(n.p,null,"ビルド。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"> C:\\python36\\python.exe setup.py build\n")),"\n",r.createElement(n.p,null,"ビルドしてみるとエラー。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"swigimgui\\imgui_wrap.cxx(26285): error C2668: 'ImGui::TreePush': オーバーロード関数の呼び出しを解決することができません。(新機能 ; ヘルプを参照)\nswigimgui\\imgui\\imgui.h(338): note: 'void ImGui::TreePush(const void *)' の可能性があります\nswigimgui\\imgui\\imgui.h(337): note: または 'void ImGui::TreePush(const char *)'\nswigimgui\\imgui_wrap.cxx(26285): note: 引数リスト '()' を一致させようとしているとき\n")),"\n",r.createElement(n.p,null,"ImGui::TreePush();が TreePush(const char* str_id = NULL)と TreePush(const void* ptr_id = NULL)でどちらなのか解決できない。\n修正。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,'%module swig_imgui\n\n%{\n/* Includes the header in the wrapper code */\n#include "imgui/imgui.h"\n%}\n\n%ignore ImGui::TreePush();\n\n/* Parse the header file to generate wrappers */\n%include "imgui/imgui.h"\n\n%include "imgui/imgui.h"の前に%ignoreを記述することで、\n')),"\n",r.createElement(n.p,null,"引数無しの TreePush を作らないようにした。\nこれでコンパイルは通った。\npython36_d.lib にリンクしない\npython36_d.lib ではなあく python36.lib にリンクする。\nimgui.i の上の方に以下の記述を追加する。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"%begin %{\n#ifdef \\_MSC_VER\n#define SWIG_PYTHON_INTERPRETER_NO_DEBUG\n#endif\n%}\n")),"\n",r.createElement(n.p,null,"実行してみよう"),"\n",r.createElement(n.p,null,"https://github.com/ocornut/imgui/tree/master/examples/sdl_opengl3_example"),"\n",r.createElement(n.p,null,"をまるっと python に移植してみる。\nここからが長くなるで。"),"\n",r.createElement(n.h1,null,"ImGui - standalone example application for SDL2 + OpenGL"),"\n",r.createElement(n.h1,null,"If you are new to ImGui, see examples/README.txt and documentation at the top of imgui.cpp."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-python"},'import os\nimport sys\n\nif not \'PYSDL2_DLL_PATH\' in os.environ:\nos.environ[\'PYSDL2_DLL_PATH\']=os.environ[\'VCPKG_DIR\'] + \'/installed/x64-windows/bin\'\nfrom sdl2 import \\*\n\npython_dir=os.path.dirname(sys.executable)\nos.environ[\'PATH\']+=(\';\'+python_dir)\nimport swig_imgui as imgui\n\nimport ImplSdlGL3\n\ndef main():\n\n    # Setup SDL\n    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) != 0):\n        print("Error: %s\\n", SDL_GetError());\n        return -1;\n\n    # Setup window\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n    current=SDL_DisplayMode();\n    SDL_GetCurrentDisplayMode(0, current);\n    window = SDL_CreateWindow(b"ImGui SDL2+OpenGL3 example", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1280, 720, SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE);\n    glcontext = SDL_GL_CreateContext(window);\n    #gl3wInit();\n\n    # Setup ImGui binding\n    ImplSdlGL3.Init(window);\n\n    # Load Fonts\n    # (there is a default font, this is only if you want to change it. see extra_fonts/README.txt for more details)\n    #ImGuiIO& io = imgui.GetIO();\n    #io.Fonts->AddFontDefault();\n    #io.Fonts->AddFontFromFileTTF("../../extra_fonts/Cousine-Regular.ttf", 15.0f);\n    #io.Fonts->AddFontFromFileTTF("../../extra_fonts/DroidSans.ttf", 16.0f);\n    #io.Fonts->AddFontFromFileTTF("../../extra_fonts/ProggyClean.ttf", 13.0f);\n    #io.Fonts->AddFontFromFileTTF("../../extra_fonts/ProggyTiny.ttf", 10.0f);\n    #io.Fonts->AddFontFromFileTTF("c:\\\\Windows\\\\Fonts\\\\ArialUni.ttf", 18.0f, NULL, io.Fonts->GetGlyphRangesJapanese());\n\n    show_test_window = True;\n    show_another_window = False;\n    clear_color = [114/255.0, 144/255.0, 154/255.0];\n\n    # Main loop\n    done = False;\n    while not done:\n\n        event=SDL_Event();\n        while SDL_PollEvent(event)!=0:\n\n            ImplSdlGL3.ProcessEvent(event);\n            if event.type == SDL_QUIT:\n                done = true;\n\n        ImplSdlGL3.NewFrame(window);\n\n        # 1. Show a simple window\n        # Tip: if we don\'t call imgui.Begin()/imgui.End() the widgets appears in a window automatically called "Debug"\n\n        f = 0.0;\n        imgui.Text("Hello, world!");\n        imgui.SliderFloat("float", f, 0.0, 1.0);\n        imgui.ColorEdit3("clear color", clear_color);\n        if imgui.Button("Test Window"): show_test_window ^= 1;\n        if imgui.Button("Another Window"): show_another_window ^= 1;\n        imgui.Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0 / imgui.GetIO().Framerate, imgui.GetIO().Framerate);\n\n        # 2. Show another simple window, this time using an explicit Begin/End pair\n        if show_another_window:\n            imgui.SetNextWindowSize(ImVec2(200,100), ImGuiSetCond_FirstUseEver);\n            imgui.Begin("Another Window", show_another_window);\n            imgui.Text("Hello");\n            imgui.End();\n\n        # 3. Show the ImGui test window. Most of the sample code is in imgui.ShowTestWindow()\n        if show_test_window:\n            imgui.SetNextWindowPos(ImVec2(650, 20), ImGuiSetCond_FirstUseEver);\n            imgui.ShowTestWindow(show_test_window);\n\n        # Rendering\n        glViewport(0, 0, int(imgui.GetIO().DisplaySize.x), int(imgui.GetIO().DisplaySize.y));\n        glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w);\n        glClear(GL_COLOR_BUFFER_BIT);\n        imgui.Render();\n        SDL_GL_SwapWindow(window);\n\n    # Cleanup\n    ImplSdlGL3.Shutdown();\n    SDL_GL_DeleteContext(glcontext);\n    SDL_DestroyWindow(window);\n    SDL_Quit();\n\n    return 0;\n\nif **name**==\'**main**\':\nmain()\n\nImplSdlGL3.py\ndef Init(window):\npass\n\ndef ProcessEvent(event):\npass\n\ndef NewFrame(window):\npass\n')),"\n",r.createElement(n.p,null,"pyd のサーチ\n環境変数 PATH\n環境変数 PYSDL2_DLL_PATH\n実行\n諸々、正しく初期化していないのでクラッシュする。\nInit を移植"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-python"},"import swig_imgui as imgui\nfrom sdl2 import \\*\n\ndef Init(window):\nio = imgui.GetIO();\n#io.KeyMap[imgui.ImGuiKey_Tab] = SDLK_TAB;\nio.KeyMap[imgui.ImGuiKey_LeftArrow] = SDL_SCANCODE_LEFT;\nio.KeyMap[imgui.ImGuiKey_RightArrow] = SDL_SCANCODE_RIGHT;\nio.KeyMap[imgui.ImGuiKey_UpArrow] = SDL_SCANCODE_UP;\nio.KeyMap[imgui.ImGuiKey_DownArrow] = SDL_SCANCODE_DOWN;\nio.KeyMap[imgui.ImGuiKey_PageUp] = SDL_SCANCODE_PAGEUP;\nio.KeyMap[imgui.ImGuiKey_PageDown] = SDL_SCANCODE_PAGEDOWN;\nio.KeyMap[imgui.ImGuiKey_Home] = SDL_SCANCODE_HOME;\nio.KeyMap[imgui.ImGuiKey_End] = SDL_SCANCODE_END;\nio.KeyMap[imgui.ImGuiKey_Delete] = SDLK_DELETE;\nio.KeyMap[imgui.ImGuiKey_Backspace] = SDLK_BACKSPACE;\nio.KeyMap[imgui.ImGuiKey_Enter] = SDLK_RETURN;\nio.KeyMap[imgui.ImGuiKey_Escape] = SDLK_ESCAPE;\nio.KeyMap[imgui.ImGuiKey_A] = SDLK_a;\nio.KeyMap[imgui.ImGuiKey_C] = SDLK_c;\nio.KeyMap[imgui.ImGuiKey_V] = SDLK_v;\nio.KeyMap[imgui.ImGuiKey_X] = SDLK_x;\nio.KeyMap[imgui.ImGuiKey_Y] = SDLK_y;\nio.KeyMap[imgui.ImGuiKey_Z] = SDLK_z;\n\n    # Alternatively you can set this to NULL and call imgui.GetDrawData() after imgui.Render() to get the same ImDrawData pointer.\n    io.RenderDrawListsFn = ImGui_ImplSdlGL3_RenderDrawLists;\n    io.SetClipboardTextFn = ImGui_ImplSdlGL3_SetClipboardText;\n    io.GetClipboardTextFn = ImGui_ImplSdlGL3_GetClipboardText;\n    #io.ClipboardUserData = NULL;\n\n#ifdef \\_WIN32\nwmInfo=SDL_SysWMinfo();\nSDL_VERSION(wmInfo.version);\nSDL_GetWindowWMInfo(window, wmInfo);\nio.ImeWindowHandle = wmInfo.info.win.window;\n#else\n#(void)window;\n#endif\n\n    return True;\n")),"\n",r.createElement(n.p,null,"実行してエラーをつぶしていく。\nint 型配列への index を使った代入\n冒頭の io.KeyMap[imgui.ImGuiKey_LeftArrow] = SDL_SCANCODE_LEFT;がエラーになる。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"io.KeyMap[imgui.ImGuiKey_LeftArrow] = SDL_SCANCODE_LEFT;\nTypeError: 'SwigPyObject' object does not support item assignment\n")),"\n",r.createElement(n.p,null,"io.KeyMap の C での型。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-c"},"int KeyMap[ImGuiKey_COUNT];\n")),"\n",r.createElement(n.p,null,"単なる配列へのアクセス。KeyMap を list 的なオブジェクトとして python 側に公開するよりも、io にセッターを実装することにした。\nimgui.i に追加。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"%extend ImGuiIO {\nvoid SetKeyMap(int k, int v)\n{\nImGui::GetIO().KeyMap[k]=v;\n}\n}\n")),"\n",r.createElement(n.p,null,"python では次のように使う。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-python"},"io.SetKeyMap(imgui.ImGuiKey_LeftArrow, SDL_SCANCODE_LEFT);\n")),"\n",r.createElement(n.p,null,"関数ポインタ型に python の関数を代入。\nswig 的にはこれがいちばんの難問である。\n関数ポインタを変数に代入するのがエラーになる。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-python"},"def RenderDrawLists():\npass\n\nio.RenderDrawListsFn = RenderDrawLists;\n\nTypeError: in method 'ImGuiIO_RenderDrawListsFn_set', argument 2 of type 'void (_)(ImDrawData _)'\nPress any key to continue . . .\n")),"\n",r.createElement(n.p,null,"そりゃ、python の関数をこれに代入するのは無理だ。\n解決方法は、以下のようにする。\nimgui.i に追記。場所に注意が必要。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,'%{\nstatic void PythonRenderDrawListsFn(ImDrawData* data)\n{\nauto func=(PyObject*)ImGui::GetIO().UserData; // Get Python function\nauto obj = SWIG_NewPointerObj(SWIG_as_voidptr(data)\n, SWIGTYPE_p_ImDrawData, 0 | 0 );\nauto arglist = Py_BuildValue("(O)",obj); // Build argument list\nPyEval_CallObject(func, arglist); // Call Python\nPy_DECREF(arglist); // Trash arglist\nPy_DECREF(obj);\n}\n%}\n\n// before\n%include "imgui/imgui.h"\n// after\n\n%extend ImGuiIO {\nvoid SetRenderDrawListsFn(PyObject \\*pyfunc) {\nImGui::GetIO().UserData=pyfunc;\nself->RenderDrawListsFn=PythonRenderDrawListsFn;\nPy_INCREF(pyfunc);\n}\n}\n')),"\n",r.createElement(n.p,null,"残り２つの関数ポインタも同様の対応で行けると思うがコメントアウトして飛ばした。"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,'io.SetClipboardTextFn = ImGui_ImplSdlGL3_SetClipboardText;\nio.GetClipboardTextFn = ImGui_ImplSdlGL3_GetClipboardText;\n\nvoid\\*の代入\nio.ImeWindowHandle = wmInfo.info.win.window;\n\nTypeError: in method \'ImGuiIO_ImeWindowHandle_set\', argument 2 of type \'void \\*\'\n\nセッターを作った。\n%extend ImGuiIO {\nvoid SetImeWindowHandle(long long v)\n{\nImGui::GetIO().ImeWindowHandle = (void\\*)v;\n}\n}\n\nNewFrame の移植\ndef CreateDeviceObjects():\npass\n\ng_MousePressed=[False, False, False]\ng_MouseWheel=None\ndef NewFrame(window):\nif not g_FontTexture:\nCreateDeviceObjects();\n\n    io = imgui.GetIO();\n\n    # Setup display size (every frame to accommodate for window resizing)\n    w, h=SDL_GetWindowSize(window);\n    display_w, display_h=SDL_GL_GetDrawableSize(window);\n    io.DisplaySize = imgui.ImVec2(w, h);\n    io.DisplayFramebufferScale = ImVec2(\n        (display_w / float(w)) if w > 0 else 0,\n        (display_h / float(h)) if h > 0 else 0);\n\n    # Setup time step\n    time = SDL_GetTicks();\n    current_time = time / 1000.0;\n    io.DeltaTime = (current_time - g_Time) if g_Time > 0.0 else (1.0 / 60.0);\n    g_Time = current_time;\n\n    # Setup inputs\n    # (we already got mouse wheel, keyboard keys & characters from SDL_PollEvent())\n    mouseMask, mx, my = SDL_GetMouseState();\n    if (SDL_GetWindowFlags(window) & SDL_WINDOW_MOUSE_FOCUS):\n        # Mouse position, in pixels (set to -1,-1 if no mouse / on another screen, etc.)\n        io.MousePos = ImVec2(mx, my);\n    else:\n        io.MousePos = ImVec2(-1, -1);\n\n    # If a mouse press event came, always pass it as "mouse held this frame", so we don\'t miss click-release events that are shorter than 1 frame.\n    io.MouseDown[0] = g_MousePressed[0] or (mouseMask & SDL_BUTTON(SDL_BUTTON_LEFT)) != 0;\n    io.MouseDown[1] = g_MousePressed[1] or (mouseMask & SDL_BUTTON(SDL_BUTTON_RIGHT)) != 0;\n    io.MouseDown[2] = g_MousePressed[2] or (mouseMask & SDL_BUTTON(SDL_BUTTON_MIDDLE)) != 0;\n    g_MousePressed[0] = g_MousePressed[1] = g_MousePressed[2] = False;\n\n    io.MouseWheel = g_MouseWheel;\n    g_MouseWheel = 0.0;\n\n    # Hide OS mouse cursor if ImGui is drawing it\n    SDL_ShowCursor(0 if io.MouseDrawCursor else 1);\n\n    # Start the frame\n    imgui.NewFrame();\n\nio.MouseDown\nセッター。\n%extend ImGuiIO {\nvoid SetMouseDown(int k, int v)\n{\nImGui::GetIO().MouseDown[k]=v;\n}\n}\n\nCreateDeviceObjects の移植 # Backup GL state\nlast_texture=glGetIntegerv(GL_TEXTURE_BINDING_2D);\nlast_array_buffer=glGetIntegerv(GL_ARRAY_BUFFER_BINDING);\nlast_vertex_array=glGetIntegerv(GL_VERTEX_ARRAY_BINDING);\n\n    vertex_shader =b\'\'\'#version 330\n\nuniform mat4 ProjMtx;\nin vec2 Position;\nin vec2 UV;\nin vec4 Color;\nout vec2 Frag_UV;\nout vec4 Frag_Color;\nvoid main()\n{\nFrag_UV = UV;\nFrag_Color = Color;\ngl_Position = ProjMtx \\* vec4(Position.xy,0,1);\n};\n\'\'\'\n\n    fragment_shader =b\'\'\'#version 330\n\nuniform sampler2D Texture;\nin vec2 Frag_UV;\nin vec4 Frag_Color;\nout vec4 Out_Color;\nvoid main()\n{\nOut_Color = Frag_Color \\* texture( Texture, Frag_UV.st);\n};\n\'\'\'\n\n    g_ShaderHandle = glCreateProgram();\n    g_VertHandle = glCreateShader(GL_VERTEX_SHADER);\n    g_FragHandle = glCreateShader(GL_FRAGMENT_SHADER);\n    glShaderSource(g_VertHandle, vertex_shader);\n    glShaderSource(g_FragHandle, fragment_shader);\n    glCompileShader(g_VertHandle);\n    glCompileShader(g_FragHandle);\n    glAttachShader(g_ShaderHandle, g_VertHandle);\n    glAttachShader(g_ShaderHandle, g_FragHandle);\n    glLinkProgram(g_ShaderHandle);\n\n    g_AttribLocationTex = glGetUniformLocation(g_ShaderHandle, "Texture");\n    g_AttribLocationProjMtx = glGetUniformLocation(g_ShaderHandle, "ProjMtx");\n    g_AttribLocationPosition = glGetAttribLocation(g_ShaderHandle, "Position");\n    g_AttribLocationUV = glGetAttribLocation(g_ShaderHandle, "UV");\n    g_AttribLocationColor = glGetAttribLocation(g_ShaderHandle, "Color");\n\n    g_VboHandle=glGenBuffers(1);\n    g_ElementsHandle=glGenBuffers(1);\n\n    g_VaoHandle=glGenVertexArrays(1);\n    glBindVertexArray(g_VaoHandle);\n    glBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);\n    glEnableVertexAttribArray(g_AttribLocationPosition);\n    glEnableVertexAttribArray(g_AttribLocationUV);\n    glEnableVertexAttribArray(g_AttribLocationColor);\n\n#define OFFSETOF(TYPE, ELEMENT) ((size_t)&(((TYPE \\*)0)->ELEMENT))\nSIZEOF_ImDrawVert=20\nglVertexAttribPointer(g_AttribLocationPosition, 2, GL_FLOAT, GL_FALSE, SIZEOF_ImDrawVert, ctypes.c_void_p(0));\nglVertexAttribPointer(g_AttribLocationUV, 2, GL_FLOAT, GL_FALSE, SIZEOF_ImDrawVert, ctypes.c_void_p(8));\nglVertexAttribPointer(g_AttribLocationColor, 4, GL_UNSIGNED_BYTE, GL_TRUE, SIZEOF_ImDrawVert, ctypes.c_void_p(16));\n#undef OFFSETOF\n\n    CreateFontsTexture();\n\n    # Restore modified GL state\n    glBindTexture(GL_TEXTURE_2D, last_texture);\n    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);\n    glBindVertexArray(last_vertex_array);\n\n    return True;\n\nsizeof\n%constant int SIZEOF_ImDrawVert = sizeof(ImDrawVert);\n%constant int SIZEOF_ImDrawIdx = sizeof(ImDrawIdx);\n\noffset\n%{\n#define OFFSETOF(TYPE, ELEMENT) ((size_t)&(((TYPE \\*)0)->ELEMENT))\nconst int OFFSETOF_ImDrawVert_pos = OFFSETOF(ImDrawVert, pos);\nconst int OFFSETOF_ImDrawVert_uv = OFFSETOF(ImDrawVert, uv);\nconst int OFFSETOF_ImDrawVert_col = OFFSETOF(ImDrawVert, col);\n#undef OFFSETOF\n%}\nconst int OFFSETOF_ImDrawVert_pos = OFFSETOF_ImDrawVert_pos;\nconst int OFFSETOF_ImDrawVert_uv = OFFSETOF_ImDrawVert_uv;\nconst int OFFSETOF_ImDrawVert_col = OFFSETOF_ImDrawVert_col;\n\nCreateFontsTexture の移植\ndef CreateFontsTexture(): # Build texture atlas\nio = imgui.GetIO(); # Load as RGBA 32-bits for OpenGL3 demo because it is more likely to be compatible with user\'s existing shader.\npixels, width, height=io.Fonts.GetTexDataAsRGBA32();\n\n    # Upload texture to graphics system\n    last_texture=glGetIntegerv(GL_TEXTURE_BINDING_2D);\n    g_FontTexture=glGenTextures(1);\n    glBindTexture(GL_TEXTURE_2D, g_FontTexture);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);\n\n    # Store our identifier\n    io.Fonts.TexID = g_FontTexture;\n\n    # Restore state\n    glBindTexture(GL_TEXTURE_2D, last_texture);\n\n値を返すためにポインタ引数を出力に使い(in + argout)、長さの分かっているバイト列へのポインタを bytes として返す\n対象はこれ。\nIMGUI_API void GetTexDataAsRGBA32(unsigned char\\*_ out_pixels, int_ out_width, int* out_height, int* out_bytes_per_pixel = NULL);\n\ntypemap でやってみる。\nimgui.i の%include "imgui/imgui.h"より前に記述。\n%typemap(in, numinputs=0) (unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel) (unsigned char *tempP, int tempW, int tempH, int tempB) {\n$1 = &tempP;\n$2 = &tempW;\n$3 = &tempH;\n$4 = &tempB;\n}\n%typemap(argout)(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel){\nauto b = PyBytes_FromStringAndSize((const char *)_$1, (_$2) _ (_$3) _ (_$4));\nauto w = PyLong_FromLong(_$2);\nauto h = PyLong_FromLong(_$3);\n\n    if ((!$result) || ($result == Py_None)) {\n        // new tuple3\n        $result = PyTuple_New(3);\n        PyTuple_SetItem($result, 0, b);\n        PyTuple_SetItem($result, 1, w);\n        PyTuple_SetItem($result, 2, h);\n    }\n    else{\n        if (!PyTuple_Check($result)) {\n            // new tuple4\n            auto t= PyTuple_New(4);\n            PyTuple_SetItem(t, 0, $result);\n            PyTuple_SetItem(t, 1, b);\n            PyTuple_SetItem(t, 2, w);\n            PyTuple_SetItem(t, 3, h);\n            $result=t;\n        }\n        else {\n            // concat\n            auto head = $result;\n            auto tail = PyTuple_New(3);\n            PyTuple_SetItem($result, 0, b);\n            PyTuple_SetItem($result, 1, w);\n            PyTuple_SetItem($result, 2, h);\n            $result = PySequence_Concat(head, tail);\n            Py_DECREF(head);\n            Py_DECREF(tail);\n        }\n    }\n\n}\n\ntypemap(in)で呼び出し時に出力変数を与える必要を無くして、typemap(argout)で呼び出し後の返り値を tuple 化して値を詰める。その際に、バイト列のサイズが計算できるので PyBytes_FromStringAndSize で bytes を作る。\nTexID のセッター\nint から void*への変換。\n%extend ImFontAtlas {\nvoid SetTexID(long long id) {\nself->TexID=reinterpret_cast<void*>(id);\n}\n}\n\nここまで実装すると Texture の nullptr でプログラムがクラッシュしなくなる。\nimgui の widget に対する inout な引数\nfloat*\nIMGUI_API bool SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);\n\nargout にすると返り値が(bool, float)になっていまいちな気がする。\nswig で float\\*型のヘルパークラスを作る。\n%include "cpointer.i"\n%pointer_functions(float, floatp);\n\nf=imgui.new_floatp()\nimgui.floatp_assign(f, 0.0)\nimgui.SliderFloat("float", f, 0.0, 1.0);\n\nbool*\nfloat と同様に。\nIMGUI_API void ShowTestWindow(bool* p_open = NULL);\n\n%include "cpointer.i"\n%pointer_functions(bool, boolp);\n\n    show_test_window = imgui.new_boolp();\n    imgui.boolp_assign(show_test_window, True)\n\n    if imgui.Button("Test Window"): imgui.boolp_assign(show_test_window, not boolp_assign.value))\n\n    if imgui.boolp_value(show_test_window):\n        imgui.SetNextWindowPos(imgui.ImVec2(650, 20), imgui.ImGuiSetCond_FirstUseEver);\n        imgui.ShowTestWindow(show_test_window);\n\n動くとはいえこれはいかんな。ポインタクラスをもう少し便利にするか、別の方法を調べよう。\nfloat[3]\nIMGUI_API bool ColorEdit3(const char\\* label, float col[3]);\n\ntypemap で list リストを受け取って、list に結果を格納するように記述する。\n%typemap(in) float col[3] (float temp[3]) {\nif (!PySequence_Check($input)) {\n        PyErr_SetString(PyExc_ValueError,"Expected a sequence");\n        return NULL;\n    }\n    if (PySequence_Length($input) < $1_dim0) {\n        PyErr_SetString(PyExc_ValueError,"Size mismatch. Expected more than $1_dim0 elements");\n        return NULL;\n    }\n    for (int i = 0; i < $1_dim0; i++) {\n        PyObject *o = PySequence_GetItem($input,i);\nif (PyNumber_Check(o)) {\ntemp[i] = (float) PyFloat_AsDouble(o);\n}\nelse {\nPyErr_SetString(PyExc_ValueError,"Sequence elements must be numbers");\nreturn NULL;\n}\n}\n$1 = temp;\n}\n%typemap(argout) float col[3] {\n    for (int i = 0; i < $1_dim0; i++) {\n        PyObject *o = PyFloat_FromDouble((double) $1[i]);\n        PyList_SetItem($input, i, o);\n}\n}\n\nclear_color = [114/255.0, 144/255.0, 154/255.0, 0];\nimgui.ColorEdit3("clear color", clear_color);\n\nRenderDrawLists の移植\ndef RenderDrawLists(draw_data):\nglobal g_ShaderHandle\n\n    # Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)\n    io = imgui.GetIO();\n    fb_width = int(io.DisplaySize.x * io.DisplayFramebufferScale.x);\n    fb_height = int(io.DisplaySize.y * io.DisplayFramebufferScale.y);\n    if fb_width == 0 or fb_height == 0:\n        return;\n    draw_data.ScaleClipRects(io.DisplayFramebufferScale);\n\n    # Backup GL state\n    last_active_texture=glGetIntegerv(GL_ACTIVE_TEXTURE);\n    glActiveTexture(GL_TEXTURE0);\n    last_program=glGetIntegerv(GL_CURRENT_PROGRAM);\n    last_texture=glGetIntegerv(GL_TEXTURE_BINDING_2D);\n    last_array_buffer=glGetIntegerv(GL_ARRAY_BUFFER_BINDING);\n    last_element_array_buffer=glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING);\n    last_vertex_array=glGetIntegerv(GL_VERTEX_ARRAY_BINDING);\n    last_blend_src_rgb=glGetIntegerv(GL_BLEND_SRC_RGB);\n    last_blend_dst_rgb=glGetIntegerv(GL_BLEND_DST_RGB);\n    last_blend_src_alpha=glGetIntegerv(GL_BLEND_SRC_ALPHA);\n    last_blend_dst_alpha=glGetIntegerv(GL_BLEND_DST_ALPHA);\n    last_blend_equation_rgb=glGetIntegerv(GL_BLEND_EQUATION_RGB);\n    last_blend_equation_alpha=glGetIntegerv(GL_BLEND_EQUATION_ALPHA);\n    last_viewport=glGetIntegerv(GL_VIEWPORT);\n    last_scissor_box=glGetIntegerv(GL_SCISSOR_BOX);\n    last_enable_blend = glIsEnabled(GL_BLEND);\n    last_enable_cull_face = glIsEnabled(GL_CULL_FACE);\n    last_enable_depth_test = glIsEnabled(GL_DEPTH_TEST);\n    last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);\n\n    # Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled\n    glEnable(GL_BLEND);\n    glBlendEquation(GL_FUNC_ADD);\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    glDisable(GL_CULL_FACE);\n    glDisable(GL_DEPTH_TEST);\n    glEnable(GL_SCISSOR_TEST);\n\n    # Setup viewport, orthographic projection matrix\n    glViewport(0, 0, fb_width, fb_height);\n    ortho_projection = (ctypes.c_float * 16)(\n         2.0/io.DisplaySize.x, 0.0,                   0.0, 0.0,\n         0.0,                  2.0/-io.DisplaySize.y, 0.0, 0.0,\n         0.0,                  0.0,                  -1.0, 0.0,\n        -1.0,                  1.0,                   0.0, 1.0,\n    );\n    glUseProgram(g_ShaderHandle);\n    glUniform1i(g_AttribLocationTex, 0);\n    glUniformMatrix4fv(g_AttribLocationProjMtx, 1, GL_FALSE, ortho_projection);\n    glBindVertexArray(g_VaoHandle);\n\n    for n in range(draw_data.CmdListsCount):\n\n        cmd_list = draw_data.CmdLists[n];\n        idx_buffer_offset = 0;\n\n        glBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);\n        glBufferData(GL_ARRAY_BUFFER, cmd_list.VtxBuffer.Size * SIZEOF_ImDrawVert, cmd_list.VtxBuffer.Data, GL_STREAM_DRAW);\n\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_ElementsHandle);\n        glBufferData(GL_ELEMENT_ARRAY_BUFFER, cmd_list.IdxBuffer.Size * SIZEOF_ImDrawVert, cmd_list.IdxBuffer.Data, GL_STREAM_DRAW);\n\n        for cmd_i in range(cmd_list.CmdBuffer.Size):\n\n            pcmd = cmd_list.CmdBuffer[cmd_i];\n            if pcmd.UserCallback:\n                pcmd.UserCallback(cmd_list, pcmd);\n            else:\n                glBindTexture(GL_TEXTURE_2D, pcmd.TextureId);\n                glScissor(pcmd.ClipRect.x, (fb_height - pcmd.ClipRect.w), (pcmd.ClipRect.z - pcmd.ClipRect.x), (pcmd.ClipRect.w - pcmd.ClipRect.y));\n                glDrawElements(GL_TRIANGLES, pcmd.ElemCount, GL_UNSIGNED_SHORT, idx_buffer_offset);\n\n            idx_buffer_offset += pcmd.ElemCount;\n\n    # Restore modified GL state\n    glUseProgram(last_program);\n    glBindTexture(GL_TEXTURE_2D, last_texture);\n    glActiveTexture(last_active_texture);\n    glBindVertexArray(last_vertex_array);\n    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, last_element_array_buffer);\n    glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);\n    glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);\n    if (last_enable_blend):\n        glEnable(GL_BLEND);\n    else:\n        glDisable(GL_BLEND);\n    if (last_enable_cull_face):\n        glEnable(GL_CULL_FACE);\n    else:\n        glDisable(GL_CULL_FACE);\n    if (last_enable_depth_test):\n        glEnable(GL_DEPTH_TEST);\n    else:\n        glDisable(GL_DEPTH_TEST);\n    if (last_enable_scissor_test):\n        glEnable(GL_SCISSOR_TEST);\n    else:\n        glDisable(GL_SCISSOR_TEST);\n    glViewport(last_viewport[0], last_viewport[1], last_viewport[2], last_viewport[3]);\n    glScissor(last_scissor_box[0], last_scissor_box[1], last_scissor_box[2], last_scissor_box[3]);\n\ngetter\n配列アクセスできない。\ncmd_list = draw_data.CmdLists[n]\n\nゲッターを実装する\n%extend ImDrawData {\nImDrawList\\* GetCmdList(int n){\nreturn self->CmdLists[n];\n}\n}\n\ntemplate の型定義が無い\n実装する型を明示する。\n%template(ImVectorDrawVert) ImVector<ImDrawVert>;\n%template(ImVectorDrawIdx) ImVector<ImDrawIdx>;\n%template(ImVectorDrawCmd) ImVector<ImDrawCmd>;\n\nByte 列を得る\ncmd_list.VtxBuffer.Data\n\n%typemap(in, numinputs=0) (unsigned char** out_bytes, int* out_size) (unsigned char *tempP, int tempSize) {\n$1 = &tempP;\n$2 = &tempSize;\n}\n%typemap(argout)(unsigned char** out_bytes, int* out_size){\nauto b = PyBytes_FromStringAndSize((const char *)_$1, _$2);\n\n    if ((!$result) || ($result == Py_None)) {\n        $result = b;\n    }\n    else{\n        if (!PyTuple_Check($result)) {\n            // new tuple4\n            auto t= PyTuple_New(2);\n            PyTuple_SetItem(t, 0, $result);\n            PyTuple_SetItem(t, 1, b);\n            $result=t;\n        }\n        else {\n            // concat\n            auto head = $result;\n            auto tail = PyTuple_New(1);\n            PyTuple_SetItem($result, 0, b);\n            $result = PySequence_Concat(head, tail);\n            Py_DECREF(head);\n            Py_DECREF(tail);\n        }\n    }\n\n}\n\n// before\n%include "imgui/imgui.h"\n// after\n\n%extend ImDrawList {\nvoid GetVtxBufferData(unsigned char **out_bytes, int *out_size){\n*out_bytes=(unsigned char *)self->VtxBuffer.Data;\n*out_size=self->VtxBuffer.Size \\* sizeof(self->VtxBuffer.Data[0]);\n}\nvoid GetIdxBufferData(unsigned char **out_bytes, int *out_size){\n*out_bytes=(unsigned char *)self->IdxBuffer.Data;\n*out_size=self->IdxBuffer.Size \\* sizeof(self->IdxBuffer.Data[0]);\n}\n}\n\nglBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);\nglBufferData(GL_ARRAY_BUFFER, cmd_list.VtxBuffer.Size \\* SIZEOF_ImDrawVert, cmd_list.GetVtxBufferData(), GL_STREAM_DRAW);\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_ElementsHandle);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, cmd_list.IdxBuffer.Size \\* SIZEOF_Idx, cmd_list.GetIdxBufferData(), GL_STREAM_DRAW);\n\nShutdown の移植\ndef Shutdown():\nInvalidateDeviceObjects();\nimgui.Shutdown();\n\ndef InvalidateDeviceObjects():\nglobal g_VaoHandle\nglobal g_VboHandle\nglobal g_ElementsHandle\nglobal g_ShaderHandle\nglobal g_VertHandle\nglobal g_FragHandle\nglobal g_FontTexture\n\n    if (g_VaoHandle): glDeleteVertexArrays(1, g_VaoHandle);\n    if (g_VboHandle): glDeleteBuffers(1, g_VboHandle);\n    if (g_ElementsHandle): glDeleteBuffers(1, g_ElementsHandle);\n    g_VaoHandle = g_VboHandle = g_ElementsHandle = 0;\n\n    if (g_ShaderHandle and g_VertHandle): glDetachShader(g_ShaderHandle, g_VertHandle);\n    if (g_VertHandle): glDeleteShader(g_VertHandle);\n    g_VertHandle = 0;\n\n    if (g_ShaderHandle and g_FragHandle): glDetachShader(g_ShaderHandle, g_FragHandle);\n    if (g_FragHandle): glDeleteShader(g_FragHandle);\n    g_FragHandle = 0;\n\n    if (g_ShaderHandle): glDeleteProgram(g_ShaderHandle);\n    g_ShaderHandle = 0;\n\n    if (g_FontTexture):\n        glDeleteTextures(1, g_FontTexture);\n        imgui.GetIO().Fonts.SetTexID(0);\n        g_FontTexture = 0;\n\nProcessEvent の移植\ndef ProcessEvent(event):\nglobal g_MouseWheel\nglobal g_MousePressed\n\n    io = imgui.GetIO();\n    if event.type==SDL_MOUSEWHEEL:\n        if (event.wheel.y > 0):\n            g_MouseWheel = 1;\n        if (event.wheel.y < 0):\n            g_MouseWheel = -1;\n        return True;\n    elif event.type==SDL_MOUSEBUTTONDOWN:\n        if (event.button.button == SDL_BUTTON_LEFT): g_MousePressed[0] = True;\n        if (event.button.button == SDL_BUTTON_RIGHT): g_MousePressed[1] = True;\n        if (event.button.button == SDL_BUTTON_MIDDLE): g_MousePressed[2] = True;\n        return True;\n    elif event.type==SDL_TEXTINPUT:\n        io.AddInputCharactersUTF8(event.text.text);\n        return True;\n    elif event.type==SDL_KEYDOWN or event.type==SDL_KEYUP:\n        key = event.key.keysym.sym & ~SDLK_SCANCODE_MASK;\n        io.SetKeysDown(key, event.type == SDL_KEYDOWN);\n        io.KeyShift = ((SDL_GetModState() & KMOD_SHIFT) != 0);\n        io.KeyCtrl = ((SDL_GetModState() & KMOD_CTRL) != 0);\n        io.KeyAlt = ((SDL_GetModState() & KMOD_ALT) != 0);\n        io.KeySuper = ((SDL_GetModState() & KMOD_GUI) != 0);\n        return True;\n\n    return False;\n\nio.KeysDown\nセッター\n%extend ImGuiIO {\nvoid SetKeysDown(int k, int v)\n{\nImGui::GetIO().KeysDown[k]=v;\n}\n}\n\nかくしてほぼ動くようになった。\n\n実際には新しい Widget を Python から使用するたびに値をやりとりする部分を追加しなければならないが、そこはおいおいやっていく。\nVisualStudio のセットアップ\nこういうネイティブモジュールの開発ではないとクラッシュの原因を探すのが困難になるが、VisualStudio で普通にアタッチできるので便利。\nひとつの solution に python プロジェクトと、c++の dll プロジェクトを同居させてデバッグできる。\n\nあとで書く\n')))}var a=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?r.createElement(n,e,r.createElement(o,e)):o(e)};t(8678);function l(e){let{data:n,children:t}=e;return r.createElement(r.Fragment,null,r.createElement("h1",null,n.mdx.frontmatter.title),r.createElement(i.Zo,null,t))}function _(e){return r.createElement(l,e,r.createElement(a,e))}},8678:function(e,n,t){t(7294)},1151:function(e,n,t){t.d(n,{Zo:function(){return l},ah:function(){return o}});var i=t(7294);const r=i.createContext({});function o(e){const n=i.useContext(r);return i.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}const a={};function l({components:e,children:n,disableParentContext:t}){let l;return l=t?"function"==typeof e?e({}):e||a:o(e),i.createElement(r.Provider,{value:l},n)}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2017-07-imgui-python-md-8741ce7568a23a0618e1.js.map