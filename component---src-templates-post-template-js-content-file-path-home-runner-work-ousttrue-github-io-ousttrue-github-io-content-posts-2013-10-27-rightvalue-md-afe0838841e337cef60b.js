"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3667],{620:function(n,s,a){a.r(s),a.d(s,{default:function(){return k}});var t=a(1151),p=a(7294);function o(n){const s=Object.assign({p:"p",span:"span"},(0,t.ah)(),n.components);return p.createElement(p.Fragment,null,p.createElement(s.p,null,"右辺値の理解\nそろそろ右辺値を抑えておきたい気がしたのでテストコードを書きながら実験してみた(VC2010\nExpress Edition)。\nhttp://msdn.microsoft.com/ja-jp/library/vstudio/dd293665.aspx\nを参考に右辺値実験クラス RightKun を書いた。\nコピーコンストラクタと同じくシグニチャは決まったものがあって\n右辺値代入演算のオーバーロードとペアになるらしい。\n各関数の呼び出しでメッセージを表示するように仕込んだ。\nhttps://gist.github.com/ousttrue/7178535"),"\n",p.createElement(s.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="cpp"><pre class="language-cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>\n\n\n<span class="token keyword">class</span> <span class="token class-name">RightKun</span>\n<span class="token punctuation">{</span>\n<span class="token keyword">public</span><span class="token operator">:</span>\n    <span class="token function">RightKun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":default constructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n    <span class="token operator">~</span><span class="token function">RightKun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":destructor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 左辺値によるコピーコンストラクタ</span>\n    <span class="token function">RightKun</span><span class="token punctuation">(</span><span class="token keyword">const</span> RightKun <span class="token operator">&amp;</span>src<span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":copy constructor: "</span><span class="token punctuation">;</span>\n        <span class="token operator">*</span><span class="token keyword">this</span><span class="token operator">=</span>src<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    RightKun <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> RightKun <span class="token operator">&amp;</span>src<span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"left value operator= "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>src <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 右辺値によるムーブコンストラクタ</span>\n    <span class="token function">RightKun</span><span class="token punctuation">(</span>RightKun <span class="token operator">&amp;&amp;</span>src<span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">":move constructor: "</span><span class="token punctuation">;</span>\n        <span class="token operator">*</span><span class="token keyword">this</span><span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    RightKun <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>RightKun <span class="token operator">&amp;&amp;</span>src<span class="token punctuation">)</span>\n    <span class="token punctuation">{</span>\n        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"right value operator= "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>src <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>'}}),"\n",p.createElement(s.p,null,"とりあえず使ってみる"),"\n",p.createElement(s.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="cpp"><pre class="language-cpp"><code class="language-cpp"><span class="token punctuation">{</span>\n    <span class="token comment">// default</span>\n    RightKun r1<span class="token punctuation">;</span>\n\n    <span class="token comment">// copy</span>\n    RightKun r2<span class="token operator">=</span>r1<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n結果\n<span class="token number">0025F</span>E33<span class="token operator">:</span><span class="token keyword">default</span> constructor\n<span class="token number">0025F</span>E32<span class="token operator">:</span>copy constructor<span class="token operator">:</span> left value <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token number">0025F</span>E33\n<span class="token number">0025F</span>E32<span class="token operator">:</span>destructor\n<span class="token number">0025F</span>E33<span class="token operator">:</span>destructor\n\n問題ない。\n通常の値返しの呼び出し\nRightKun <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">RightKun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n使う\n<span class="token punctuation">{</span>\n    RightKun r<span class="token operator">=</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n結果\n<span class="token number">0025F</span>E2E<span class="token operator">:</span><span class="token keyword">default</span> constructor\n<span class="token number">0025F</span>E2E<span class="token operator">:</span>destructor\n\nおや、コピーコンストラクタが呼ばれない。\nRVO\n調べてみたらこれはコンパイラの<span class="token function">RVO</span><span class="token punctuation">(</span>Return Value Optimization<span class="token punctuation">)</span>という機能で\n返り値が変数に代入されていない場合<span class="token punctuation">(</span>いわゆる右辺値<span class="token punctuation">)</span>に代入を無しにできるというものらしい。\nなるほど。\nよくある\nvec3 <span class="token function">cross</span><span class="token punctuation">(</span><span class="token keyword">const</span> vec3 <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> vec3 <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n  <span class="token comment">// x, y, z...</span>\n  <span class="token keyword">return</span> <span class="token function">vec3</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nvec3 out<span class="token operator">=</span><span class="token function">cross</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n的なものを\n<span class="token keyword">void</span> <span class="token function">cross</span><span class="token punctuation">(</span>vec3 <span class="token operator">*</span>out<span class="token punctuation">,</span> <span class="token keyword">const</span> vec3 <span class="token operator">*</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> vec3 <span class="token operator">*</span>rhs<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n  <span class="token comment">// x, y, z...</span>\n  out<span class="token operator">-></span>x<span class="token operator">=</span>x<span class="token punctuation">;</span>\n  out<span class="token operator">-></span>y<span class="token operator">=</span>y<span class="token punctuation">;</span>\n  out<span class="token operator">-></span>z<span class="token operator">=</span>z<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nvec3 out<span class="token punctuation">;</span>\n<span class="token function">cross</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>out<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nと書いても別にパフォーマンスが変わらんと言うことですな。\n最近のコンパイラなら大丈夫というのは、RVOがたぶん効くということか。\nむしろ適切なコンストラクタで初期化できるので前者の方がよろしいな。\n後者だとデフォルトコンストラクタが<span class="token number">0</span>で初期化しないようにしたくなるし、\nいろいろよろしくない。\nRVOできないようにする\n先ほどの関数をRVOが無効になるように改造してみる。\nRightKun <span class="token function">createNoRVO</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    RightKun r<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> r<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n使う\n<span class="token punctuation">{</span>\n    RightKun r<span class="token operator">=</span><span class="token function">createNoRVO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n結果\n<span class="token number">0025F</span>DFB<span class="token operator">:</span><span class="token keyword">default</span> constructor\n<span class="token number">0025F</span>E31<span class="token operator">:</span>move constructor<span class="token operator">:</span> right value <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token number">0025F</span>DFB\n<span class="token number">0025F</span>DFB<span class="token operator">:</span>destructor\n<span class="token number">0025F</span>E31<span class="token operator">:</span>destructor\n\n期せずしてムーブコンストラクタ呼び出しが発生した。\nどういう条件で切り替わるんだこれは。\n調べてみるとムーブコンストラクタはRVOが効かない時に使われる、という記述を見つけた。\nhttp<span class="token operator">:</span><span class="token comment">//msdn.microsoft.com/ja-jp/library/vstudio/dd293668.aspx</span>\n\nコンパイラが戻り値の最適化 <span class="token punctuation">(</span>RVO<span class="token punctuation">)</span> または名前付き戻り値の最適化 <span class="token punctuation">(</span>NRVO<span class="token punctuation">)</span>\nを使用できない場合に、移動セマンティクスが役立ちます。\nこのような場合、型が移動コンストラクターを定義していれば、コンパイラはその移動コンストラクターを呼び出します\n\nほぅ。\nNRVOというのはRVOの進化型で戻り値が変数に代入<span class="token punctuation">(</span>名前付き<span class="token punctuation">)</span>されていても有効になるものらしい。上記の例だと単純なのでNRVOできそうな気もするがコンパイルオプションとかですかね。\nコンパイラが代入の右側を破棄してもよいと判断した場合にムーブコンストラクタが定義されていれば自動的にそっちを使うという暗黙的な仕組みのようだ。\ng<span class="token operator">++</span><span class="token punctuation">(</span><span class="token number">4.6</span><span class="token punctuation">)</span>ではNRVOされた\n右側を破棄できないようにしてみよう\nRightKun <span class="token function">createCanNotMove</span><span class="token punctuation">(</span><span class="token keyword">const</span> RightKun <span class="token operator">&amp;</span>src<span class="token punctuation">,</span> <span class="token keyword">bool</span> hoge<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>hoge<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> src<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token function">RightKun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n使う\n<span class="token punctuation">{</span>\n    RightKun r<span class="token operator">=</span><span class="token function">createCanNotMove</span><span class="token punctuation">(</span><span class="token function">RightKun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n結果\n<span class="token number">0025F</span>E2C<span class="token operator">:</span><span class="token keyword">default</span> constructor\n<span class="token number">0025F</span>E30<span class="token operator">:</span>copy constructor<span class="token operator">:</span> left value <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token number">0025F</span>E2C\n<span class="token number">0025F</span>E2C<span class="token operator">:</span>destructor\n<span class="token number">0025F</span>E30<span class="token operator">:</span>destructor\n\n予定通りコピーコンストラクタ呼び出し。問題ない。\n引数をRightKun<span class="token operator">&amp;&amp;</span>にしてみる\nここでsrcの型をRightKun<span class="token operator">&amp;&amp;</span>にすればムーブコンストラクタ呼び出しできるのではないか。\n<span class="token keyword">static</span> RightKun <span class="token function">rightValueArg</span><span class="token punctuation">(</span>RightKun <span class="token operator">&amp;&amp;</span>src<span class="token punctuation">,</span> <span class="token keyword">bool</span> hoge<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>hoge<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> src<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token function">RightKun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n使う\n<span class="token punctuation">{</span>\n    RightKun r<span class="token operator">=</span><span class="token function">rightValueArg</span><span class="token punctuation">(</span><span class="token function">RightKun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n結果\n<span class="token number">0025F</span>E2C<span class="token operator">:</span><span class="token keyword">default</span> constructor\n<span class="token number">0025F</span>E30<span class="token operator">:</span>copy constructor<span class="token operator">:</span> left value <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token number">0025F</span>E2C\n<span class="token number">0025F</span>E2C<span class="token operator">:</span>destructor\n<span class="token number">0025F</span>E30<span class="token operator">:</span>destructor\n\nところがぎっちょん、コピーの方。何故かというとrightValueArg内ではsrcはただの変数、左辺値として\n扱われるのだ。RightKun<span class="token operator">&amp;&amp;</span>は実引数の制限だ。\n試しに以下のように呼び出すとエラーになる。\n<span class="token punctuation">{</span>\n  RightKun leftvalue<span class="token punctuation">;</span>\n  RightKun r<span class="token operator">=</span><span class="token function">rightValueArg</span><span class="token punctuation">(</span>leftvalue<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nエラー\nerror C2664<span class="token operator">:</span> <span class="token char">\'rightValueArg\'</span> <span class="token operator">:</span> <span class="token number">1</span> 番目の引数を <span class="token char">\'RightKun\'</span> から <span class="token char">\'RightKun &amp;&amp;\'</span> に変換できません。\n\nsrcが右辺値であることを明示する\nプログラマはsrcが右辺値であることを明示できる。\n<span class="token keyword">static</span> RightKun <span class="token function">moveExplicit</span><span class="token punctuation">(</span>RightKun <span class="token operator">&amp;&amp;</span>src<span class="token punctuation">,</span> <span class="token keyword">bool</span> hoge<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>hoge<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>RightKun<span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token function">RightKun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n使う\n<span class="token punctuation">{</span>\n    RightKun r<span class="token operator">=</span><span class="token function">moveExplicit</span><span class="token punctuation">(</span><span class="token function">RightKun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n結果\n<span class="token number">0025F</span>E2B<span class="token operator">:</span><span class="token keyword">default</span> constructor\n<span class="token number">0025F</span>E2F<span class="token operator">:</span>move constructor<span class="token operator">:</span> right value <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token number">0025F</span>E2B\n<span class="token number">0025F</span>E2B<span class="token operator">:</span>destructor\n<span class="token number">0025F</span>E2F<span class="token operator">:</span>destructor\n\n意図通りにムーブコンストラクタが呼ばれた。\nで、このキャストをラップするのがstd<span class="token double-colon punctuation">::</span>moveですよと。\nただし、std<span class="token double-colon punctuation">::</span>moveした変数をその後で使わないのはプログラマの責任と。\nということで右辺値とムーブコンストラクタのなんたるかがなんとなく分かった。\nムーブコンストラクタを呼ぶかどうかはコンパイラが判断するので\n使うほうは気にしなくても、知らないうちにムーブコンストラクタが呼ばれてパフォーマンス上の恩恵を受けることができるということですな。\n知っていればstd<span class="token double-colon punctuation">::</span>moveによりムーブコンストラクタの呼び出しを増やせるかもしれない。\nunique_ptrでstd<span class="token double-colon punctuation">::</span>moveを要求されるのはコピーコンストラクタを無効にしつつ、\nムーブコンストラクタを定義している故と類推できた。\nだいたい分かった結果、\n自分でムーブコンストラクタを定義するクラスを書くことはあまり無さそうな気がした。\nだめな書き方\n最後に右辺値を返す関数を書こうとして最初にはまった、だめなバージョンを書いておく\nRightKun <span class="token operator">&amp;&amp;</span><span class="token function">moveFail</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">RightKun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n使う\n<span class="token punctuation">{</span>\n    RightKun r<span class="token operator">=</span><span class="token function">moveFail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",p.createElement(s.p,null,"結果\n0025FE07:default constructor\n0025FE07:destructor\n0025FE2D:move constructor: right value operator= 0025FE07\n0025FE2D:destructor"),"\n",p.createElement(s.p,null,"destructor が動いた後のポインタで、ムーブコンストラクタが呼び出される\n大変危険なコードになった。 なんじゃこりゃー。\ngcc でやってみたらわかりやすいエラーメッセージが出た。\n警告: 一時オブジェクトへの参照を返そうとしています [デフォルトで有効]"),"\n",p.createElement(s.p,null,"関数返り値の宣言に&&を使ってはいけないということか"))}var e=function(n){void 0===n&&(n={});const{wrapper:s}=Object.assign({},(0,t.ah)(),n.components);return s?p.createElement(s,n,p.createElement(o,n)):o(n)},c=a(8678),u=a(8838);const l={code:n=>{let{children:s,className:a}=n;return a?p.createElement(u.Z,{className:a},s):p.createElement("code",null,s)}};function r(n){let{data:s,children:a}=n;return p.createElement(c.Z,null,p.createElement("h1",null,s.mdx.frontmatter.title),p.createElement(t.Zo,{components:l},a))}function k(n){return p.createElement(r,n,p.createElement(e,n))}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2013-10-27-rightvalue-md-afe0838841e337cef60b.js.map