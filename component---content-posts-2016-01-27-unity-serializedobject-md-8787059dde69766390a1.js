"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4596],{9524:function(e,n,t){t.r(n);var r=t(1151),i=t(7294);function a(e){const n=Object.assign({p:"p",pre:"pre",code:"code"},(0,r.ah)(),e.components);return i.createElement(i.Fragment,null,i.createElement(n.p,null,"Unity の SerializedObject のメモ。"),"\n",i.createElement(n.pre,null,i.createElement(n.code,null,'PropertyDrawers have two uses:\n- Customize the GUI of every instance of a Serializable class.\n- Customize the GUI of script members with custom PropertyAttributes.\n\nできることは２つ。\nSerializeable classのPropertyDrawerを定義する。\nPropertyAttributeを定義して既存のSerializable classのPropertyDrawerを差し替える。\nNot Serializableなclassに対してPropertyDrawerを定義することはできぬ(TimeSpanとかね)。\nPropertyDrawerを定義してみる\nusing UnityEngine;\n#if UNITY_EDITOR\nusing UnityEditor;\n#endif\n\npublic class SampleAttribute : PropertyAttribute\n{\n}\n\n#if UNITY_EDITOR\n[CustomPropertyDrawer(typeof(SampleAttribute))]\npublic class SampleDrawer : PropertyDrawer\n{\n    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\n    {\n        var sampleAttribute = (SampleAttribute)attribute;\n        Debug.Log(property);\n        EditorGUI.PropertyField(position, property, new GUIContent("Hoge"));\n    }\n}\n#endif\n\npublic class SampleBehaviour : MonoBehaviour\n{\n    [Sample]\n    public int Value;\n}\n\nproperty.Path\n(x:14.00, y:154.00, width:266.00, height:16.00) path: Value\n\nOnGUIでデバッグプリント\n        Debug.LogFormat("{0} path: {1}", position, property.propertyPath);\n\nなるほど。次のプロパティではどうか。\n    [Sample]\n    public List<int> ValueArray;\n\n    [Sample]\n    public List<int> ValueList;\n\nOnGUIが呼ばれぬ。プリミティブ型以外はだめなのか？\nかと思いきや中身に対して呼ばれることが分かった。\n配列、Listの中身に対してPropertyDrawerが呼ばれる。\n(x:14.00, y:208.00, width:258.00, height:16.00) path: ValueArray.Array.data[0]\n(x:14.00, y:262.00, width:258.00, height:16.00) path: ValueList.Array.data[0]\n\nSerializable class\npublic enum IngredientUnit { Spoon, Cup, Bowl, Piece }\n\n// Custom serializable class\n[Serializable]\npublic class Ingredient\n{\n    [Sample]\n    public string name;\n\n    [Sample]\n    public int amount = 1;\n\n    [Sample]\n    public IngredientUnit unit;\n}\n\n    public Ingredient ingredient;\n\n    public List<Ingredient> ingredientList;\n\n(x:14.00, y:298.00, width:258.00, height:16.00) path: ingredient.name\n(x:14.00, y:406.00, width:258.00, height:16.00) path: ingredientList.Array.data[0].name\n\nCustomEditor\nデフォルトと同じ挙動。DrawDefaultInspector()の前後にボタンを追加したりできる。\n[CustomEditor(typeof(SampleBehaviour))]\npublic class ObjectGeneratorEditor : Editor\n{\n    public override void OnInspectorGUI()\n    {\n        DrawDefaultInspector();\n    }\n}\n\nSerializedObjectのPropertyを列挙してみる\n    public override void OnInspectorGUI()\n    {\n        serializedObject.Update();\n\n        var it = serializedObject.GetIterator();\n        bool hasNext = it.NextVisible(true);\n        while(hasNext)\n        {\n            //Debug.Log(it.propertyPath);\n            var expand = EditorGUILayout.PropertyField(it, false);\n            hasNext=it.NextVisible(expand);\n        }\n\n        serializedObject.ApplyModifiedProperties();\n    }\n\n\nEditorGUIの関数はpositionが必要\nEditorGUILayoutはposition無用。\n')))}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?i.createElement(n,e,i.createElement(a,e)):a(e)}},1151:function(e,n,t){t.d(n,{ah:function(){return a}});var r=t(7294);const i=r.createContext({});function a(e){const n=r.useContext(i);return r.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);
//# sourceMappingURL=component---content-posts-2016-01-27-unity-serializedobject-md-8787059dde69766390a1.js.map