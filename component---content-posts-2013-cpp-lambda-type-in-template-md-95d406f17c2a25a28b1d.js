"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8001],{9998:function(e,n,t){t.r(n);var a=t(1151),c=t(7294);function l(e){const n=Object.assign({p:"p",pre:"pre",code:"code",a:"a"},(0,a.ah)(),e.components);return c.createElement(c.Fragment,null,c.createElement(n.p,null,"(記事復旧のついでに少し修正)"),"\n",c.createElement(n.p,null,"msgpack-rpcの関数登録の都合上、 lambda関数から引数の型を得たい。 下記のような書き方をしたい。"),"\n",c.createElement(n.pre,null,c.createElement(n.code,{className:"language-c++"},"template<typename R, typename A1, typename A2>\nvoid register_func (const std::string &func_name, R(*handler)(A1, A2))\n{\n    // 関数登録\n}\n\nstatic int Add(int a, int b)\n{\n    return a+b;\n}\n\nint main()\n{\n    // 関数ポインタは受けれる\n    register_func(“add”, &Add);\n\n    // lambdaを受けることはできない\n    register_func(“add”, [](int a,  int b)->int{ return a+b; });\n    return 0;\n}\n\n")),"\n",c.createElement(n.p,null,"上記の書き方では普通の関数ポインタを受けることはできるのだが、 std::functionやlambdaは受けられない。"),"\n",c.createElement(n.p,null,"std::functionを受けるには下記のようにすることでできた。"),"\n",c.createElement(n.pre,null,c.createElement(n.code,{className:"language-c++"},"template<typename R, typename A1, typename A2>\nvoid register_func(const std::string &func_name, std::function<R(A1, A2) handler) {\n    //\n}\n")),"\n",c.createElement(n.p,null,"残り、lambdaを受けられる記述方法を知りたいのだがどうしたらよいものか。 下記のような手はうまくいかなかった・・・"),"\n",c.createElement(n.pre,null,c.createElement(n.code,{className:"language-c++"},"template<typename F, typename R, typename A1, typename A2>\nvoid add_handler(const std::string &method, F handler)\n{\n    std::function<R(A1, A2)> f(handler);\n    //add_handler\n}\n\n")),"\n",c.createElement(n.p,null,c.createElement(n.a,{href:"http://d.hatena.ne.jp/osyo-manga/20121205/1354674180"},"lambda expression を 関数ポインタ型へと変換する")," こちらのサイトから decltypeを使ったらなんかできそうな感じがしたので粘っていたのだが、"),"\n",c.createElement(n.p,null,"目的そのものの記事を発見した。 http://stackoverflow.com/questions/6512019/can-we-get-the-type-of-a-lambda-argument"),"\n",c.createElement(n.pre,null,c.createElement(n.code,{className:"language-c++"},"// 2019/08 元記事のコードがよくわからなかったので書き直し。\n\n// decltypeから得たメンバ関数へのポインタを触媒にして型を得る\ntemplate<typename F, typename R, typename C, typename A1, typename A2>\nvoid _register_func(const std::string &func_name, R(C::*m)(A1 a1, A2 a2)const) // constに注意\n{\n    // R: 返り値の型\n    // A1, A2: 引数の型\n    // C: lambdaオブジェクトの型を受ける\n}\n\n// まずあらゆる引数を受け付けられるtemplateでlambdaオブジェクトを受ける(functor)\ntemplate<typename F>\nvoid register_func(const std::string &func_name, F f)\n{\n    _register_func(const std::string &func_name, f, decltype(f)::operator());\n)\n")),"\n",c.createElement(n.p,null,"F で関数ポインタ、lambda、std::function等を受けられるようになった。 decltypeなんかすごいな。"),"\n",c.createElement(n.p,null,"関連して、",c.createElement(n.a,{href:"https://qiita.com/ousttrue/items/6b207e1d431cf20e04d9"},"C++でメンバー関数を、thisを第１引数にとる関数ポインタに変換する"),"。\nメンバ関数へのポインタは意外と使い道がある。"))}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?c.createElement(n,e,c.createElement(l,e)):l(e)}},1151:function(e,n,t){t.d(n,{ah:function(){return l}});var a=t(7294);const c=a.createContext({});function l(e){const n=a.useContext(c);return a.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);
//# sourceMappingURL=component---content-posts-2013-cpp-lambda-type-in-template-md-95d406f17c2a25a28b1d.js.map