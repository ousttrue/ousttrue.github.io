{"version":3,"file":"component---content-posts-2013-06-17-irrlicht-msgpackrpc-md-af4130b054909ebf97e1.js","mappings":"wHAGA,SAASA,EAAkBC,GACzB,MAAMC,EAAcC,OAAOC,OAAO,CAChCC,IAAK,MACLC,KAAM,SACLC,EAAAA,EAAAA,MAAsBN,EAAMO,YAC/B,OAAOC,EAAAA,cAAoBP,EAAYG,IAAK,KAAMI,EAAAA,cAAoBP,EAAYI,KAAM,KAAM,muJAChG,CAKA,UAJA,SAAoBL,QAAK,IAALA,IAAAA,EAAQ,CAAC,GAC3B,MAAOS,QAASC,GAAaR,OAAOC,OAAO,CAAC,GAAGG,EAAAA,EAAAA,MAAsBN,EAAMO,YAC3E,OAAOG,EAAYF,EAAAA,cAAoBE,EAAWV,EAAOQ,EAAAA,cAAoBT,EAAmBC,IAAUD,EAAkBC,EAC9H,C,sECoBO,MAAMW,EAAa,gBAAoB,CAAC,GAiCxC,SAASC,EAAiBL,GAC/B,MAAMM,EAAoB,aAAiBF,GAG3C,OAAO,WAAc,IAEO,mBAAfJ,EACFA,EAAWM,GAGb,IAAIA,KAAsBN,IAChC,CAACM,EAAmBN,GACzB,C","sources":["webpack:///./content/posts/2013/06/17/irrlicht_msgpackrpc.md","webpack:///./node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return React.createElement(_components.pre, null, React.createElement(_components.code, null, \"IrrlichtにMsgPackRPCを仕込む\\nOculusの通販ステータスが早くもProcessingに変わって届くのが楽しみな今日この頃。\\nレンダリングエンジンにはIrrlichtを選択したのであるが、\\nそのままだとシーンを構築するとか諸々の作業がC++直叩きになる。\\nこれだとさすがに大変なのでMsgPackRPCでラップして外部のツールから\\n操作しようと構想しておったのだが始めてみると早速問題に突き当たった。\\nオブジェクトを生成してそのメソッドをコールするのにどうすればいいのか。\\nこういう場合だ。\\nIMesh *mesh=CreateMesh(\\\"miku.pmd\\\");\\nmesh->SetPosition(0, 0, 5);\\n\\nMsgPackRPC経由だと以下のような感じか。\\n# pythonとかそういうの\\nclient=msgpac.rpc.client()\\nmesh=client.call(\\\"CreateMesh\\\", \\\"miku.pmd\\\")\\nclient.call(\\\"Mesh_SetPosition\\\", mesh, 0, 0, 5)\\n\\n1つめのCreateMeshはグローバル関数かシングルトン的オブジェクトのメソッド呼び出しになるので特に問題は無い。\\n2つめはSetPositionのthisとしてmeshを送ってやる必要がある。\\nここでmsgpack的にはIMesh*をシリアライズ/デシリアライズすることが必要になる。\\n案１ ポインタを整数値としてキャストすればいいじゃない\\ntemplate <typename Stream>\\ninline packer<Stream>& operator<< (packer<Stream>& o, IMesh *v)\\n{\\n    // ポインタをintにキャスト\\n    o.pack((int)v);\\n    return o;\\n}\\n\\ninline IMesh *v operator>> (object o, IMesh* v)\\n{\\n    unsigned int p;\\n    o.convert(&p):\\n\\n    // intをポインタにキャスト\\n    v=(IMesh*)p;\\n\\n    return v;\\n}\\n\\nさすがにワイルドすぎる。というかポインタが既に開放されている場合になすすべが無いので没\\n案２ 適当にユニークなIDを振る\\ntemplate <typename Stream>\\ninline packer<Stream>& operator<< (packer<Stream>& o, IMesh *v)\\n{\\n    // ポインタのuid値\\n    o.pack(v->uid());\\n    return o;\\n}\\n\\ninline IMesh *v operator>> (object o, IMesh* v)\\n{\\n    unsigned int uid;\\n    o.convert(&uid):\\n\\n    // uid値からポインタを得る\\n    v=IMesh::get_from_uid(uid);\\n\\n    return v;\\n}\\n\\nIrrlichtだと本体側に改造が要るけどこれでいってみるか。\\ntemplate<typename T>\\nclass IDGenerator\\n{\\n    unsigned int m_uid;\\n\\npublic:\\n    IDGenerator():m_uid(generate_uid())\\n    {\\n        m_uid_map.insert(std::make_pair(m_uid, this));\\n    }\\n\\n    unsigned int uid()const\\n    {\\n        return m_uid;\\n    }\\n\\n////////////////////\\n// static\\n////////////////////\\nprivate:\\n    static unsigned int m_next_uid=1;\\n    static std::hash_map<unsigned int, T*> m_uid_map;\\npublic:\\n    static unsigned int generate_uid(){\\n        return m_next_uid++;\\n    }\\n\\n    statc T* get_from_uid(unsigned int uid){\\n        auto found=m_uid_map.find(uid);\\n        if(found==m_uid_map.end()){\\n            return 0;\\n        }\\n        return found->second;\\n    }\\n};\\n\\n// 継承階層のIReferenceCountedの下あたりにこんな感じで介入する予定\\nclass IMesh : public virtual IReferenceCounted, public IDGenerator<IMesh>\\n{\\n};\\n\\nうまくいくかやってみるとしよう。\\n書いてみた\\n自由に書いてみたらこうなった。templateクラスのスタティックメンバ変数の書き方を学んだ。\\nhttp://d.hatena.ne.jp/higepon/20100803/1280834422\\ntemplate<typename T>\\nclass IDGenerator\\n{\\n    struct Deleter{\\n        unsigned int m_uid;\\n\\n        Deleter(unsigned int uid): m_uid(uid){}\\n        ~Deleter(){ remove_from_map(m_uid); }\\n    };\\n    Deleter m_deleter;\\n    unsigned int m_uid;\\n\\npublic:\\n    IDGenerator():m_uid(generate_uid()), m_deleter(m_uid)\\n    {\\n        s_uid_map[m_uid]=this;\\n    }\\n\\n    unsigned int uid()const\\n    {\\n        return m_uid;\\n    }\\n\\n    ////////////////////\\n    // static\\n    ////////////////////\\nprivate:\\n    static core::map<unsigned int, IDGenerator*> s_uid_map;\\npublic:\\n    static unsigned int generate_uid(){\\n        static unsigned int next_uid=1;\\n        return next_uid++;\\n    }\\n\\n    static T* get_from_uid(unsigned int uid){\\n        return s_uid_map.find(uid);\\n    }\\n\\n    static void remove_from_map(unsigned int uid){\\n        s_uid_map.remove(uid);\\n    }\\n};\\ntemplate <typename T> core::map<unsigned int, IDGenerator<T>*> IDGenerator<T>::s_uid_map;\\n\\nしかし、この設計だとstaticメンバがdll境界を越えて２つ存在してうまくいかない罠があった。没\\n案3 適当にユニークなIDを振る(非テンプレート)\\nirr::IReferenceCountedを改造する。\\n小賢しいtemplateをやめてべたにグローバル変数を隠蔽する方式を導入した。\\nclass IReferenceCounted\\n{\\npublic:\\n\\n    //! Constructor.\\n    IReferenceCounted()\\n        : DebugName(0), ReferenceCounter(1), UID(get_uid())\\n    {\\n        register_uid(UID, this);\\n    }\\n\\n    u32 uid(){ return UID; }\\n\\n    //! Destructor.\\n    virtual ~IReferenceCounted()\\n    {\\n        unregister_uid(UID);\\n    }\\n\\n\\n// 省略\\n\\n};\\n\\n\\n#include \\\"IDGenerator.h\\\"\\n#include \\\"IReferenceCounted.h\\\"\\n#include \\\"irrMap.h\\\"\\n\\nnamespace irr {\\n\\n    extern \\\"C\\\" IRRLICHT_API u32 get_uid()\\n    {\\n        static u32 uid=1;\\n        return uid++;\\n    }\\n\\n    static core::map<u32, IReferenceCounted*> g_map;\\n\\n    extern \\\"C\\\" IRRLICHT_API void register_uid(u32 uid, IReferenceCounted *p)\\n    {\\n        g_map.set(uid, p);\\n    }\\n\\n    extern \\\"C\\\" IRRLICHT_API void unregister_uid(u32 uid)\\n    {\\n        auto found=g_map.remove(uid);\\n    }\\n\\n    extern \\\"C\\\" IRRLICHT_API IReferenceCounted* get_from_uid(u32 uid)\\n    {\\n        auto found=g_map.find(uid);\\n        if(!found){\\n            return 0;\\n        }\\n        return found->getValue();\\n    }\\n}\\n\\n動作確認できた。\\nここまでの作業でMsgPackRPCを使ったIrrlichtエクスポートについて見通しを得ることができた。\\nPythonやLuaから使えるようにするのと同じような作業でリモートから関数をコールできるようになるのでいい感じだ。\\n呼び出し側にPythonのMsgPackRPCを使えば違う言語からでも呼び出せるので一石二鳥というもの。\\nということで引き続き作業を進める。\\nMsgPackRPCのリモート呼び出しを利用したシーンエディタを作りながら表示できるものを増やしていく。\\n\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('mdx/types.js').MDXComponents} Components\n *\n * @typedef Props\n *   Configuration.\n * @property {Components | MergeComponents | null | undefined} [components]\n *   Mapping of names for JSX components to React components.\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context.\n * @property {ReactNode | null | undefined} [children]\n *   Children.\n *\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Components} currentComponents\n *   Current components from the context.\n * @returns {Components}\n *   Merged components.\n */\n\nimport React from 'react'\n\n/**\n * @type {import('react').Context<Components>}\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components and\n *   `MDXProvider` to set context based components instead.\n */\nexport const MDXContext = React.createContext({})\n\n/**\n * @param {import('react').ComponentType<any>} Component\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components instead.\n */\nexport function withMDXComponents(Component) {\n  return boundMDXComponent\n\n  /**\n   * @param {Record<string, unknown> & {components?: Components | null | undefined}} props\n   * @returns {JSX.Element}\n   */\n  function boundMDXComponent(props) {\n    const allComponents = useMDXComponents(props.components)\n    return React.createElement(Component, {...props, allComponents})\n  }\n}\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Components | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that takes the current\n *   components and filters/merges/changes them.\n * @returns {Components}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(() => {\n    // Custom merge via a function prop\n    if (typeof components === 'function') {\n      return components(contextComponents)\n    }\n\n    return {...contextComponents, ...components}\n  }, [contextComponents, components])\n}\n\n/** @type {Components} */\nconst emptyObject = {}\n\n/**\n * Provider for MDX context\n *\n * @param {Props} props\n * @returns {JSX.Element}\n */\nexport function MDXProvider({components, children, disableParentContext}) {\n  /** @type {Components} */\n  let allComponents\n\n  if (disableParentContext) {\n    allComponents =\n      typeof components === 'function'\n        ? components({})\n        : components || emptyObject\n  } else {\n    allComponents = useMDXComponents(components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","pre","code","_provideComponents","components","React","wrapper","MDXLayout","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}