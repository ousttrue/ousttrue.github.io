{"version":3,"file":"component---content-posts-2016-01-23-webpack-md-a133120d56f449381416.js","mappings":"yHAGA,SAASA,EAAkBC,GACzB,MAAMC,EAAcC,OAAOC,OAAO,CAChCC,EAAG,IACHC,IAAK,MACLC,KAAM,SACLC,EAAAA,EAAAA,MAAsBP,EAAMQ,YAC/B,OAAOC,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,sDAAuD,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,kCAAmC,KAAMK,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,4DAA6D,KAAMK,EAAAA,cAAoBR,EAAYI,IAAK,KAAMI,EAAAA,cAAoBR,EAAYK,KAAM,KAAM,wxKAC9a,CAKA,UAJA,SAAoBN,QAAK,IAALA,IAAAA,EAAQ,CAAC,GAC3B,MAAOU,QAASC,GAAaT,OAAOC,OAAO,CAAC,GAAGI,EAAAA,EAAAA,MAAsBP,EAAMQ,YAC3E,OAAOG,EAAYF,EAAAA,cAAoBE,EAAWX,EAAOS,EAAAA,cAAoBV,EAAmBC,IAAUD,EAAkBC,EAC9H,C,sECmBO,MAAMY,EAAa,gBAAoB,CAAC,GAiCxC,SAASC,EAAiBL,GAC/B,MAAMM,EAAoB,aAAiBF,GAG3C,OAAO,WAAc,IAEO,mBAAfJ,EACFA,EAAWM,GAGb,IAAIA,KAAsBN,IAChC,CAACM,EAAmBN,GACzB,C","sources":["webpack:///./content/posts/2016/01/23/webpack.md","webpack:///./node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"gulp だけでいっぱいいっぱいだったので敬遠していた webpack をやってみる。 #ことはじめ\"), \"\\n\", React.createElement(_components.p, null, \"http://webpack.github.io/docs/\"), \"\\n\", React.createElement(_components.p, null, \"http://webpack.github.io/docs/tutorials/getting-started/\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, null, \"webpackをインストールして\\n> npm install webpack -g\\n\\nサンプルファイルを用意して\\nentry.js\\ndocument.write(\\\"It works.\\\");\\n\\nwebpack実行。\\n> webpack ./entry.js bundle.js\\nHash: ca188ee5789bb780fcec\\nVersion: webpack 1.12.12\\nTime: 52ms\\n    Asset     Size  Chunks             Chunk Names\\nbundle.js  1.42 kB       0  [emitted]  main\\n   [0] ./entry.js 28 bytes {0} [built]\\n\\nentry.jsを入力し、bundle.jsが出力される。\\nbundle.js\\n/******/ (function(modules) { // webpackBootstrap\\n/******/    // The module cache\\n/******/    var installedModules = {};\\n\\n/******/    // The require function\\n/******/    function __webpack_require__(moduleId) {\\n\\n/******/        // Check if module is in cache\\n/******/        if(installedModules[moduleId])\\n/******/            return installedModules[moduleId].exports;\\n\\n/******/        // Create a new module (and put it into the cache)\\n/******/        var module = installedModules[moduleId] = {\\n/******/            exports: {},\\n/******/            id: moduleId,\\n/******/            loaded: false\\n/******/        };\\n\\n/******/        // Execute the module function\\n/******/        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n/******/        // Flag the module as loaded\\n/******/        module.loaded = true;\\n\\n/******/        // Return the exports of the module\\n/******/        return module.exports;\\n/******/    }\\n\\n\\n/******/    // expose the modules object (__webpack_modules__)\\n/******/    __webpack_require__.m = modules;\\n\\n/******/    // expose the module cache\\n/******/    __webpack_require__.c = installedModules;\\n\\n/******/    // __webpack_public_path__\\n/******/    __webpack_require__.p = \\\"\\\";\\n\\n/******/    // Load entry module and return exports\\n/******/    return __webpack_require__(0);\\n/******/ })\\n/************************************************************************/\\n/******/ ([\\n/* 0 */\\n/***/ function(module, exports) {\\n\\n    document.write(\\\"It works.\\\");\\n\\n/***/ }\\n/******/ ]);\\n\\nユーティリティと合体したコードが出力された。\\n使う方は、bundle.jsをscriptタグで読み込むと。\\n<script type=\\\"text/javascript\\\" src=\\\"bundle.js\\\" charset=\\\"utf-8\\\"></script>\\n\\n複数ファイルのマージとrequire\\n複数ファイルの参照にrequire関数が導入される。\\nmodule.exports = \\\"It works from content.js.\\\";\\n\\ndocument.write(require(\\\"./content.js\\\"));\\n\\nwebpackする。\\n> webpack ./entry.js bundle.js\\nHash: 71eea1fe067e73397ebe\\nVersion: webpack 1.12.12\\nTime: 64ms\\n    Asset     Size  Chunks             Chunk Names\\nbundle.js  1.55 kB       0  [emitted]  main\\n   [0] ./entry.js 40 bytes {0} [built]\\n   [1] ./content.js 45 bytes {0} [built]\\n\\nbundle.jsが出力される。\\nbundle.jsの概要\\n(function(modules) { // webpackBootstrap\\n\\n// 省略\\n\\n    // Load entry module and return exports\\n    return __webpack_require__(0);\\n})\\n/************************************************************************/\\n( /* 無名関数を即実行 */\\n[\\n/* 0 */\\nfunction(module, exports, __webpack_require__) {\\n\\n    document.write(__webpack_require__(1));\\n\\n},\\n/* 1 */\\nfunction(module, exports) {\\n\\n    // content.jsはここに\\n    module.exports = \\\"It works from content.js.\\\";\\n\\n}\\n]);\\n\\nなるほど。自身がmodule[0]になって、requireされたファイルがmodule[1]になるのか。\\ncss対応\\nWebPackは素ではjavascriptしか対応していない。cssに対応するためにloaderを導入する。\\n> npm install css-loader style-loader\\n\\ncssを追加して、\\nstyle.css\\nbody {\\n    background: yellow;\\n}\\n\\nrequireする。\\nloader経由でrequireするには、特殊な記法を用いるらしい。\\nentry.js\\nrequire(\\\"!style!css!./style.css\\\");\\ndocument.write(require(\\\"./content.js\\\"));\\n\\nwebpack実行\\n> webpack ./entry.js bundle.js\\nHash: c8494a414a3a1d5c8c29\\nVersion: webpack 1.12.12\\nTime: 716ms\\n    Asset     Size  Chunks             Chunk Names\\nbundle.js  11.8 kB       0  [emitted]  main\\n   [0] ./entry.js 76 bytes {0} [built]\\n   [5] ./content.js 45 bytes {0} [built]\\n    + 4 hidden modules\\n\\n6つモジュールができたと書いてあります。\\n確かに、最初の無名関数への引数が6要素の配列になっている。\\nmodules[2]にさっきのcssがjavascript化されて入っている。\\n/***/ },\\n/* 2 */\\n/***/ function(module, exports, __webpack_require__) {\\n\\n    exports = module.exports = __webpack_require__(3)();\\n    // imports\\n\\n\\n    // module\\n    exports.push([module.id, \\\"body {\\\\r\\\\n    background: yellow;\\\\r\\\\n}\\\", \\\"\\\"]);\\n\\n    // exports\\n\\n\\n/***/ },\\n\\nwebpackは何もかもをjavascript化してrequireするシステムなのか！？\\nconfigfile\\nコマンドライン引数を設定に移動。\\nwebpack.config.js\\nmodule.exports = {\\n    entry: \\\"./entry.js\\\",\\n    output: {\\n        path: __dirname,\\n        filename: \\\"bundle.js\\\"\\n    },\\n    module: {\\n        loaders: [\\n            { test: /\\\\.css$/, loader: \\\"style!css\\\" }\\n        ]\\n    }\\n};\\n\\n引数無しで実行できる。\\n> webpack\\nHash: 1141db5208a3ce352fb6\\nVersion: webpack 1.12.12\\nTime: 669ms\\n    Asset     Size  Chunks             Chunk Names\\nbundle.js  11.8 kB       0  [emitted]  main\\n   [0] ./entry.js 67 bytes {0} [built]\\n   [5] ./content.js 45 bytes {0} [built]\\n    + 4 hidden modules\\n\\nWatchモードとか開発サーバーもあるで\\nwatchモード。\\n> webpack --progress --colors --watch\\n\\ndev-serverをインストール。\\n> npm install webpack-dev-server -g\\n\\n> webpack-dev-server --progress --colors\\n\\n\\nhttp://localhost:8080 で静的なコンパイル結果を表示\\nhttp://localhost:8080/webpack-dev-server/bundle で自動リロード付き\\n\\ngulpでがんばってwatchからbrowser-syncを構築していたのをさくっとできるね。\\nこれはよさげ。\\n機能的にはブラウザ側(いわゆるフロントエンド)に特化しているぽいな。\\nサーバーサイドとの連携方法を探る必要がある。\\nbrowsery-syncとnodemonの連携みたいにproxyを駆使するのか。\\n参考\\n\\nwebpack で Node サーバー用のコードを bundle する\\nhttps://webpack.github.io/docs/webpack-dev-server.html#proxy\\nhttp://stackoverflow.com/questions/26203725/how-to-allow-for-webpack-dev-server-to-allow-entry-points-from-react-router\\n\")));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('mdx/types.js').MDXComponents} Components\n *\n * @typedef Props\n *   Configuration.\n * @property {Components | MergeComponents | null | undefined} [components]\n *   Mapping of names for JSX components to React components.\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context.\n * @property {ReactNode | null | undefined} [children]\n *   Children.\n *\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Components} currentComponents\n *   Current components from the context.\n * @returns {Components}\n *   Merged components.\n */\n\nimport React from 'react'\n\n/**\n * @type {import('react').Context<Components>}\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components and\n *   `MDXProvider` to set context based components instead.\n */\nexport const MDXContext = React.createContext({})\n\n/**\n * @param {import('react').ComponentType<any>} Component\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components instead.\n */\nexport function withMDXComponents(Component) {\n  return boundMDXComponent\n\n  /**\n   * @param {Record<string, unknown> & {components?: Components | null | undefined}} props\n   * @returns {JSX.Element}\n   */\n  function boundMDXComponent(props) {\n    const allComponents = useMDXComponents(props.components)\n    return React.createElement(Component, {...props, allComponents})\n  }\n}\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Components | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that takes the current\n *   components and filters/merges/changes them.\n * @returns {Components}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(() => {\n    // Custom merge via a function prop\n    if (typeof components === 'function') {\n      return components(contextComponents)\n    }\n\n    return {...contextComponents, ...components}\n  }, [contextComponents, components])\n}\n\n/** @type {Components} */\nconst emptyObject = {}\n\n/**\n * Provider for MDX context\n *\n * @param {Props} props\n * @returns {JSX.Element}\n */\nexport function MDXProvider({components, children, disableParentContext}) {\n  /** @type {Components} */\n  let allComponents\n\n  if (disableParentContext) {\n    allComponents =\n      typeof components === 'function'\n        ? components({})\n        : components || emptyObject\n  } else {\n    allComponents = useMDXComponents(components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","p","pre","code","_provideComponents","components","React","wrapper","MDXLayout","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}