{"version":3,"file":"component---content-posts-2015-12-11-express-socket-io-md-36bc6099d37d30369646.js","mappings":"yHAGA,SAASA,EAAkBC,GACzB,MAAMC,EAAcC,OAAOC,OAAO,CAChCC,EAAG,IACHC,IAAK,MACLC,KAAM,SACLC,EAAAA,EAAAA,MAAsBP,EAAMQ,YAC/B,OAAOC,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBR,EAAYG,EAAG,KAAM,yBAA0B,KAAMK,EAAAA,cAAoBR,EAAYI,IAAK,KAAMI,EAAAA,cAAoBR,EAAYK,KAAM,KAAM,0zRACnN,CAKA,UAJA,SAAoBN,QAAK,IAALA,IAAAA,EAAQ,CAAC,GAC3B,MAAOU,QAASC,GAAaT,OAAOC,OAAO,CAAC,GAAGI,EAAAA,EAAAA,MAAsBP,EAAMQ,YAC3E,OAAOG,EAAYF,EAAAA,cAAoBE,EAAWX,EAAOS,EAAAA,cAAoBV,EAAmBC,IAAUD,EAAkBC,EAC9H,C,sECmBO,MAAMY,EAAa,gBAAoB,CAAC,GAiCxC,SAASC,EAAiBL,GAC/B,MAAMM,EAAoB,aAAiBF,GAG3C,OAAO,WAAc,IAEO,mBAAfJ,EACFA,EAAWM,GAGb,IAAIA,KAAsBN,IAChC,CAACM,EAAmBN,GACzB,C","sources":["webpack:///./content/posts/2015/12/11/express_socket.io.md","webpack:///./node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"Socket.IO を実験する環境のメモ。\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, null, \"Expressは、serve-staticで静的なファイルのhostingが目的兼後で拡張できるように\\ncoffee-scriptは無しでES6要素をなるべく入れる\\nSocket.IOを手早く展開するのが目的なのでtypescriptは抜きにしようと思ったが、無い方がつらいので矢張り入れる\\n\\nhttps://github.com/ousttrue/sio_sample\\nProject生成\\n> mkdir sio_sample\\n> cd sio_sample\\nsio_sample> npm init -y\\nsio_sample> npm install gulp gulp-load-plugins gulp-nodemon browser-sync -D\\nsio_sample> npm install express socket.io body-parser method-override connect-logger errorhandler serve-static --save\\n\\nvscodeでes6を使えるように\\njsconifg.json\\n{\\n    \\\"compilerOptions\\\": {\\n        \\\"target\\\": \\\"ES6\\\"\\n    }\\n}\\n\\n後で拡張できるように以下のようなディレクトリ構成にする。\\nbuild <- srcから(加工して)コピーされる\\n\\nsrc <- 加工前のファイル置き場\\n  + server\\n    + app.js\\n  + client\\n    + index.html\\n    + index.js\\n\\nsrc/server/app.js\\n\\\"use strict\\\";\\n\\nconst http = require('http');\\nconst express = require('express');\\nconst port = process.env.port || 3000;\\nconst app = express();\\nconst server = http.createServer(app);\\nconst servestatic = require('serve-static');\\nconst serve_dir = __dirname + '/public';\\nconsole.log('serve %s', serve_dir);\\napp\\n    .use(servestatic(serve_dir))\\n;\\n\\n// socket.io\\nconst socketio = require('socket.io');\\nconst io = socketio(server);\\nio.on('connection', (socket) => {\\n    console.log('a client connected %s', socket);\\n    socket.on('disconnect', () => {\\n        console.log('a client disconnected');\\n    });\\n});\\n\\n// start\\nserver.listen(port);\\nconsole.log('start port: %d...', port);\\n\\nsrc/client/index.html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <title>Document</title>\\n    <script src=\\\"index.js\\\"></script>\\n</head>\\n<body>\\n    <div id=\\\"target\\\"></div>\\n</body>\\n</html>\\n\\nsrc/client/index.js\\n\\\"use strict\\\";\\n\\nfunction setup(target) {\\n    const div = document.createElement('div');\\n    div.appendChild(document.createTextNode('onLoad'));\\n    target.appendChild(div);\\n}\\n\\nwindow.onload = () => {\\n\\n    setup(document.getElementById('target'));\\n\\n};\\n\\nsrcからbuildに展開するgulp\\ngulpfile.js\\nconst gulp = require('gulp');\\nconst $ = require('gulp-load-plugins')();\\n\\nconst config = {\\n    server_src: './src/server/**/*',\\n    server_dst: './build',\\n    client_src: './src/client/**/*',\\n    client_dst: './build/public'\\n};\\n\\ngulp.task('server', () => {\\n    gulp.src(config.server_src)\\n        .pipe(gulp.dest(config.server_dst));\\n});\\n\\ngulp.task('client', () => {\\n    gulp.src(config.client_src)\\n        .pipe(gulp.dest(config.client_dst));\\n});\\n\\ngulp.task('default', ['server', 'client']);\\n\\nbuild\\nsio_sample> gulp\\n\\nブラウザで動いた。\\nbrowserSync導入\\ngulpfile.js。browserSync\\nconst config = { // 追加分\\n    app_entry: './build/app.js',\\n    app_port: 5000,\\n};\\n\\nconst browserSync = require('browser-sync').create();\\ngulp.task('serve', ()=>{\\n    $.nodemon({\\n        script: config.app_entry,\\n        exp: 'js',\\n        ignore: [],\\n        env: {\\n            port: config.app_port\\n        }\\n    })\\n    .on('readable', ()=>{\\n        this.stdout.on('data', (chunk)=>{\\n            if (/^start /.test(chunk)){\\n                console.log('reloading...');\\n                browserSync.reload();\\n            }\\n            process.stdout.write(chunk)\\n        });\\n    });\\n});\\n\\ngulp.task('browser-sync', ['serve'], ()=>{\\n    browserSync.init({\\n        proxy: 'localhost:' + config.app_port,\\n        port: 3000,\\n        ws: true\\n    })\\n});\\n\\ngulpfile.js。watchタスク追加\\ngulp.task('server', () => {\\n    gulp.src(config.server_src)\\n        .pipe(gulp.dest(config.server_dst))\\n        .pipe(browserSync.stream())\\n        ;\\n});\\n\\ngulp.task('client', () => {\\n    gulp.src(config.client_src)\\n        .pipe(gulp.dest(config.client_dst))\\n        .pipe(browserSync.stream())\\n        ;\\n});\\n\\ngulp.task('build', ['server', 'client']);\\n\\ngulp.task('watch', ['build', 'browser-sync'], ()=>{\\n    gulp.watch(config.server_src, ['server']);\\n    gulp.watch(config.client_src, ['client']);\\n});\\n\\ngulp.task('default', ['watch']);\\n\\ngit\\nいったんgitに登録しよう。\\n.gitignore\\n/node_modules/\\n/build/\\n\\nSocket.IOの疎通\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <title>Document</title>\\n    <script type=\\\"text/javascript\\\" src=\\\"/socket.io/socket.io.js\\\"></script>\\n    <script src=\\\"index.js\\\"></script>\\n</head>\\n<body>\\n    <div id=\\\"target\\\"></div>\\n</body>\\n</html>\\n\\n\\\"use strict\\\";\\n\\nfunction setup(target) {\\n    const div = document.createElement('div');\\n    div.appendChild(document.createTextNode('hello'));\\n    target.appendChild(div);\\n\\n    this.socket = io.connect();\\n}\\n\\nwindow.onload = () => {\\n    setup(document.getElementById('target'));\\n};\\n\\ntypescript導入\\nsio_sample> tsc --init\\n\\ntsconfig.json\\n{\\n    \\\"compilerOptions\\\": {\\n        \\\"module\\\": \\\"commonjs\\\",\\n        \\\"target\\\": \\\"es5\\\",\\n        \\\"noImplicitAny\\\": true,\\n        \\\"outDir\\\": \\\".\\\",\\n        \\\"rootDir\\\": \\\".\\\",\\n        \\\"sourceMap\\\": false\\n    },\\n    \\\"exclude\\\": [\\n        \\\"node_modules\\\"\\n    ]\\n}\\n\\nsio_sample> npm install gulp-typescript gulp-if gulp-plumber gulp-debug -D\\nsio_sample> cd src\\nsio_sample/src> tsd init\\nsio_sample/src> tsd query node express socket.io -rosa install\\n\\ngulpfile.js。typescriptのコンパイルを追加\\nconst path = require('path');\\nconst tsconfig = require('./tsconfig.json');\\nconst isTypescript = (file) => {\\n    const ext = path.extname(file.path).toLowerCase();\\n    return ext === '.ts';\\n}\\n\\ngulp.task('server', () => {\\n    gulp.src(config.server_src)\\n        .pipe($.plumber())\\n        .pipe($.if(isTypescript, $.typescript(tsconfig.compilerOptions)))\\n        .pipe($.debug('server'))\\n        .pipe(gulp.dest(config.server_dst))\\n        .pipe(browserSync.stream())\\n    ;\\n});\\n\\ngulp.task('client', () => {\\n    gulp.src(config.client_src)\\n        .pipe($.plumber())\\n        .pipe($.if(isTypescript, $.typescript(tsconfig.compilerOptions)))\\n        .pipe($.debug('client'))\\n        .pipe(gulp.dest(config.client_dst))\\n        .pipe(browserSync.stream())\\n    ;\\n});\\n\\nsrc/server/app.jsをapp.tsにリネーム\\n/// <reference path=\\\"../typings/tsd.d.ts\\\" />\\n\\\"use strict\\\";\\n\\nimport http = require('http');\\nimport express = require('express');\\nconst port = process.env.port || 3000;\\nconst app = express();\\nconst server = http.createServer(app);\\nconst servestatic = require('serve-static');\\nconst serve_dir = __dirname + '/public';\\nconsole.log('serve %s', serve_dir);\\napp\\n    .use(servestatic(serve_dir))\\n;\\n\\n// socket.io\\nimport socketio = require('socket.io');\\nconst io = socketio(server);\\nio.on('connection', (socket) => {\\n    var clientAddress=socket.client.conn.remoteAddress;\\n    console.log('connected: %s', clientAddress);\\n    socket.on('disconnect', () => {\\n        console.log('disconnected: %s', clientAddress);\\n    });\\n});\\n\\n// start\\nserver.listen(port);\\nconsole.log('start port: %d...', port);\\n\\nsrc/client/index.jsをindex.tsにリネーム\\n/// <reference path=\\\"../typings/tsd.d.ts\\\" />\\n\\\"use strict\\\";\\n\\ndeclare module io {\\n    export function connect(): SocketIO.Socket;\\n}\\n\\nfunction setup(target: Element) {\\n    const div = document.createElement('div');\\n    div.appendChild(document.createTextNode('hello socket.io'));\\n    target.appendChild(div);\\n\\n    this.socket = io.connect();\\n}\\n\\nwindow.onload = () => {\\n\\n    setup(document.getElementById('target'));\\n\\n};\\n\\nメッセージをやり取り\\nsrc/server/app.ts サーバーサイド。client-messageを受けてserver-messageを発行\\n// socket.io\\nimport socketio = require('socket.io');\\nconst io = socketio(server);\\nio.on('connection', (socket) => {\\n    var clientAddress = socket.client.conn.remoteAddress;\\n    console.log('connected: %s', clientAddress);\\n    socket.on('disconnect', () => {\\n        console.log('disconnected: %s', clientAddress);\\n    });\\n\\n    socket.on('client-message', (data: any) => {\\n        socket.emit('server-message', 'server clicked message');\\n    });\\n});\\n\\nsrc/client/index.ts クライアントサイド。buttonを押したらclient-messageを発行。server-messageを受けてテキストを描画\\n/// <reference path=\\\"../typings/tsd.d.ts\\\" />\\n\\\"use strict\\\";\\n\\ndeclare module io {\\n    export function connect(): SocketIO.Socket;\\n}\\n\\nclass Client {\\n    socket: SocketIO.Socket;\\n\\n    constructor() {\\n        this.socket = io.connect();\\n    }\\n\\n    setup(target: Element) {\\n        const div = document.createElement('div');\\n        div.appendChild(document.createTextNode('hello socket.io'));\\n        target.appendChild(div);\\n\\n        this.socket.on('server-message', (data: any)=>{\\n            const div = document.createElement('div');\\n            div.appendChild(document.createTextNode(data.toString()));\\n            target.appendChild(div);\\n        });\\n\\n        const button=document.createElement('button');\\n        button.appendChild(document.createTextNode('send'));\\n        button.onclick=(ev: MouseEvent)=>{\\n            this.socket.emit('client-message', 'clicked');\\n        };\\n        target.appendChild(button);\\n    }\\n}\\nvar client=new Client();\\n\\nwindow.onload = () => {\\n\\n    client.setup(document.getElementById('target'));\\n\\n};\\n\")));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('mdx/types.js').MDXComponents} Components\n *\n * @typedef Props\n *   Configuration.\n * @property {Components | MergeComponents | null | undefined} [components]\n *   Mapping of names for JSX components to React components.\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context.\n * @property {ReactNode | null | undefined} [children]\n *   Children.\n *\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Components} currentComponents\n *   Current components from the context.\n * @returns {Components}\n *   Merged components.\n */\n\nimport React from 'react'\n\n/**\n * @type {import('react').Context<Components>}\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components and\n *   `MDXProvider` to set context based components instead.\n */\nexport const MDXContext = React.createContext({})\n\n/**\n * @param {import('react').ComponentType<any>} Component\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components instead.\n */\nexport function withMDXComponents(Component) {\n  return boundMDXComponent\n\n  /**\n   * @param {Record<string, unknown> & {components?: Components | null | undefined}} props\n   * @returns {JSX.Element}\n   */\n  function boundMDXComponent(props) {\n    const allComponents = useMDXComponents(props.components)\n    return React.createElement(Component, {...props, allComponents})\n  }\n}\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Components | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that takes the current\n *   components and filters/merges/changes them.\n * @returns {Components}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(() => {\n    // Custom merge via a function prop\n    if (typeof components === 'function') {\n      return components(contextComponents)\n    }\n\n    return {...contextComponents, ...components}\n  }, [contextComponents, components])\n}\n\n/** @type {Components} */\nconst emptyObject = {}\n\n/**\n * Provider for MDX context\n *\n * @param {Props} props\n * @returns {JSX.Element}\n */\nexport function MDXProvider({components, children, disableParentContext}) {\n  /** @type {Components} */\n  let allComponents\n\n  if (disableParentContext) {\n    allComponents =\n      typeof components === 'function'\n        ? components({})\n        : components || emptyObject\n  } else {\n    allComponents = useMDXComponents(components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","p","pre","code","_provideComponents","components","React","wrapper","MDXLayout","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}