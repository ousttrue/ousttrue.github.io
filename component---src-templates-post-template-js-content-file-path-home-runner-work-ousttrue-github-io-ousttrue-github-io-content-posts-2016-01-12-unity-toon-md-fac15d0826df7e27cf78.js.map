{"version":3,"file":"component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2016-01-12-unity-toon-md-fac15d0826df7e27cf78.js","mappings":"+JAGA,SAASA,EAAkBC,GACzB,MAAMC,EAAcC,OAAOC,OAAO,CAChCC,EAAG,IACHC,KAAM,SACLC,EAAAA,EAAAA,MAAsBN,EAAMO,YAC/B,OAAOC,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBP,EAAYG,EAAG,KAAM,qBAAsB,KAAMI,EAAAA,cAAoBP,EAAYI,KAAM,CAC1JI,wBAAyB,CACvBC,OAAQ,0/iBAGd,CAKA,MAJA,SAAoBV,QAAK,IAALA,IAAAA,EAAQ,CAAC,GAC3B,MAAOW,QAASC,GAAaV,OAAOC,OAAO,CAAC,GAAGG,EAAAA,EAAAA,MAAsBN,EAAMO,YAC3E,OAAOK,EAAYJ,EAAAA,cAAoBI,EAAWZ,EAAOQ,EAAAA,cAAoBT,EAAmBC,IAAUD,EAAkBC,EAC9H,E,8BCVA,MAAMO,EAAa,CACjBM,KAAMC,IAA2B,IAA1B,SAACC,EAAQ,UAAEC,GAAUF,EAC1B,OAAOE,EAAYR,EAAAA,cAAoBS,EAAAA,EAAsB,CAC3DD,UAAWA,GACVD,GAAYP,EAAAA,cAAoB,OAAQ,KAAMO,EAAS,GAG9D,SAASG,EAAYC,GAAmB,IAAlB,KAACC,EAAI,SAAEL,GAASI,EACpC,MAAME,EAAcD,EAAKE,IAAID,YAC7B,OAAOb,EAAAA,cAAoBe,EAAAA,EAAQ,KAAMf,EAAAA,cAAoB,KAAM,KAAMa,EAAYG,OAAQhB,EAAAA,cAAoB,MAAO,CACtHQ,UAAW,cACVK,EAAYI,MAAQJ,EAAYI,KAAKC,OAAS,GAAKL,EAAYI,KAAKE,KAAIC,GAClEpB,EAAAA,cAAoBqB,EAAAA,GAAM,CAC/BC,GAAI,SAASF,EAAG,IAChBG,SAAU,OACTvB,EAAAA,cAAoB,SAAU,KAAMoB,OACpCpB,EAAAA,cAAoBwB,EAAAA,GAAa,CACpCzB,WAAYA,GACXQ,GACL,CACe,SAASkB,EAAiBjC,GACvC,OAAOQ,EAAAA,cAAoBU,EAAclB,EAAOQ,EAAAA,cAAoB0B,EAAqBlC,GAC3F,C","sources":["webpack:///./content/posts/2016/01/12/unity_toon.md","webpack:///./src/templates/post-template.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"Toon シェーダーをやってみる。\"), \"\\n\", React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\"><pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">メニューからインポートすると、\\nAssets > Import Package > Effects\\n\\nAssetsが現れる。\\nStandard Assets/Effects/ToonShading\\n\\nToon/Lit\\nStandard Assets/Effects/ToonShadingのshaderを自分のフォルダにコピーして改造する。\\n#UsePassを展開して改造準備\\nShader \\\"MyToon/Lit Outline\\\" {\\n    Properties {\\n        _Color (\\\"Main Color\\\", Color) = (0.5,0.5,0.5,1)\\n        _OutlineColor (\\\"Outline Color\\\", Color) = (0,0,0,1)\\n        _Outline (\\\"Outline width\\\", Range (.002, 0.03)) = .005\\n        _MainTex (\\\"Base (RGB)\\\", 2D) = \\\"white\\\" {}\\n        _Ramp (\\\"Toon Ramp (RGB)\\\", 2D) = \\\"gray\\\" {}\\n    }\\n\\n    SubShader {\\n        Tags { \\\"RenderType\\\"=\\\"Opaque\\\" }\\n        UsePass \\\"Toon/Lit/FORWARD\\\"\\n        UsePass \\\"Toon/Basic Outline/OUTLINE\\\"\\n    }\\n\\n    Fallback \\\"Toon/Lit\\\"\\n}\\n\\nToon/Litのinspectorの\\nSurface shader: Show generated code\\n\\nから該当するFORWARD Passをコピペし、\\nToon/Basic OutlineのOUTLINE Passをコピペする。\\n適当に整理する。\\nShader \\\"MyToon/Custom\\\"\\n{\\n    Properties\\n    {\\n        _Color(\\\"Main Color\\\", Color) = (0.5,0.5,0.5,1)\\n        _MainTex(\\\"Base (RGB)\\\", 2D) = \\\"white\\\" {}\\n        _Ramp(\\\"Toon Ramp (RGB)\\\", 2D) = \\\"gray\\\" {}\\n\\n        _OutlineColor(\\\"Outline Color\\\", Color) = (0,0,0,1)\\n        _Outline(\\\"Outline width\\\", Range(.002, 0.03)) = .005\\n    }\\n    SubShader\\n    {\\n        Tags { \\\"RenderType\\\"=\\\"Opaque\\\" }\\n        LOD 100\\n\\n        // ---- forward rendering base pass:\\n        Pass{\\n            Name \\\"FORWARD\\\"\\n            Tags{ \\\"LightMode\\\" = \\\"ForwardBase\\\" }\\n\\n            CGPROGRAM\\n#pragma vertex vert_surf\\n#pragma fragment frag_surf\\n#pragma lighting ToonRamp exclude_path:prepass\\n#pragma multi_compile_fog\\n#pragma multi_compile_fwdbase\\n#include \\\"Custom.cginc\\\"\\n            ENDCG\\n        }\\n\\n        // outline\\n        Pass{\\n            Name \\\"OUTLINE\\\"\\n            Tags{ \\\"LightMode\\\" = \\\"Always\\\" }\\n            Cull Front\\n            ZWrite On\\n            ColorMask RGB\\n            Blend SrcAlpha OneMinusSrcAlpha\\n\\n            CGPROGRAM\\n#pragma vertex vert\\n#pragma fragment frag\\n#pragma multi_compile_fog\\n#pragma multi_compile_fwdbase\\n#include \\\"Custom.cginc\\\"\\n            ENDCG\\n        }\\n    }\\n\\n    // for shadow etc...\\n    Fallback \\\"Diffuse\\\"\\n}\\n\\n*.shaderファイルのインデントが扱いずらいのでcgincと分割して手で整形。\\n気持ちよくindentできるエディタを見繕う必要があるな・・・\\nCustom.cginc\\n#include \\\"HLSLSupport.cginc\\\"\\n#include \\\"UnityShaderVariables.cginc\\\"\\n// Surface shader code generated based on:\\n// writes to per-pixel normal: no\\n// writes to emission: no\\n// needs world space reflection vector: no\\n// needs world space normal vector: no\\n// needs screen space position: no\\n// needs world space position: no\\n// needs view direction: no\\n// needs world space view direction: no\\n// needs world space position for lighting: no\\n// needs world space view direction for lighting: no\\n// needs world space view direction for lightmaps: no\\n// needs vertex color: no\\n// needs VFACE: no\\n// passes tangent-to-world matrix to pixel shader: no\\n// reads from normal: no\\n// 1 texcoords actually used\\n//   float2 _MainTex\\n#define UNITY_PASS_FORWARDBASE\\n#include \\\"UnityCG.cginc\\\"\\n#include \\\"Lighting.cginc\\\"\\n#include \\\"AutoLight.cginc\\\"\\n\\n#define INTERNAL_DATA\\n#define WorldReflectionVector(data,normal) data.worldRefl\\n#define WorldNormalVector(data,normal) normal\\n\\n// Original surface shader snippet:\\n#line 10 \\\"\\\"\\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\\n#endif\\n\\n//#pragma surface surf ToonRamp\\n\\nsampler2D _Ramp;\\n\\n// custom lighting function that uses a texture ramp based\\n// on angle between light direction and normal\\n//#pragma lighting ToonRamp exclude_path:prepass\\ninline half4 LightingToonRamp(SurfaceOutput s, half3 lightDir, half atten)\\n{\\n#ifndef USING_DIRECTIONAL_LIGHT\\n    lightDir = normalize(lightDir);\\n#endif\\n\\n    half d = dot(s.Normal, lightDir)*0.5 + 0.5;\\n    half3 ramp = tex2D(_Ramp, float2(d, d)).rgb;\\n\\n    half4 c;\\n    c.rgb = s.Albedo * _LightColor0.rgb * ramp * (atten * 2);\\n    c.a = 0;\\n    return c;\\n}\\n\\n\\nsampler2D _MainTex;\\nfloat4 _Color;\\n\\nstruct Input {\\n    float2 uv_MainTex : TEXCOORD0;\\n};\\n\\nvoid surf(Input IN, inout SurfaceOutput o) {\\n    half4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;\\n    o.Albedo = c.rgb;\\n    o.Alpha = c.a;\\n}\\n\\n\\n// vertex-to-fragment interpolation data\\n// no lightmaps:\\n#ifdef LIGHTMAP_OFF\\nstruct v2f_surf {\\n    float4 pos : SV_POSITION;\\n    float2 pack0 : TEXCOORD0; // _MainTex\\n    half3 worldNormal : TEXCOORD1;\\n    fixed3 vlight : TEXCOORD2; // ambient/SH/vertexlights\\n    SHADOW_COORDS(3)\\n        UNITY_FOG_COORDS(4)\\n#if SHADER_TARGET >= 30\\n        float4 lmap : TEXCOORD5;\\n#endif\\n};\\n#endif\\n// with lightmaps:\\n#ifndef LIGHTMAP_OFF\\nstruct v2f_surf {\\n    float4 pos : SV_POSITION;\\n    float2 pack0 : TEXCOORD0; // _MainTex\\n    half3 worldNormal : TEXCOORD1;\\n    float4 lmap : TEXCOORD2;\\n    SHADOW_COORDS(3)\\n        UNITY_FOG_COORDS(4)\\n#ifdef DIRLIGHTMAP_COMBINED\\n        fixed3 tSpace0 : TEXCOORD5;\\n    fixed3 tSpace1 : TEXCOORD6;\\n    fixed3 tSpace2 : TEXCOORD7;\\n#endif\\n};\\n#endif\\nfloat4 _MainTex_ST;\\n\\n// vertex shader\\nv2f_surf vert_surf(appdata_full v) {\\n    v2f_surf o;\\n    UNITY_INITIALIZE_OUTPUT(v2f_surf, o);\\n    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);\\n    o.pack0.xy = TRANSFORM_TEX(v.texcoord, _MainTex);\\n    float3 worldPos = mul(_Object2World, v.vertex).xyz;\\n    fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);\\n#if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)\\n    fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\\n    fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\\n    fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\\n#endif\\n#if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)\\n    o.tSpace0 = fixed3(worldTangent.x, worldBinormal.x, worldNormal.x);\\n    o.tSpace1 = fixed3(worldTangent.y, worldBinormal.y, worldNormal.y);\\n    o.tSpace2 = fixed3(worldTangent.z, worldBinormal.z, worldNormal.z);\\n#endif\\n    o.worldNormal = worldNormal;\\n#ifndef DYNAMICLIGHTMAP_OFF\\n    o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\\n#endif\\n#ifndef LIGHTMAP_OFF\\n    o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\\n#endif\\n\\n    // SH/ambient and vertex lights\\n#ifdef LIGHTMAP_OFF\\n#if UNITY_SHOULD_SAMPLE_SH\\n    float3 shlight = ShadeSH9(float4(worldNormal, 1.0));\\n    o.vlight = shlight;\\n#else\\n    o.vlight = 0.0;\\n#endif\\n#ifdef VERTEXLIGHT_ON\\n    o.vlight += Shade4PointLights(\\n            unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\\n            unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,\\n            unity_4LightAtten0, worldPos, worldNormal);\\n#endif // VERTEXLIGHT_ON\\n#endif // LIGHTMAP_OFF\\n\\n    TRANSFER_SHADOW(o); // pass shadow coordinates to pixel shader\\n    UNITY_TRANSFER_FOG(o, o.pos); // pass fog coordinates to pixel shader\\n    return o;\\n}\\n\\n// fragment shader\\nfixed4 frag_surf(v2f_surf IN) : SV_Target{\\n    // prepare and unpack data\\n    Input surfIN;\\n    UNITY_INITIALIZE_OUTPUT(Input,surfIN);\\n    surfIN.uv_MainTex.x = 1.0;\\n    surfIN.uv_MainTex = IN.pack0.xy;\\n    float3 lightDir = _WorldSpaceLightPos0.xyz;\\n#ifdef UNITY_COMPILER_HLSL\\n    SurfaceOutput o = (SurfaceOutput)0;\\n#else\\n    SurfaceOutput o;\\n#endif\\n    o.Albedo = 0.0;\\n    o.Emission = 0.0;\\n    o.Specular = 0.0;\\n    o.Alpha = 0.0;\\n    o.Gloss = 0.0;\\n    fixed3 normalWorldVertex = fixed3(0,0,1);\\n    o.Normal = IN.worldNormal;\\n    normalWorldVertex = IN.worldNormal;\\n\\n    // call surface function\\n    surf(surfIN, o);\\n\\n    // compute lighting &amp; shadowing factor\\n    UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\\n        fixed4 c = 0;\\n#ifdef LIGHTMAP_OFF\\n    c.rgb += o.Albedo * IN.vlight;\\n#endif // LIGHTMAP_OFF\\n\\n    // lightmaps\\n#ifndef LIGHTMAP_OFF\\n#ifdef DIRLIGHTMAP_OFF\\n    // single lightmap\\n    fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\\n    fixed3 lm = DecodeLightmap(lmtex);\\n#elif DIRLIGHTMAP_COMBINED\\n    // directional lightmaps\\n    fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\\n    half3 lm = DecodeLightmap(lmtex);\\n#elif DIRLIGHTMAP_SEPARATE\\n    // directional with specular - no support\\n    half4 lmtex = 0;\\n    half3 lm = 0;\\n#endif // DIRLIGHTMAP_OFF\\n\\n#endif // LIGHTMAP_OFF\\n\\n\\n    // realtime lighting: call lighting function\\n#ifdef LIGHTMAP_OFF\\n    c += LightingToonRamp(o, lightDir, atten);\\n#else\\n    c.a = o.Alpha;\\n#endif\\n\\n#ifndef LIGHTMAP_OFF\\n    // combine lightmaps with realtime shadows\\n#ifdef SHADOWS_SCREEN\\n#if defined(UNITY_NO_RGBM)\\n    c.rgb += o.Albedo * min(lm, atten * 2);\\n#else\\n    c.rgb += o.Albedo * max(min(lm,(atten * 2)*lmtex.rgb), lm*atten);\\n#endif\\n#else // SHADOWS_SCREEN\\n    c.rgb += o.Albedo * lm;\\n#endif // SHADOWS_SCREEN\\n#endif // LIGHTMAP_OFF\\n\\n#ifndef DYNAMICLIGHTMAP_OFF\\n    fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\\n    c.rgb += o.Albedo * DecodeRealtimeLightmap(dynlmtex);\\n#endif\\n\\n    UNITY_APPLY_FOG(IN.fogCoord, c); // apply fog\\n    UNITY_OPAQUE_ALPHA(c.a);\\n    return c;\\n}\\n\\n//////////////////////////////////////////////////////////////////////////////\\n// outline\\n//////////////////////////////////////////////////////////////////////////////\\n#include \\\"UnityCG.cginc\\\"\\n\\nstruct appdata {\\n    float4 vertex : POSITION;\\n    float3 normal : NORMAL;\\n};\\n\\nstruct v2f {\\n    float4 pos : SV_POSITION;\\n    UNITY_FOG_COORDS(0)\\n        fixed4 color : COLOR;\\n};\\n\\nuniform float _Outline;\\nuniform float4 _OutlineColor;\\n\\nv2f vert(appdata v) {\\n    v2f o;\\n    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);\\n\\n    float3 norm = normalize(mul((float3x3)UNITY_MATRIX_IT_MV, v.normal));\\n    float2 offset = TransformViewToProjection(norm.xy);\\n\\n    o.pos.xy += offset * o.pos.z * _Outline;\\n    o.color = _OutlineColor;\\n    UNITY_TRANSFER_FOG(o, o.pos);\\n    return o;\\n}\\n\\nfixed4 frag(v2f i) : SV_Target\\n{\\n    UNITY_APPLY_FOG(i.fogCoord, i.color);\\n    return i.color;\\n}\\n\\n改造準備完了。\\n改造した\\n\\nalpha blending\\n影と陰の合成とRampの適用法を改造\\n\\nなかなか難しい。\\n顔は別光源にして影が落ちないようにする必要があるね。\\n顔にDiffuseは必要ない。\\n#include \\\"HLSLSupport.cginc\\\"\\n#include \\\"UnityShaderVariables.cginc\\\"\\n// Surface shader code generated based on:\\n// writes to per-pixel normal: no\\n// writes to emission: no\\n// needs world space reflection vector: no\\n// needs world space normal vector: no\\n// needs screen space position: no\\n// needs world space position: no\\n// needs view direction: no\\n// needs world space view direction: no\\n// needs world space position for lighting: no\\n// needs world space view direction for lighting: no\\n// needs world space view direction for lightmaps: no\\n// needs vertex color: no\\n// needs VFACE: no\\n// passes tangent-to-world matrix to pixel shader: no\\n// reads from normal: no\\n// 1 texcoords actually used\\n//   float2 _MainTex\\n#define UNITY_PASS_FORWARDBASE\\n#include \\\"UnityCG.cginc\\\"\\n#include \\\"Lighting.cginc\\\"\\n#include \\\"AutoLight.cginc\\\"\\n\\n#define INTERNAL_DATA\\n#define WorldReflectionVector(data,normal) data.worldRefl\\n#define WorldNormalVector(data,normal) normal\\n\\n// Original surface shader snippet:\\n#line 10 \\\"\\\"\\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\\n#endif\\n\\n//#pragma surface surf ToonRamp\\n\\nsampler2D _Ramp;\\n\\n// custom lighting function that uses a texture ramp based\\n// on angle between light direction and normal\\n//#pragma lighting ToonRamp exclude_path:prepass\\ninline half3 LightingToonRamp(half3 rgb, half diffuse, half atten)\\n{\\n    float d = min(diffuse, atten);\\n    float3 ramp = tex2D(_Ramp, float2(d, d));\\n    return rgb * ramp;\\n}\\n\\nsampler2D _MainTex;\\nfloat4 _Color;\\n\\nstruct Input {\\n    float2 uv_MainTex : TEXCOORD0;\\n};\\n\\nvoid surf(Input IN, inout SurfaceOutput o) {\\n    half4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;\\n    o.Albedo = c.rgb;\\n    o.Alpha = c.a;\\n}\\n\\n\\n// vertex-to-fragment interpolation data\\n// no lightmaps:\\n#ifdef LIGHTMAP_OFF\\nstruct v2f_surf {\\n    float4 pos : SV_POSITION;\\n    float2 pack0 : TEXCOORD0; // _MainTex\\n    half3 worldNormal : TEXCOORD1;\\n    fixed3 vlight : TEXCOORD2; // ambient/SH/vertexlights\\n    SHADOW_COORDS(3)\\n        UNITY_FOG_COORDS(4)\\n#if SHADER_TARGET >= 30\\n        float4 lmap : TEXCOORD5;\\n#endif\\n};\\n#endif\\n// with lightmaps:\\n#ifndef LIGHTMAP_OFF\\nstruct v2f_surf {\\n    float4 pos : SV_POSITION;\\n    float2 pack0 : TEXCOORD0; // _MainTex\\n    half3 worldNormal : TEXCOORD1;\\n    float4 lmap : TEXCOORD2;\\n    SHADOW_COORDS(3)\\n        UNITY_FOG_COORDS(4)\\n#ifdef DIRLIGHTMAP_COMBINED\\n        fixed3 tSpace0 : TEXCOORD5;\\n    fixed3 tSpace1 : TEXCOORD6;\\n    fixed3 tSpace2 : TEXCOORD7;\\n#endif\\n};\\n#endif\\nfloat4 _MainTex_ST;\\n\\n// vertex shader\\nv2f_surf vert_surf(appdata_full v) {\\n    v2f_surf o;\\n    UNITY_INITIALIZE_OUTPUT(v2f_surf, o);\\n    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);\\n    o.pack0.xy = TRANSFORM_TEX(v.texcoord, _MainTex);\\n    float3 worldPos = mul(_Object2World, v.vertex).xyz;\\n    fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);\\n#if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)\\n    fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\\n    fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\\n    fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\\n#endif\\n#if !defined(LIGHTMAP_OFF) &amp;&amp; defined(DIRLIGHTMAP_COMBINED)\\n    o.tSpace0 = fixed3(worldTangent.x, worldBinormal.x, worldNormal.x);\\n    o.tSpace1 = fixed3(worldTangent.y, worldBinormal.y, worldNormal.y);\\n    o.tSpace2 = fixed3(worldTangent.z, worldBinormal.z, worldNormal.z);\\n#endif\\n    o.worldNormal = worldNormal;\\n#ifndef DYNAMICLIGHTMAP_OFF\\n    o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\\n#endif\\n#ifndef LIGHTMAP_OFF\\n    o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\\n#endif\\n\\n    // SH/ambient and vertex lights\\n#ifdef LIGHTMAP_OFF\\n#if UNITY_SHOULD_SAMPLE_SH\\n    float3 shlight = ShadeSH9(float4(worldNormal, 1.0));\\n    o.vlight = shlight;\\n#else\\n    o.vlight = 0.0;\\n#endif\\n#ifdef VERTEXLIGHT_ON\\n    o.vlight += Shade4PointLights(\\n            unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\\n            unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,\\n            unity_4LightAtten0, worldPos, worldNormal);\\n#endif // VERTEXLIGHT_ON\\n#endif // LIGHTMAP_OFF\\n\\n    TRANSFER_SHADOW(o); // pass shadow coordinates to pixel shader\\n    UNITY_TRANSFER_FOG(o, o.pos); // pass fog coordinates to pixel shader\\n    return o;\\n}\\n\\n// fragment shader\\nfixed4 frag_surf(v2f_surf IN) : SV_Target{\\n    // prepare and unpack data\\n    Input surfIN;\\n    UNITY_INITIALIZE_OUTPUT(Input,surfIN);\\n    surfIN.uv_MainTex.x = 1.0;\\n    surfIN.uv_MainTex = IN.pack0.xy;\\n    float3 lightDir = _WorldSpaceLightPos0.xyz;\\n#ifdef UNITY_COMPILER_HLSL\\n    SurfaceOutput o = (SurfaceOutput)0;\\n#else\\n    SurfaceOutput o;\\n#endif\\n    o.Albedo = 0.0;\\n    o.Emission = 0.0;\\n    o.Specular = 0.0;\\n    o.Alpha = 0.0;\\n    o.Gloss = 0.0;\\n    fixed3 normalWorldVertex = fixed3(0,0,1);\\n    o.Normal = IN.worldNormal;\\n    normalWorldVertex = IN.worldNormal;\\n\\n    // call surface function\\n    surf(surfIN, o);\\n\\n    // compute lighting &amp; shadowing factor\\n    UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\\n        fixed4 c = 0;\\n#ifdef LIGHTMAP_OFF\\n    c.rgb += o.Albedo * IN.vlight;\\n#endif // LIGHTMAP_OFF\\n\\n    // lightmaps\\n#ifndef LIGHTMAP_OFF\\n#ifdef DIRLIGHTMAP_OFF\\n    // single lightmap\\n    fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\\n    fixed3 lm = DecodeLightmap(lmtex);\\n#elif DIRLIGHTMAP_COMBINED\\n    // directional lightmaps\\n    fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\\n    half3 lm = DecodeLightmap(lmtex);\\n#elif DIRLIGHTMAP_SEPARATE\\n    // directional with specular - no support\\n    half4 lmtex = 0;\\n    half3 lm = 0;\\n#endif // DIRLIGHTMAP_OFF\\n\\n#endif // LIGHTMAP_OFF\\n\\n\\n    // realtime lighting: call lighting function\\n    c.a = o.Alpha;\\n#ifdef LIGHTMAP_OFF\\n#ifndef USING_DIRECTIONAL_LIGHT\\n    lightDir = normalize(lightDir);\\n#endif\\n    half diffuse = max(0, dot(o.Normal, lightDir));\\n    c.rgb += LightingToonRamp(o.Albedo, diffuse, atten);\\n#else\\n\\n    // combine lightmaps with realtime shadows\\n#ifdef SHADOWS_SCREEN\\n#if defined(UNITY_NO_RGBM)\\n    c.rgb += o.Albedo * min(lm, atten * 2);\\n#else\\n    c.rgb += o.Albedo * max(min(lm,(atten * 2)*lmtex.rgb), lm*atten);\\n#endif\\n#else // SHADOWS_SCREEN\\n    c.rgb += o.Albedo * lm;\\n#endif // SHADOWS_SCREEN\\n#endif // LIGHTMAP_OFF\\n\\n#ifndef DYNAMICLIGHTMAP_OFF\\n    fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\\n    c.rgb += o.Albedo * DecodeRealtimeLightmap(dynlmtex);\\n#endif\\n\\n    UNITY_APPLY_FOG(IN.fogCoord, c); // apply fog\\n\\n    return c;\\n}\\n\\n//////////////////////////////////////////////////////////////////////////////\\n// outline\\n//////////////////////////////////////////////////////////////////////////////\\n#include \\\"UnityCG.cginc\\\"\\n\\nstruct appdata {\\n    float4 vertex : POSITION;\\n    float3 normal : NORMAL;\\n};\\n\\nstruct v2f {\\n    float4 pos : SV_POSITION;\\n    UNITY_FOG_COORDS(0)\\n        fixed4 color : COLOR;\\n};\\n\\nuniform float _Outline;\\nuniform float4 _OutlineColor;\\n\\nv2f vert(appdata v) {\\n    v2f o;\\n    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);\\n\\n    float3 norm = normalize(mul((float3x3)UNITY_MATRIX_IT_MV, v.normal));\\n    float2 offset = TransformViewToProjection(norm.xy);\\n\\n    o.pos.xy += offset * min(1, o.pos.z) * _Outline; // 太さ調整\\n    o.color = _OutlineColor;\\n    UNITY_TRANSFER_FOG(o, o.pos);\\n    return o;\\n}\\n\\nfixed4 frag(v2f i) : SV_Target\\n{\\n    UNITY_APPLY_FOG(i.fogCoord, i.color);\\n    return i.color;\\n}\\n</code></pre></div>\"\n    }\n  }));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import GATSBY_COMPILED_MDX from \"/home/runner/work/ousttrue.github.io/ousttrue.github.io/content/posts/2016/01/12/unity_toon.md\";\nimport React from \"react\";\nimport {graphql} from \"gatsby\";\nimport Layout from \"../components/layout.js\";\nimport {MDXProvider} from \"@mdx-js/react\";\nimport {Link} from \"gatsby\";\nimport PrismSyntaxHighlight from \"../components/prism-syntax-highlight\";\nconst components = {\n  code: ({children, className}) => {\n    return className ? React.createElement(PrismSyntaxHighlight, {\n      className: className\n    }, children) : React.createElement(\"code\", null, children);\n  }\n};\nfunction PostTempalte({data, children}) {\n  const frontmatter = data.mdx.frontmatter;\n  return React.createElement(Layout, null, React.createElement(\"h1\", null, frontmatter.title), React.createElement(\"div\", {\n    className: \"tags-index\"\n  }, frontmatter.tags && frontmatter.tags.length > 0 && frontmatter.tags.map(tag => {\n    return React.createElement(Link, {\n      to: `/tags/${tag}/`,\n      itemProp: \"url\"\n    }, React.createElement(\"button\", null, tag));\n  })), React.createElement(MDXProvider, {\n    components: components\n  }, children));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(PostTempalte, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const query = graphql`\n  query ($id: String!) {\n    mdx(id: { eq: $id }) {\n      frontmatter {\n        title\n        tags\n      }\n    }\n  }\n`;\n"],"names":["_createMdxContent","props","_components","Object","assign","p","span","_provideComponents","components","React","dangerouslySetInnerHTML","__html","wrapper","MDXLayout","code","_ref","children","className","PrismSyntaxHighlight","PostTempalte","_ref2","data","frontmatter","mdx","Layout","title","tags","length","map","tag","Link","to","itemProp","MDXProvider","GatsbyMDXWrapper","GATSBY_COMPILED_MDX"],"sourceRoot":""}