<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>三次元日誌</title>

    

  <script src="https://ousttrue.github.io/plugins/elasticlunr.min.js" defer></script>
  <script src="https://ousttrue.github.io/search_index.en.js" defer></script>
  <script src="https://ousttrue.github.io/js/search.js" defer></script>

    

     
    <link rel="stylesheet" href="https://ousttrue.github.io/main.css">
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css"
      />
    
  </head>

  <body class="container">
    <a class="site_title" href="https:&#x2F;&#x2F;ousttrue.github.io&#x2F;">
      <div>三次元日誌</div>
    </a>

    <nav class="nav">
      <a class="item" href="/tags/">tags</a>
      <a class="item" href="https://github.com/ousttrue" aria-label="github">
        <i class="fab fa-github fa-lg"></i>
      </a>
      

        
            <form class="navbar-form">
                <input id="userinput" class="form-control is-search" type="search" placeholder="Search docs..."
                    aria-label="Search docs..." autocomplete="off">
                <div id="suggestions" class="shadow bg-white rounded"></div>
            </form>
        
    </nav>

    <main class="main">
<div class="page">
<div class="content">
  <div class="headline">
  
  

  
  <a class="headline_title" href="https:&#x2F;&#x2F;ousttrue.github.io&#x2F;gltf&#x2F;draco-basics&#x2F;"> dracoの基本 
  

  
  </a>

  

  <div>
    <ul class="tags">
      <li class="headline_date">
        <div class="year">2017</div>
        <div class="md">1212</div>
      </li>
      
      


    <li class="tag"><a href="https:&#x2F;&#x2F;ousttrue.github.io&#x2F;tags&#x2F;gltf&#x2F;">gltf</a></li>




    </ul>
  </div>
</div>
 <p>Googleのメッシュ圧縮ライブラリDracoの使い方を調査中。</p>
<p>https://github.com/google/draco
コマンドラインツールからobjとply形式の読み書きができるのでそこから解読する。
ポイントクラウドの読み書き
点群を表すdraco::PointCloud型があって、それを継承して面を追加したdraco::Mesh型がある。
まずは、基本となるPointCloudの読み書き。
#include &quot;draco/point_cloud/point_cloud.h&quot;
#include &quot;draco/point_cloud/point_cloud_builder.h&quot;
#include &quot;draco/compression/encode.h&quot;
#include &quot;draco/compression/decode.h&quot;</p>
<p>struct Vector3
{
float x;
float y;
float z;
};</p>
<p>/*
static int AddPositionAttribute(draco::PointCloud *pc, int vertexCount)
{
draco::GeometryAttribute va;
va.Init(draco::GeometryAttribute::POSITION, nullptr, 3, draco::DT_FLOAT32, false, 
sizeof(float) * 3, 0);
return pc-&gt;AddAttribute(va, false, vertexCount);
}
static int AddTexCoordAttribute(draco::PointCloud *pc, int vertexCount)
{
draco::GeometryAttribute va;
va.Init(draco::GeometryAttribute::TEX_COORD, nullptr, 2, draco::DT_FLOAT32, false,
sizeof(float) * 2, 0);
return pc-&gt;AddAttribute(va, false, vertexCount);
}
static int AddNormaldAttribute(draco::PointCloud *pc, int vertexCount)
{
draco::GeometryAttribute va;
va.Init(draco::GeometryAttribute::NORMAL, nullptr, 3, draco::DT_FLOAT32, false,
sizeof(float) * 3, 0);
return pc-&gt;AddAttribute(va, false, vertexCount);
}
*/</p>
<p>int main(int argc, char **argv)
{
Vector3 vertices[] =
{
{-1, -1, -1},
{ -1, 1, -1 },
{ 1, 1, -1 },
{ 1, -1, -1 },
};</p>
<pre style="background-color:#2b303b;">
<code>// setup point cloud
/*
draco::PointCloud pc;
pc.set_num_points(_countof(vertices));

{
    auto pos_att_id = AddPositionAttribute(&amp;pc, _countof(vertices));
    auto attr = pc.attribute(pos_att_id);
    auto size = attr-&gt;size();
    attr-&gt;SetAttributeValue(draco::AttributeValueIndex(0), vertices);
}
*/
draco::PointCloudBuilder builder;
builder.Start(_countof(vertices));
auto pos_att_id = builder.AddAttribute(draco::GeometryAttribute::POSITION, 3, draco::DT_FLOAT32);
for (int i = 0; i &lt; _countof(vertices); ++i) {
    builder.SetAttributeValueForPoint(pos_att_id, draco::PointIndex(i), &amp;vertices[i]);
}
auto res = builder.Finalize(false);

draco::EncoderBuffer encodeBuffer;
{
    // encode
    draco::Encoder encoder;
    auto  status = encoder.EncodePointCloudToBuffer(*res, &amp;encodeBuffer);
}

{
    // decode
    draco::DecoderBuffer decodeBuffer;
    decodeBuffer.Init(encodeBuffer.data(), encodeBuffer.size());

    draco::Decoder decoder;
    auto statusor = decoder.DecodePointCloudFromBuffer(&amp;decodeBuffer);

    auto dpc = std::move(statusor).value();
    auto num = dpc-&gt;NumNamedAttributes(draco::GeometryAttribute::POSITION);
    auto attr = dpc-&gt;GetNamedAttribute(draco::GeometryAttribute::POSITION);
    std::vector&lt;Vector3&gt; positions(attr-&gt;size());
    for (int i = 0; i &lt; positions.size(); ++i)
    {
        attr-&gt;ConvertValue&lt;float, 3&gt;(draco::AttributeValueIndex(i), &amp;positions[i].x);
    }
}

return 0;
</code></pre>
<p>}</p>
<p>参考になるファイルは、</p>
<p>point_cloud_builder_test.cc(build point cloud)
draco_encoder.cc(obj to draco)
draco_decoder.cc(draco to obj)</p>
<p>PointCloud -&gt; dracoとdraco-&gt;PointCloud-&gt;get pointsは簡単でAPIを素直に呼び出せばいい。
問題は如何にPointCloudを構築するか。draco_encoderから解読したローレベルのAPIでやってみたらうまくいかなかったのだが、draco::PointCloudBuilderを発見した。
Meshの読み書き
ToDo…</p>

</div>

<nav class="toc">


</nav>
</div>
</main>

    <footer class="footer">Powered by <a href="https://www.getzola.org/">Zola</a> <a href="https://github.com/ousttrue/zola/tree/custom">custom</a></footer>

  </body>
</html>
