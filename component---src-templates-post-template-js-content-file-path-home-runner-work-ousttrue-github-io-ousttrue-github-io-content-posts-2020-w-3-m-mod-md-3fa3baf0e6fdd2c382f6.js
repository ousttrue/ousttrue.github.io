"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7114],{7287:function(e,n,t){t.r(n),t.d(n,{default:function(){return m}});var l=t(1151),a=t(7294);function c(e){const n=Object.assign({p:"p",a:"a",span:"span",ul:"ul",li:"li",h1:"h1",h2:"h2"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.p,null,"以前にも何度かやったことがあるのだけど立ち消えになっていた、 ",a.createElement(n.a,{href:"http://w3m.sourceforge.net/index.ja.html"},"w3m")," の改造を試みている。\nw3m はわりと好きなテキストブラウザなのだが、 2011 年くらいの 0.5.3 で開発が終了している様子。"),"\n",a.createElement(n.p,null,"https://github.com/ousttrue/w3m"),"\n",a.createElement(n.p,null,"まずは ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">C++</code>'}})," 化してから、HTML処理などを再入可能にしてタブごとにスレッド独立する方向を目指す。\n同時に、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">boehm-GC</code>'}})," を少しずつ ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">STL</code>'}})," のコンテナや ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::string</code>'}})," に置き換える。\nどうも、",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">c++</code>'}})," と ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">boehm-GC</code>'}})," の共存するのに技がいるらしく、適当に置き換えていくとメモリ破壊で死ぬ。",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">boehm-GC</code>'}})," をすべて置き換える必要がありそう。",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">C++</code>'}})," クラスのメンバーに ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">GC</code>'}})," が要る、",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">GC struct</code>'}})," のメンバーに ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">C++</code>'}})," クラスが居るの両方に問題があるっぽい。一応、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gc_cleanup</code>'}})," を継承したりしているのだけど、やり方がまずいぽい。"),"\n",a.createElement(n.p,null,"改造にあたってなるべく機能を維持しようとしていたのだけど、ある程度わりきって機能を落とさないと手に負えないところがある。"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"http + https 以外の通信プロトコルは落とす。NNTP とか Gopher 使ったことないしなー、FTPもいったん落とす"),"\n",a.createElement(n.li,null,"backend, dump, halfload 等の出力に介入する機能は落とす。コードを読むのが大変"),"\n",a.createElement(n.li,null,"M17N, COLOR, IMAGE, MENU は残す"),"\n",a.createElement(n.li,null,"Mouse は微妙。削ってもよいかも"),"\n",a.createElement(n.li,null,"GetText も削る"),"\n"),"\n",a.createElement(n.p,null,"量を減らす。思ったよりコードが多かったのだ。"),"\n",a.createElement(n.h1,null,"下準備"),"\n",a.createElement(n.h2,null,"msys2 でとりあえずビルド"),"\n",a.createElement(n.p,null,"WSL Ubuntu だとビルドできなかった。\nしかし、msys2 ならわりと簡単にビルドできることを発見。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ pacman -S make gcc libgc-devel openssl-devel ncurses-devel\n$ x86_64-pc-msys-gcc --version\nx86_64-pc-msys-gcc (GCC) 9.3.0\nCopyright (C) 2019 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n$ ./configure</code></pre></div>'}}),"\n",a.createElement(n.p,null,"コンパイル環境の方が昔と変わってしまってビルドでエラーになる。"),"\n",a.createElement(n.p,null,"修正方法👇"),"\n",a.createElement(n.p,null,a.createElement(n.a,{href:"https://qiita.com/imkitchen/items/02a9df7baaaf434fee66"},"[CentOS7] emacs24にemacs-w3mインストール")),"\n",a.createElement(n.p,null,a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">#ifdef</code>'}})," の調整"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// config.h\n//#define USE_BINMODE_STREAM 1\n//#define USE_EGD</code></pre></div>'}}),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ make\n$ ./w3m www.google.com // 動いた</code></pre></div>'}}),"\n",a.createElement(n.h2,null,"WSL で GC がクラッシュする問題"),"\n",a.createElement(n.p,null,a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">boehm-GC</code>'}})," がランタイムにエラーになることで、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">make</code>'}})," 中のコード生成 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">mktable</code>'}})," がクラッシュするのが原因でビルドステップが途中で止まるのが原因だった。なので、たとえビルド済みの ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">w3m</code>'}})," を ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">apt get</code>'}})," しても、ランタイムも同じ原因でクラッシュする。"),"\n",a.createElement(n.p,null,"エラー。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Wrong __data_start/_end pair\nfish: \'./build/w3m\' terminated by signal SIGABRT (Abort)</code></pre></div>'}}),"\n",a.createElement(n.p,null,"https://hitkey.nekokan.dyndns.info/diary2004.php#D200424"),"\n",a.createElement(n.p,null,"によると、stack size の制限が原因らしい。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ ulimit -s\n8192</code></pre></div>'}}),"\n",a.createElement(n.p,null,"WSL でこれを変えるには・・・。"),"\n",a.createElement(n.p,null,"https://github.com/microsoft/WSL/issues/633"),"\n",a.createElement(n.p,null,"無理。"),"\n",a.createElement(n.p,null,a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">WSL2</code>'}})," ならできる？"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">> wsl -l -v\n  NAME            STATE           VERSION\n* Ubuntu-20.04    Running         2</code></pre></div>'}}),"\n",a.createElement(n.p,null,"やってみる。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ ulimit -s unlimited\n> ulimit -s\nunlimited</code></pre></div>'}}),"\n",a.createElement(n.p,null,"できた。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ w3m\nWrong __data_start/_end pair</code></pre></div>'}}),"\n",a.createElement(n.p,null,"うーむ。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$ ulimit -s 81920\n> ulimit -s\n81920</code></pre></div>'}}),"\n",a.createElement(n.p,null,"動いた。\n8192KB では足りなく、 unlimited では多すぎるらしい。これは、難しいな。"),"\n",a.createElement(n.p,null,"ちなみに、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gdb</code>'}})," 上ならスタック問題を解決しなくても動いた。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gdb</code>'}})," がスタックを覆い隠すのかな？\n開発だけならできなくもない。"),"\n",a.createElement(n.h2,null,"ビルドシステム"),"\n",a.createElement(n.p,null,"とりあえず慣れたツールに変更。\nWSL 上の vscode で作業しているのもあり、autotools から CMake に変更。\nクロスプラットフォームは後退させて、新しめの gcc(c++20) でビルドできればいいや。\nconfig.h や funcname 系のコード生成結果はコミットしちゃう。\nlibwc が static ライブラリにわかれているのも、ひとまとめにしてしまった。\nあと、適当にソースをフォルダに移動する。"),"\n",a.createElement(n.p,null,"生成コード一覧"),"\n",a.createElement(n.p,null,"| ファイル     | 生成方法          | 入力           | 備考                                                   |\n|--------------|-------------------|----------------|--------------------------------------------------------|\n| config.h     | configure         |                | 各種 #define など                                      |\n| entity.h     | Makefile(mktable) | entity.tab     | ./mktable 100 entity.tab > entity.h                    |\n| funcname.tab | Makefile(awk)     | main.c, menu.c |                                                        |\n| funcname.c   | Makefile(awk)     | funcname.tab   | sort funcname.tab ｜ awk -f funcname0.awk > funcname.c |\n| funcname1.h  | Makefile(awk)     | funcname.tab   |                                                        |\n| funcname2.h  | Makefile(awk)     | funcname.tab   |                                                        |\n| functable.c  | Makefile(mktable) | funcname.tab   |                                                        |\n| tagtable.c   | Makefile(mktable) | funcname.tab   |                                                        |"),"\n",a.createElement(n.h2,null,"警告からエラーに引き上げ"),"\n",a.createElement(n.p,null,"改造していくのに ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">C</code>'}})," の緩い型制限が危険(コンパイルが通るのに型が不一致になりやすい)なので、\n以下のオプションを追加。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">-Werror=implicit-function-declaration\n-Werror=int-conversion\n-Werror=conversion-null</code></pre></div>'}}),"\n",a.createElement(n.p,null,"これで、型宣言を補強しながら進める。"),"\n",a.createElement(n.h1,null,"第1段階"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,'extern "C" を追加してソースの拡張子を ',a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">.cpp</code>'}})," に変更"),"\n",a.createElement(n.li,null,'extern "C" をまとめて取り除く'),"\n",a.createElement(n.li,null,"typedef struct tag を取り除く"),"\n"),"\n",a.createElement(n.p,null,"ここまでやると、自由に ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">c++</code>'}})," のコードを混ぜることができる。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::string</code>'}}),"、",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::vector</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::shared_ptr</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::function</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::string_view</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">template</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">class</code>'}}),", 前方宣言, ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">auto</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">inline</code>'}})," 等使い放題 👍"),"\n",a.createElement(n.p,null,"特に ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::string_view</code>'}})," の使い勝手を試したい。\n所有しない文字列はすべて、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::string_view</code>'}})," でいけると思うのだが。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">split</code>'}})," の ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::string_view</code>'}})," 版は具合がよかった。"),"\n",a.createElement(n.h2,null,'c++ 化 (extern "C")'),"\n",a.createElement(n.p,null,"手法としては、各ソースの拡張子を ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">.c</code>'}})," から ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">.cpp</code>'}})," に変更する。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">CMakeLists.txt</code>'}})," を修正。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">#include</code>'}})," を ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">extern "C"</code>'}})," で囲む、で ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">c++</code>'}})," 化することができる。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">extern &quot;C&quot; {\n#include &quot;xxx.h&quot;\n}</code></pre></div>'}}),"\n",a.createElement(n.p,null,"ただ、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">cpp</code>'}})," で定義する関数の宣言が ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">extern "C"</code>'}})," の中に入らないとリンクエラーになるので、\nそうなるようにソースごとにヘッダを分配してやる。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">w3m</code>'}})," は関数宣言が少数のファイル ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">proto.h</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">fm.h</code>'}})," とかに集中しているのだが、いっぱいあるので雑にやる。\nコンパイルが通ればよい。"),"\n",a.createElement(n.p,null,"分配するときに未定義の型を前方宣言ですませたいのだけど、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">c</code>'}})," の ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">struct</code>'}})," 定義が、",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">struct tag</code>'}})," と ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">typedef</code>'}})," に分かれているのがやっかいだった。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token comment">// C</span>\n<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">hogeTag</span>\n<span class="token punctuation">{</span>\n\n<span class="token punctuation">}</span> Hoge<span class="token punctuation">;</span></code></pre></div>'}}),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">DoHoge</span><span class="token punctuation">(</span>Hoge <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// に対する前方宣言は、</span>\n\n<span class="token keyword">struct</span> <span class="token class-name">hogeTag</span><span class="token punctuation">;</span>\n<span class="token keyword">typedef</span> hogeTag Hoge<span class="token punctuation">;</span></code></pre></div>'}}),"\n",a.createElement(n.p,null,a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">C</code>'}})," の状態で、前方宣言を導入できずヘッダの分割が難航。\n型ごとに別のヘッダに分割することは断念して、\nほとんど全部の ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">struct</code>'}})," 定義の入ったヘッダを ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">fm.h</code>'}})," から分離して作るのに留めた。"),"\n",a.createElement(n.h2,null,"DEFUN"),"\n",a.createElement(n.p,null,a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">w3m</code>'}})," は ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">DEFUN</code>'}})," でキーアサインできる関数を定義している。"),"\n",a.createElement(n.p,null,a.createElement(n.a,{href:"/w3m/doc-jp/readme.func/"},"readme.func")),"\n",a.createElement(n.p,null,"以下のように、キーボードなどのイベントをトリガーにアクションを実行するというイメージ。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Key\n    KeyMap\n        DEFUN\n    Menu\n        DEFUN\nMouseAction\n    ActionMap\n        DEFUN\n    Menu\n        DEFUN\nAlarm\n    DEFUN</code></pre></div>'}}),"\n",a.createElement(n.p,null,"ソースは、",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">main.c</code>'}})," と ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">menu.c</code>'}})," に ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">DEFUN</code>'}})," とそれの使う補助関数がまとめて定義されていて、\nヘッダは ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">proto.h</code>'}})," に全部入れとなっている。"),"\n",a.createElement(n.p,null,"c++ で下記のようなディスパッチャを作った。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">typedef void (*Command)();\nstd::unordered_map&lt;std::string, Command&gt; g_commandMap;</code></pre></div>'}}),"\n",a.createElement(n.p,null,"使い捨ての python で関数に登録するコードを生成した。"),"\n",a.createElement(n.h1,null,"第２段階"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"PODじゃない型が動くようにする","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"constructor/destructor"),"\n"),"\n"),"\n",a.createElement(n.li,null,"脱GC","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"コレクションをSTLに置き換える"),"\n",a.createElement(n.li,null,"std::string"),"\n",a.createElement(n.li,null,"std::shared_ptr"),"\n"),"\n"),"\n",a.createElement(n.li,null,"機能ごとにモジュール化"),"\n",a.createElement(n.li,null,"再入可能"),"\n"),"\n",a.createElement(n.h2,null,"GC_MALLOC から gc_cleanup 継承へ"),"\n",a.createElement(n.p,null,"boehm-GC を ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">c++</code>'}})," のクラスで使う方法を調べた。"),"\n",a.createElement(n.p,null,"http://www.namikilab.tuat.ac.jp/~sasada/prog/boehmgc.html#i-0-5"),"\n",a.createElement(n.p,null,a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">w3m</code>'}})," では、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">GC</code>'}})," を多用している。"),"\n",a.createElement(n.p,null,"おもに、"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"struct Str"),"\n",a.createElement(n.li,null,"コレクション"),"\n",a.createElement(n.li,null,"struct の field"),"\n"),"\n",a.createElement(n.p,null,"という感じに。\nこのうち、 struct の field で使われるタイプの単発の ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">GC_MALLOC</code>'}})," している型を ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gc_cleanup</code>'}})," 継承にして、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">new</code>'}})," で初期化するようにする。"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"bzero, bcopy, memcpy, sizeof"),"\n"),"\n",a.createElement(n.p,null,"等でメモリクリアしているところに注意する。\nこれで、その型は ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">constructor/destructor</code>'}})," が動くようになり、\nメンバーに ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::string</code>'}})," 等を配置できるようになる。\nあとで、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gc_cleanup</code>'}})," から ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::shared_ptr</code>'}})," に変更することも視野に入れている。"),"\n",a.createElement(n.h2,null,"GC文字列 Str"),"\n",a.createElement(n.p,null,"アプリ全体で使われていて一挙になくすことはできないのだけど、構造体の末端のメンバーから ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::string</code>'}})," に変える。\nあと、がんばって ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const char *</code>'}})," の範囲を増やす。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">libwc</code>'}})," から ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Str</code>'}})," を剥そうと思っていたのだが、逆に ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">libwc</code>'}})," に ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Str</code>'}})," を封じ込める方向に軌道修正。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">indep.c</code>'}})," の便利文字列関数も少しずつ変えてく。"),"\n",a.createElement(n.h2,null,"グローバル変数を減らす"),"\n",a.createElement(n.p,null,"関数の中でグローバル変数にアクセスしている場合(CurrentBufferなど)、これを関数の引数経由とか、クラスのメンバー経由でもらう。面倒でも Getter と Setter を区別して、どこで変更されうるかわかりやすくする。\nクラスのメンバーは、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">private</code>'}})," 化を試みる。"),"\n",a.createElement(n.h2,null,"Stream処理"),"\n",a.createElement(n.p,null,"多分、最難関の ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">loadGeneralFile</code>'}})," 関数。700行くらいだったか。\ngoto とか longjmp があってよくわからなかったのだが、慣れてきた。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">http</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">https</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">NNTP ?</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gopher</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ftp</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">pipe</code>'}})," 等、",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">http</code>'}})," のプロキシーやリダイレクト、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">www-auth</code>'}})," などを一手に処理していて容易に手を付けられない。\n何度か整理しようとして悉く撃退されたので、雑にやることにした。\n機能を ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">http(https)</code>'}})," に絞ってそれ以外をコメントアウトしてとにかく量を減らす。\nプロキシーとか、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">dump</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">halfload</code>'}})," などのよく知らない機能もどんどん削る。\nとしてなんとか改造できるようになってきた。"),"\n",a.createElement(n.p,null,"ここを ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">HttpClient</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">LocalFile</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">PipeReader</code>'}})," あたりに整理したい。"),"\n",a.createElement(n.h1,null,"第３段階"),"\n",a.createElement(n.p,null,"Tab, Buffer, Line のリンクリストを STL のコレクションに置き換えた。"),"\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c++"><pre class="language-c++"><code class="language-c++">auto buf = load(url);\ntab-&gt;push(buf);</code></pre></div>'}}),"\n",a.createElement(n.p,null,"という形を目指す。"),"\n",a.createElement(n.p,null,a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">loadGeneralFile</code>'}})," を解きほぐして、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">HTTP</code>'}})," 機能を抽出、リダイレクトまで動くようにできた。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">loadGeneralFile</code>'}})," は、"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"OpenStream/Send HTTP Request"),"\n",a.createElement(n.li,null,"HTTP Response","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"3xx => Redirect"),"\n"),"\n"),"\n",a.createElement(n.li,null,"content-type で分岐","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"BufferLoader => Buffer"),"\n"),"\n"),"\n"),"\n",a.createElement(n.p,null,"という感じに整理できそう。\nHttpとBufferローダーを副作用の無い関数に整理できれば再入可能が見えてくる。\n早めに分岐させて、分岐したら合流しない。同じ処理は関数で共有するという方向性で整理。"),"\n",a.createElement(n.p,null,"Buffer が多機能なので、Document, HttpResponse, FileInfo とかに分割したい。"),"\n",a.createElement(n.h1,null,"第４段階"),"\n",a.createElement(n.p,null,"mainloop の再実装。libuv, libevent 等を検討していたのだけど、 c++ との親和性の高い asio を使うことにした。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">tty read (keyboard input)</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">signal callback (sigint, winresize)</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">alarm</code>'}})," の割り込みを asio 経由にする。\nアプリの終了をloop の終了にして、自然に destructor がコールされるようになる。"),"\n",a.createElement(n.h1,null,"第５段階"),"\n",a.createElement(n.p,null,"html parse から term へのレンダリング部分の分解。\nやっと解読できて１パス目"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"内部文字コード(wtf-8)に変換"),"\n",a.createElement(n.li,null,"tokenize"),"\n",a.createElement(n.li,null,"tag をパースして属性取得 => パースに成功したら行バッファに書き戻す。フォームの情報を蓄積する。テーブルのレイアウト"),"\n"),"\n",a.createElement(n.p,null,"結果として、行のリストと、フォーム情報を得る。"),"\n",a.createElement(n.p,null,"２パス目"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"行のリストを再度パース"),"\n",a.createElement(n.li,null,"非タグ部分をBufferに出力"),"\n",a.createElement(n.li,null,"Aタグやフォームを Anchor などに出力"),"\n"),"\n",a.createElement(n.p,null,"という感じだった。\n１パス目で html 化するときに知らない属性を捨てたり、内部属性を追加したりしている様子。\nこの、内部属性がよくわからなくて難しい。"),"\n",a.createElement(n.h1,null,"文字コード"),"\n",a.createElement(n.p,null,a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">content-charset</code>'}})," => ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">wtf</code>'}})," => ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">DisplayCharset</code>'}})," と文字コードを変換して動作していることがわかった。\n試しに、",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">utf-8</code>'}})," であることが分かっている ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">html</code>'}})," で ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">wtf</code>'}})," 変換を飛ばしてみたところ表示が壊れた。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">wtf</code>'}})," は ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">utf-8</code>'}})," と互換性がないらしい。\nhttp://simonsapin.github.io/wtf-8/\nなのかと思ったのだが、違う独自形式かもしれない。"),"\n",a.createElement(n.p,null,"w3m は、この ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">wtf</code>'}})," エンコーディングで、html タグのパース、文字のバイト幅の判定、文字のカラム幅の判定をしているのだが、\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">utf-8</code>'}})," では、文字のバイト幅、カラム幅の判定が狂う。\nということで、 ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">utf-8</code>'}})," でのバイト幅判定を自作して ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">wcwidth</code>'}})," を組み合わせてみた。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">*#12345;</code>'}})," 形式の ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">unicode</code>'}})," 埋め込みに対応するために、追加で ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">unicode</code>'}})," => ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">utf-8</code>'}})," 変換も作った。\n正しく表示することができた。"),"\n",a.createElement(n.p,null,"ということで、",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">euc-jp</code>'}})," と ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">shift-jis</code>'}})," と ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">iso-2022-jp</code>'}})," から ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">utf-8</code>'}})," への変換を作れば日本語は対応できそう。\n",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">std::string_view</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">char32_t</code>'}}),", ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">char8_t</code>'}})," あたりの新しい型を使った ",a.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">\\0</code>'}})," 終端に頼らないライブラリを作ってみる。"),"\n",a.createElement(n.h1,null,"メモ"),"\n",a.createElement(n.h2,null,"モジュールに分割"),"\n",a.createElement(n.p,null,"機能ごとにモジュールに分割する。"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"UI(frontend)"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Term","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"低レベル描画","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"termcap の関数を直接呼ぶ。curses の自前実装的な"),"\n",a.createElement(n.li,null,"マルチバイト、マルチカラムの文字列と密接に関連していて libwc と不可分"),"\n"),"\n"),"\n",a.createElement(n.li,null,"キーボード入力"),"\n",a.createElement(n.li,null,"マウス入力"),"\n",a.createElement(n.li,null,"リサイズイベント"),"\n",a.createElement(n.li,null,"SIGNALハンドリング","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"SIGINT => longjmp でキャンセル処理を実現している。c++ のデストラクタとかまずそう"),"\n"),"\n"),"\n"),"\n"),"\n",a.createElement(n.li,null,"高レベル描画","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Lineの構築(byte ごとに char と Lineprop がペアになる)"),"\n"),"\n"),"\n",a.createElement(n.li,null,"Tab"),"\n",a.createElement(n.li,null,"Buffer"),"\n",a.createElement(n.li,null,"Message"),"\n",a.createElement(n.li,null,"Menu"),"\n",a.createElement(n.li,null,"Keymap"),"\n",a.createElement(n.li,null,"LineInput","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"SearchKey"),"\n",a.createElement(n.li,null,"History"),"\n"),"\n"),"\n"),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"IO(transport)"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"IStream","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"union => class polymorphism化"),"\n",a.createElement(n.li,null,"file descriptor"),"\n",a.createElement(n.li,null,"FILE*"),"\n",a.createElement(n.li,null,"ssl"),"\n",a.createElement(n.li,null,"memory"),"\n",a.createElement(n.li,null,"Compression"),"\n"),"\n"),"\n",a.createElement(n.li,null,"LocalCGI"),"\n"),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"http"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"HttpSession","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"HttpRequest"),"\n",a.createElement(n.li,null,"HttpResponse"),"\n"),"\n"),"\n",a.createElement(n.li,null,"cookie"),"\n",a.createElement(n.li,null,"redirect"),"\n",a.createElement(n.li,null,"referer"),"\n",a.createElement(n.li,null,"https"),"\n",a.createElement(n.li,null,"ftp"),"\n",a.createElement(n.li,null,"URL"),"\n"),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"HTML"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"HTMLtagproc1"),"\n",a.createElement(n.li,null,"HTMLlineproc2body","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"process_form"),"\n",a.createElement(n.li,null,"process_form_int"),"\n"),"\n"),"\n",a.createElement(n.li,null,"form"),"\n",a.createElement(n.li,null,"table"),"\n",a.createElement(n.li,null,"frame"),"\n",a.createElement(n.li,null,"term rendering"),"\n"),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"String"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"文字コード"),"\n",a.createElement(n.li,null,"quote"),"\n",a.createElement(n.li,null,"url escape"),"\n",a.createElement(n.li,null,"html escape"),"\n",a.createElement(n.li,null,"html entity"),"\n",a.createElement(n.li,null,"char_util","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"myctype"),"\n"),"\n"),"\n",a.createElement(n.li,null,"string_view_util","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"strip"),"\n"),"\n"),"\n",a.createElement(n.li,null,"string_util","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"malloc"),"\n"),"\n"),"\n"),"\n"),"\n"),"\n",a.createElement(n.h2,null,"リンクをたどる(followLink)"),"\n",a.createElement(n.p,null,"followA();\nloadLink();\nloadGeneralFile();"),"\n",a.createElement(n.p,null,"cmd_loadURL();\nloadGeneralFile();"),"\n",a.createElement(n.p,null,"cmd_loadURL();\nloadGeneralFile();"),"\n",a.createElement(n.h2,null,"描画する"),"\n",a.createElement(n.p,null,"displayBuffer\nredrawBuffer\nredrawNLine"),"\n",a.createElement(n.h2,null,"key入力"))}var s=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?a.createElement(n,e,a.createElement(c,e)):c(e)},r=(t(8678),t(8838));const u={code:e=>{let{children:n,className:t}=e;return t?a.createElement(r.Z,{className:t},n):a.createElement("code",null,n)}};function o(e){let{data:n,children:t}=e;return a.createElement(a.Fragment,null,a.createElement("h1",null,n.mdx.frontmatter.title),a.createElement(l.Zo,{components:u},t))}function m(e){return a.createElement(o,e,a.createElement(s,e))}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2020-w-3-m-mod-md-3fa3baf0e6fdd2c382f6.js.map