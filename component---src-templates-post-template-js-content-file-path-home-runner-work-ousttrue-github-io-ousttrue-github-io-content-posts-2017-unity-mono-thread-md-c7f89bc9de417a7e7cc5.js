"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4368],{2345:function(n,e,t){t.r(e),t.d(e,{default:function(){return l}});var r=t(1151),o=t(7294);function a(n){const e=Object.assign({pre:"pre",code:"code",p:"p"},(0,r.ah)(),n.components);return o.createElement(o.Fragment,null,o.createElement(e.pre,null,o.createElement(e.code,null,'タイトルが長いが、RenderingスレッドでC#関数を呼び出すと次回play時に固まるの続きです。\n\n前回の記事についてメールで指摘をいただきました。\n意訳\n\nmono_thread_detachすればいいよ\n\nなるほど、やってみよう。\nmono_thread_detachとは\n\nhttp://docs.go-mono.com/index.aspx?link=xhtml%3Adeploy%2Fmono-api-threads.html\n\nそいう関数があることはわかった。名前しか分からん。\n\nhttp://www.mono-project.com/docs/advanced/embedding/\nhttps://github.com/mono/mono/blob/master/docs/threading\n\nMonoをスクリプトエンジンとしてホスティングする場合に使うAPIらしい。\nMonoエンジンでC#のコードを実行する場合実行スレッドでは事前にスレッドの初期化をする必要があり、他所で作られた既存のスレッドを初期化するのがmono_thread_attachらしい。 mono_thread_attachされたスレッドはMonoの終了時に回収対象として登録されるが、これを解除するのがmono_thread_detachのようだ。\nやってみる\ndocumentが見つからなかったので、使われているコードを参考にしてみる。\n\nhttps://github.com/jart/freeswitch/blob/master/src/mod/languages/mod_managed/mod_managed.cpp\n\nusing System;\nusing System.Runtime.InteropServices;\nusing UnityEngine;\n\n\npublic class CallbackOnRenderThread : MonoBehaviour\n{\n    [DllImport("mono")]\n    static extern IntPtr mono_thread_current();\n\n    [DllImport("mono")]\n    static extern IntPtr mono_thread_detach(IntPtr p);\n\n    public int m_count;\n    public IntPtr m_renderThread;\n\n    void OnRender(int eventID)\n    {\n        m_count++;\n        m_renderThread = mono_thread_current();\n    }\n\n    private void OnApplicationQuit()\n    {\n        Debug.Log(m_count);\n\n        if (m_renderThread != IntPtr.Zero)\n        {\n            Debug.LogFormat("detach thread: {0}", m_renderThread);\n            mono_thread_detach(m_renderThread);\n            m_renderThread = IntPtr.Zero;\n        }\n    }\n\n    delegate void OnRenderFunc(int eventID);\n    OnRenderFunc m_callback;\n\n    void Update()\n    {\n        m_callback = new OnRenderFunc(OnRender);\n        var p = Marshal.GetFunctionPointerForDelegate(m_callback);\n        GL.IssuePluginEvent(p, 0);\n    }\n}\n\nCollecting from unknown threadと怒られる・・・\nならば、\npublic class CallbackOnRenderThread : MonoBehaviour\n{\n    [DllImport("mono")]\n    static extern IntPtr mono_thread_current();\n\n    [DllImport("mono")]\n    static extern IntPtr mono_thread_detach(IntPtr p);\n\n    public int m_count;\n    //public IntPtr m_renderThread;\n\n    void OnRender(int eventID)\n    {\n        try\n        {\n            m_count++;\n        }\n        finally\n        {\n            mono_thread_detach(mono_thread_current());\n        }\n    }\n\n    delegate void OnRenderFunc(int eventID);\n    OnRenderFunc m_callback;\n\n    void Update()\n    {\n        m_callback = new OnRenderFunc(OnRender);\n        var p = Marshal.GetFunctionPointerForDelegate(m_callback);\n        GL.IssuePluginEvent(p, 0);\n    }\n}\n')),"\n",o.createElement(e.p,null,"できちゃった。\nやったぜ。"))}var c=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?o.createElement(e,n,o.createElement(a,n)):a(n)};t(8678);function d(n){let{data:e,children:t}=n;return o.createElement(o.Fragment,null,o.createElement("h1",null,e.mdx.frontmatter.title),o.createElement(r.Zo,null,t))}function l(n){return o.createElement(d,n,o.createElement(c,n))}},8678:function(n,e,t){t(7294)},1151:function(n,e,t){t.d(e,{Zo:function(){return d},ah:function(){return a}});var r=t(7294);const o=r.createContext({});function a(n){const e=r.useContext(o);return r.useMemo((()=>"function"==typeof n?n(e):{...e,...n}),[e,n])}const c={};function d({components:n,children:e,disableParentContext:t}){let d;return d=t?"function"==typeof n?n({}):n||c:a(n),r.createElement(o.Provider,{value:d},e)}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2017-unity-mono-thread-md-c7f89bc9de417a7e7cc5.js.map