<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>三次元日誌 (unityについての記事)</title><link>https://ousttrue.github.io/</link><description></description><atom:link href="https://ousttrue.github.io/categories/unity.xml" rel="self" type="application/rss+xml"></atom:link><language>ja</language><copyright>Contents © 2022 &lt;a href="mailto:ousttrue@gmail.com"&gt;ousttrue&lt;/a&gt; </copyright><lastBuildDate>Sun, 18 Sep 2022 09:57:34 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>vscode で unity の breakpoint が動かない</title><link>https://ousttrue.github.io/qiita/vscode-de-unity-no-breakpoint-gadong-kanai/</link><dc:creator>ousttrue</dc:creator><description>&lt;p&gt;&lt;a href="https://qiita.com/ousttrue/items/3aad6a43767dffa7a98a"&gt;https://qiita.com/ousttrue/items/3aad6a43767dffa7a98a&lt;/a&gt;&lt;/p&gt;</description><category>qiita</category><category>unity</category><category>vscode</category><guid>https://ousttrue.github.io/qiita/vscode-de-unity-no-breakpoint-gadong-kanai/</guid><pubDate>Mon, 16 Nov 2020 08:05:08 GMT</pubDate></item><item><title>Unity2018.2のIAnimationJob</title><link>https://ousttrue.github.io/qiita/unity20182noianimationjob/</link><dc:creator>ousttrue</dc:creator><description>&lt;p&gt;&lt;a href="https://qiita.com/ousttrue/items/5a7be2af9c0576a93358"&gt;https://qiita.com/ousttrue/items/5a7be2af9c0576a93358&lt;/a&gt;&lt;/p&gt;</description><category>qiita</category><category>unity</category><guid>https://ousttrue.github.io/qiita/unity20182noianimationjob/</guid><pubDate>Sun, 20 May 2018 11:40:44 GMT</pubDate></item><item><title>UnityのTimelineTrackを実装する</title><link>https://ousttrue.github.io/qiita/unitynotimelinetrackwoshi-zhuang-suru/</link><dc:creator>ousttrue</dc:creator><description>&lt;p&gt;&lt;a href="https://qiita.com/ousttrue/items/ac2f0b3847e76a36b1f0"&gt;https://qiita.com/ousttrue/items/ac2f0b3847e76a36b1f0&lt;/a&gt;&lt;/p&gt;</description><category>qiita</category><category>unity</category><guid>https://ousttrue.github.io/qiita/unitynotimelinetrackwoshi-zhuang-suru/</guid><pubDate>Sun, 24 Dec 2017 05:45:31 GMT</pubDate></item><item><title>Unityちゃんの-Candy Rock Star-を研究する</title><link>https://ousttrue.github.io/posts/2017/unitychan_crs/</link><dc:creator>ousttrue</dc:creator><description>&lt;p&gt;わしもギャルが歌って踊るようなシーンを作ってみたいので
いまさらながらUnityChan CRSを調べてみることにした。&lt;/p&gt;
&lt;p&gt;http://unity-chan.com/
https://github.com/unity3d-jp/unitychan-crs&lt;/p&gt;
&lt;p&gt;をクローン。&lt;/p&gt;
&lt;p&gt;https://github.com/ousttrue/unitychan-crs&lt;/p&gt;
&lt;p&gt;今回はなんとなく&lt;/p&gt;
&lt;p&gt;https://github.com/ousttrue/unitychan-crs/blob/master/Memo/&lt;/p&gt;
&lt;p&gt;に記事を書いてます。&lt;/p&gt;</description><category>unity</category><guid>https://ousttrue.github.io/posts/2017/unitychan_crs/</guid><pubDate>Thu, 14 Dec 2017 15:00:00 GMT</pubDate></item><item><title>UnityEditorでnativeスレッドからC# delegateを呼ぶと後でフリーズする件</title><link>https://ousttrue.github.io/posts/2017/unity_mono_thread/</link><dc:creator>ousttrue</dc:creator><description>&lt;p&gt;タイトルが長いが、RenderingスレッドでC#関数を呼び出すと次回play時に固まるの続きです。&lt;/p&gt;
&lt;p&gt;前回の記事についてメールで指摘をいただきました。
意訳&lt;/p&gt;
&lt;p&gt;mono_thread_detachすればいいよ&lt;/p&gt;
&lt;p&gt;なるほど、やってみよう。
mono_thread_detachとは&lt;/p&gt;
&lt;p&gt;http://docs.go-mono.com/index.aspx?link=xhtml%3Adeploy%2Fmono-api-threads.html&lt;/p&gt;
&lt;p&gt;そいう関数があることはわかった。名前しか分からん。&lt;/p&gt;
&lt;p&gt;http://www.mono-project.com/docs/advanced/embedding/
https://github.com/mono/mono/blob/master/docs/threading&lt;/p&gt;
&lt;p&gt;Monoをスクリプトエンジンとしてホスティングする場合に使うAPIらしい。
MonoエンジンでC#のコードを実行する場合実行スレッドでは事前にスレッドの初期化をする必要があり、他所で作られた既存のスレッドを初期化するのがmono_thread_attachらしい。 mono_thread_attachされたスレッドはMonoの終了時に回収対象として登録されるが、これを解除するのがmono_thread_detachのようだ。
やってみる
documentが見つからなかったので、使われているコードを参考にしてみる。&lt;/p&gt;
&lt;p&gt;https://github.com/jart/freeswitch/blob/master/src/mod/languages/mod_managed/mod_managed.cpp&lt;/p&gt;
&lt;p&gt;using System;
using System.Runtime.InteropServices;
using UnityEngine;&lt;/p&gt;
&lt;p&gt;public class CallbackOnRenderThread : MonoBehaviour
{
    [DllImport("mono")]
    static extern IntPtr mono_thread_current();&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;[DllImport("mono")]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;static extern IntPtr mono_thread_detach(IntPtr p);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="na"&gt;public int m_count;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;public IntPtr m_renderThread;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="na"&gt;void OnRender(int eventID)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;m_count++;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;m_renderThread&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;mono_thread_current();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="na"&gt;private void OnApplicationQuit()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;Debug.Log(m_count);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;if (m_renderThread !&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;IntPtr.Zero)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="na"&gt;Debug.LogFormat("detach thread: {0}", m_renderThread);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="na"&gt;mono_thread_detach(m_renderThread);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="na"&gt;m_renderThread&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;IntPtr.Zero;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="na"&gt;delegate void OnRenderFunc(int eventID);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;OnRenderFunc m_callback;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="na"&gt;void Update()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;m_callback&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;new OnRenderFunc(OnRender);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;var p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;Marshal.GetFunctionPointerForDelegate(m_callback);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;GL.IssuePluginEvent(p, 0);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;Collecting from unknown threadと怒られる・・・
ならば、
public class CallbackOnRenderThread : MonoBehaviour
{
    [DllImport("mono")]
    static extern IntPtr mono_thread_current();&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;[DllImport("mono")]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;static extern IntPtr mono_thread_detach(IntPtr p);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="na"&gt;public int m_count;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;//public IntPtr m_renderThread;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="na"&gt;void OnRender(int eventID)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;try&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="na"&gt;m_count++;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;finally&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="na"&gt;mono_thread_detach(mono_thread_current());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="na"&gt;delegate void OnRenderFunc(int eventID);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;OnRenderFunc m_callback;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="na"&gt;void Update()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;m_callback&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;new OnRenderFunc(OnRender);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;var p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;Marshal.GetFunctionPointerForDelegate(m_callback);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;GL.IssuePluginEvent(p, 0);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;できちゃった。
やったぜ。&lt;/p&gt;</description><category>unity</category><guid>https://ousttrue.github.io/posts/2017/unity_mono_thread/</guid><pubDate>Sun, 29 Oct 2017 15:00:00 GMT</pubDate></item><item><title>Holotoolkit-unityでMSBuild-15.0(VS2017)を使う</title><link>https://ousttrue.github.io/posts/2017/04/holotoolkit_build_vs2017/</link><dc:creator>ousttrue</dc:creator><description>&lt;p&gt;VS2017からレジストリの構成が変わっている。&lt;/p&gt;
&lt;p&gt;http://stackoverflow.com/questions/328017/path-to-msbuild&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CalcMSBuildPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;msBuildVersion&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msBuildVersion&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"15.0"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;using&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Microsoft&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Win32&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Registry&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;LocalMachine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OpenSubKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="s"&gt;@"SOFTWARE\WOW6432Node\Microsoft\VisualStudio\SxS\VS7"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;folder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msBuildVersion&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;msBuildPath&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Combine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;folder&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"MSBuild&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;15.0&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;Bin&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;msbuild.exe"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;msBuildPath&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 既存のコード&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><category>unity</category><guid>https://ousttrue.github.io/posts/2017/04/holotoolkit_build_vs2017/</guid><pubDate>Sat, 15 Apr 2017 15:00:00 GMT</pubDate></item><item><title>RenderingスレッドでC#関数を呼び出すと次回play時に固まる</title><link>https://ousttrue.github.io/posts/2017/04/mono_domain_unload/</link><dc:creator>ousttrue</dc:creator><description>&lt;p&gt;何のことか分かりにくいが以下のコードで再現できる。
public int m_count;&lt;/p&gt;
&lt;p&gt;void OnRender(int eventID)
{
    m_count++;
}&lt;/p&gt;
&lt;p&gt;void Update()
{
    var p = Marshal.GetFunctionPointerForDelegate(OnRender);
    GL.IssuePluginEvent(p, 0);
}&lt;/p&gt;
&lt;p&gt;SharpDXをUnity上で使うべくGL.IssuePluginEventにC#のDelegateを渡す実験をしていた。これをやると、Editor終了時もしくは次回play時にUnityEditorがFreezeする(100%)。Unity5.5.3とUnity2017.1.0beta1で再現した。
調べてみたところ、&lt;/p&gt;
&lt;p&gt;https://forum.unity3d.com/threads/problem-with-callbacks.87513/&lt;/p&gt;
&lt;p&gt;が該当しそうかと思ったがちょっと違う。新しいスレッドを起こしている訳では無いので。 ただ、条件は下記の通り&lt;/p&gt;
&lt;p&gt;C#のdelegateを関数ポインタとしてCに渡す
その関数ポインタが異なるスレッドから呼び出される&lt;/p&gt;
&lt;p&gt;次に&lt;/p&gt;
&lt;p&gt;https://blog.tedd.no/2016/10/09/investigating-unity-hang-on-second-run-multi-threading/&lt;/p&gt;
&lt;p&gt;を当たった。ここで紹介しているvisualstudioのdebug - window - 並列スタックで状況を確認する手法を使ってみたところ以下のようになっていた。&lt;/p&gt;
&lt;p&gt;mono_domain_unloadが固まっているような気がするぞ。&lt;/p&gt;
&lt;p&gt;http://stackoverflow.com/questions/10138015/unloading-mono-domains-in-multithreaded-context&lt;/p&gt;
&lt;p&gt;monoがdelegateから関数ポインタを作るのに使っているらしいinvoke wrappersの周りの回収に失敗しているのではないかというような気がする。&lt;/p&gt;
&lt;p&gt;http://d.hatena.ne.jp/saiya_moebius/20090319/1237434037&lt;/p&gt;
&lt;p&gt;Unity上で打つ手は見つからなかった・・・&lt;/p&gt;</description><category>unity</category><guid>https://ousttrue.github.io/posts/2017/04/mono_domain_unload/</guid><pubDate>Fri, 14 Apr 2017 15:00:00 GMT</pubDate></item><item><title>Unity向けのJSON Parserを作成中</title><link>https://ousttrue.github.io/posts/2017/02/osaru/</link><dc:creator>ousttrue</dc:creator><description>&lt;p&gt;いつもJSONUtilやMiniJson+JsonNodeを使うのだけど数値周りのcastで苦しんだので自前でつくることにした。&lt;/p&gt;
&lt;p&gt;https://github.com/ousttrue/JsonSan~
https://github.com/ousttrue/Osaru&lt;/p&gt;
&lt;p&gt;UnityのJSON
UnityのJsonUtilityみたいなシリアライザ・デシリアライザと不可分のものは使いづらい。例えば、以下のようなjsonでpositionだけをデシリアライズしたい場合。
{
    "action": "hoge",
    "params": {
        "power": 9.8,
        "position": [0, 1, 2]
    }
}&lt;/p&gt;
&lt;p&gt;下記のように使いたい。
string json;&lt;/p&gt;
&lt;p&gt;var parsed=Json.Parse(json);
var x=(float)parsed["params"]["position"][0];&lt;/p&gt;
&lt;p&gt;MiniJson&lt;/p&gt;
&lt;p&gt;MiniJson
MiniJsonをちょっと楽にするスクリプト&lt;/p&gt;
&lt;p&gt;MiniJsonはパースした時にObjectの入れ物としてDictionary[string, object]、Arrayの入れ物としてList[object]を使っている。ここから値を取り出すにはキャストを使うのだがこれがわりとはまる。
int64 n=1234;
var no=(object)n;
var i=(int)no; // boxingされたint64型の値はobjectから直接intにキャストできない&lt;/p&gt;
&lt;p&gt;上記のような、ある数をobject型に代入してそれを違う型として取りだすようなときに面倒すぎだった。
// こうすればできる
var i=(int)(int64)no;&lt;/p&gt;
&lt;p&gt;ということで自作してみた。
JsonSan Osaru
JSON, Util, Parse, Reader, Deserializer|Serializerあたりの組み合わせが使い尽くされていたのでリポジトリ名がすごい適当になった。JSONさん。さらにMessagePackと統合してObjectStructure改めOsaruにした&lt;/p&gt;
&lt;p&gt;https://github.com/ousttrue/Osaru&lt;/p&gt;
&lt;p&gt;JSONの仕様を見ながらごりごりテストドリブンで実装した。&lt;/p&gt;
&lt;p&gt;http://www.json.org/json-ja.html&lt;/p&gt;
&lt;p&gt;JSONは、ObjectのキーがString限定なのに初めて気づいたり。Stackoverflowで「JavascriptのObjectリテラルとJSONは違うのだよ」というのを見たが、まぁそうですね。コメントとかキーのクォート省略とか。
実装
JSON文字列をパーサーに入力したらパース済みのノードとして結果を得る。
var json="[ \"json\" ]";
var node=Node.Parse(json);&lt;/p&gt;
&lt;p&gt;ノードはJSONの定義に沿った型をenumで知っていて、GetNumber(), GetString(), GetBoolean()等が実装してあるので適当に値を取り出せる。MiniJsonでのはまりを反省してNumber型はdouble決め打ちにした。
public enum ValueType
{
    Unknown,&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;String,
Number,
Object,
Array,
Boolean,
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;Debug.Log(node.ValueType); // ValueType.String
node.GetString();&lt;/p&gt;
&lt;p&gt;nodeがObjectかArrayの場合がミソでパースした時点では”{“または”[“までしか読まないことにした。IEnumerable[Node]の発動で子要素への要求が来て中に読み進む。使い方によっては軽量。Count()を使ったりすると遅くなるであろう。
foreach(var child in node)
{
    Debug.Log(child.GetString());
}&lt;/p&gt;</description><category>unity</category><guid>https://ousttrue.github.io/posts/2017/02/osaru/</guid><pubDate>Sun, 26 Feb 2017 15:00:00 GMT</pubDate></item><item><title>HoloToolkitのInputManager</title><link>https://ousttrue.github.io/posts/2017/02/hololens_input/</link><dc:creator>ousttrue</dc:creator><description>&lt;p&gt;HololensのInputManagerの動きを読んでみた&lt;/p&gt;
&lt;p&gt;HoloToolkit.Unity.InputModule.InputManager
Assets/HoloToolkit/Input/Prefabs/InputManagerプレハブから見る。
InputManager
  + (GazeManager)
  + (GazeStablilizer)
  + (InputManager)
  + (StabilizationPlaneModifier)&lt;/p&gt;
&lt;p&gt;GesturesInput# BaseInputSource(UnityEngine.VR.WSA.Input.GestureRecognizerを通じてジェスチャーを取得する)
  RawInteractionSourcesInput# BaseInputSource(UnityEngine.VR.WSA.Input.InteractionSourceを通じて手の検出・位置・ロストなどのイベントを検知する)
  EditorHandsInput# BaseInputSource(Editor向けに手イベントを偽装する)&lt;/p&gt;
&lt;p&gt;こんな感じに親子関係があって結構たくさんスクリプトがアタッチされている。
主要な部分だけに減らすと以下の3つのスクリプトになる。
InputManager
  + (GazeManager)
  + (InputManager)
  GesturesInput# BaseInputSource(UnityEngine.VR.WSA.Input.GestureRecognizerを通じてジェスチャーを取得する)&lt;/p&gt;
&lt;p&gt;この３つのスクリプトは下記のように連携する。
GazeManager -&amp;gt; raycast -&amp;gt; hitObject
                                  |
                                  v
GesturesInput -&amp;gt; event -&amp;gt; InputManager -&amp;gt; hitObjectのeventハンドラを実行する&lt;/p&gt;
&lt;p&gt;UnityのEventSystemとの連携
通常のUnityのEventは、EventSystemがアタッチされたInputModule(StandardInputModule)のProcess関数をコールすることで始まる。
HoloToolkitのInputManagerは、GestureRecognizer等からのイベントを即座にUnityのEventに変換して発行していた。
ShouldSendUnityUiEventsでInputManager.csを検索すると以下がヒットする。
HoloToolkit-Unity\Assets\HoloToolkit\Input\Scripts\InputManager.cs(308)
HoloToolkit-Unity\Assets\HoloToolkit\Input\Scripts\InputManager.cs(317)
HoloToolkit-Unity\Assets\HoloToolkit\Input\Scripts\InputManager.cs(340)
HoloToolkit-Unity\Assets\HoloToolkit\Input\Scripts\InputManager.cs(363)
HoloToolkit-Unity\Assets\HoloToolkit\Input\Scripts\InputManager.cs(386)&lt;/p&gt;
&lt;p&gt;コードを見てみると
// hololensのevent
ExecuteEvents.ExecuteHierarchy(newObject, null, OnFocusEnterEventHandler);
if (ShouldSendUnityUiEvents)
{
    // unity仕様に変換して実行
    ExecuteEvents.ExecuteHierarchy(newObject
        , GazeManager.Instance.UnityUIPointerEvent, ExecuteEvents.pointerEnterHandler);
}&lt;/p&gt;
&lt;p&gt;という風になっていて、以下の5種類のイベント転送を実装していた。&lt;/p&gt;
&lt;p&gt;IPointerClickHandler
IPointerDownHandler
IPointerEnterHandler
IPointerExitHandler
IPointerUpHandler&lt;/p&gt;
&lt;p&gt;これだとButton等のクリックイベントを処理するタイプのものは動く。
DragとかScrollイベントは別途イベント転送してやる必要がありそう。
なるほど。&lt;/p&gt;</description><category>hololens</category><category>unity</category><guid>https://ousttrue.github.io/posts/2017/02/hololens_input/</guid><pubDate>Fri, 17 Feb 2017 15:00:00 GMT</pubDate></item><item><title>UnityのhumanoidからBlenderのArmatureを作る</title><link>https://ousttrue.github.io/qiita/unitynohumanoidkarablendernoarmaturewozuo-ru/</link><dc:creator>ousttrue</dc:creator><description>&lt;p&gt;&lt;a href="https://qiita.com/ousttrue/items/be95a8a0286eed6ebd2a"&gt;https://qiita.com/ousttrue/items/be95a8a0286eed6ebd2a&lt;/a&gt;&lt;/p&gt;</description><category>blender</category><category>qiita</category><category>unity</category><guid>https://ousttrue.github.io/qiita/unitynohumanoidkarablendernoarmaturewozuo-ru/</guid><pubDate>Sat, 16 Jul 2016 08:05:04 GMT</pubDate></item></channel></rss>