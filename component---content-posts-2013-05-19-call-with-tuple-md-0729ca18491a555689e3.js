"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3738],{3850:function(n,e,t){t.r(e);var a=t(1151),s=t(7294);function c(n){const e=Object.assign({p:"p",pre:"pre",code:"code"},(0,a.ah)(),n.components);return s.createElement(s.Fragment,null,s.createElement(e.p,null,"msgpack-rpc-asio の関数登録と実行\nmsgpack-rpc のリクエストは、によると"),"\n",s.createElement(e.pre,null,s.createElement(e.code,null,"[type, msgid, method, params]\n")),"\n",s.createElement(e.p,null,"という形式なので method 名を std::string として params を std::tuple として得られる。\nこれをサーバ側で如何に呼び出すかについて。\n単純な実装だと以下のようにメソッド名をキーにして分岐することになる。"),"\n",s.createElement(e.pre,null,s.createElement(e.code,{className:"language-c++"},"int and(int, int);\nclass dispatcher { void dispatch(int msgid, const std::string &method,\nconst msgpack::object &params) { if(method==“add”){ // 引数展開\nstd::tuple t; params.convert(&t);\n// 関数実行\nint result=add(std::get<0>(t), std::get<1>(t));\n\n// 結果のパッキング\n// response [type, msgid, error, result]\nmsgpack::sbuffer response;\nmsgpack::packer<msgpack::sbuffer> pk(&response);\npk.pack_array(4)\npk.pack(1);\npk.pack(msgid);\npk.pack_nil();\npk.pack(result);\n\n// responseを送り返す\n\n\n} else{ throw “unknown func”; }\n\n}\n")),"\n",s.createElement(e.p,null,"引数展開、関数呼び出し、結果のパッキングと一連の操作を定型処理として括りだすと下記のように書ける。"),"\n",s.createElement(e.pre,null,s.createElement(e.code,{className:"language-c++"},"// ２引数展開用 class dispatcher { // 実行 void dispatcher::dispatch(int\nmsgid, const std::string &method, const msgpack::object &params) {\nif(method==“add”){ msgpack::sbuffer response=unpack_exec_pack(msgid,\nadd, params);\n// responseを送り返す\n\n\n} else{ throw “unknown func”; }\n\n}\n// ヘルパー template msgpack::sbuffer unpack_exec_pack(int msgid,\nR(*f)(A1, A2), const msgpack::object &params) { // 引数展開 std::tuple\nt; params.convert(&t);\n// 関数実行\nR result=add(std::get<0>(t), std::get<1>(t));\n\n// 結果のパッキング\n// response [type, msgid, error, result]\nmsgpack::sbuffer response;\nmsgpack::packer<msgpack::sbuffer> pk(&response);\npk.pack_array(4)\npk.pack(1);\npk.pack(msgid);\npk.pack_nil();\npk.pack(result);\n\nreturn response;\n\n}\n")),"\n",s.createElement(e.p,null,"１引数関数から９引数くらいまでと返り値 void 版を作ってやればだいたいの関数を登録することができる。\nさらに 関数の登録と実行を分けるべく次のように拡張した。"),"\n",s.createElement(e.pre,null,s.createElement(e.code,{className:"language-c++"},"class\ndispatcher { std::map m_map;\n// 実行 void dispatch(int msgid, const std::string &method, const\nmsgpack::object &params) { std::function f=m_map.find(method);\nif(f!=m_map.end()){ // 関数実行 msgpack::sbuffer resonse=f(msgid,\nparams);\n// responseを送り返す\n\n\n} else{ throw “unknown func”; }\n\n}\n// 登録 template void add_handler(const std::string &method, R(*f)(A1,\nA2)) {\nm_map[method]=f->msgpack::sbuffer{\n// 引数展開\nstd::tuple<A1, A2> t;\nparams.convert(&t);\n\n// 実行\nR result=f(std::get<0>(t), std::get<1>(t));\n\n// 結果のパッキング\n// response [type, msgid, error, result]\nmsgpack::sbuffer response;\nmsgpack::packer<msgpack::sbuffer> pk(&response);\npk.pack_array(4)\npk.pack(1);\npk.pack(msgid);\npk.pack_nil();\npk.pack(result);\n\nreturn response;\n\n\n};\n\n}\n")),"\n",s.createElement(e.p,null,s.createElement(e.code,null,"msgpack->引数展開->c++関数呼び出し->msgpack")," への一連の操作を 同一のシグネチャの ",s.createElement(e.code,null,"std::function")," に封じ込めることができる。\n次にこれを関数ポインタ以外に関数オブジェクトを受け付けるように拡張したい。\nまず、std::function から実装。"),"\n",s.createElement(e.pre,null,s.createElement(e.code,null,"c++   // std::function用   template<typname R, typename A1, typename A2>   void add_handler(contt std::string &method, std::function<R(A1, A2)> f)   {     // 中身同じ   }\n")),"\n",s.createElement(e.p,null,"呼び出し時に std::function を経由するようにすればあらゆる関数呼び出しを登録できる。\n例えば、ラムダ関数も以下のように登録できる。"),"\n",s.createElement(e.pre,null,s.createElement(e.code,null,'c++ // ラムダ登録 dispatcher d; d.add_handler("add",      std::function<int(int, int)>(       [](int a, int b)->int{          return a+b;        }));\n')),"\n",s.createElement(e.p,null,"しかし、どうせなら"),"\n",s.createElement(e.pre,null,s.createElement(e.code,null,'c++ dispatcher d; d.add_handler("add",      [](int a, int b)->int{        return a+b;      });\n')),"\n",s.createElement(e.p,null,"と書きたい。\nとなると下記のような登録関数を書かねばならぬが関数のシグネチャがわからないので中身を記述することができない。"),"\n",s.createElement(e.pre,null,s.createElement(e.code,{className:"language-c++"},"// ラムダの登録\ntemplate<typname F>\nvoid add_handler(const std::string &method, F f)   {     // 型がわからぬ   }\n")),"\n",s.createElement(e.p,null,"ここで関数オブジェクトの operator()へのポインタを型推論することで F のシグネチャを得ることができる。"),"\n",s.createElement(e.pre,null,s.createElement(e.code,{className:"language-c++"},"template void add_handler(const std::string &method, F f,\nR(C::*)(A1, A2)const) { // 中身同じ }\n// ラムダの登録 // std::functionも受けられる // std::bindは無理だった //\n")),"\n",s.createElement(e.p,null,"operator()がひとつしかない関数オブジェクトを受け付けられる？"),"\n",s.createElement(e.pre,null,s.createElement(e.code,{className:"language-c++"},"template\nvoid add_handler(const std::string &method, F f) {\n// 上の関数で型推論させる\nadd_handler(method, f, &F::operator()); }\n")),"\n",s.createElement(e.p,null,"これでめでたくラムダも直接登録できるようになった。\nただし、operator()のオーバーロードが解決できないらしく std::bind が登録できない。\nstd::bind に関しては、ラムダで代用できるし std::function でラップできるのでおいておくことにした。"))}e.default=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,a.ah)(),n.components);return e?s.createElement(e,n,s.createElement(c,n)):c(n)}},1151:function(n,e,t){t.d(e,{ah:function(){return c}});var a=t(7294);const s=a.createContext({});function c(n){const e=a.useContext(s);return a.useMemo((()=>"function"==typeof n?n(e):{...e,...n}),[e,n])}}}]);
//# sourceMappingURL=component---content-posts-2013-05-19-call-with-tuple-md-0729ca18491a555689e3.js.map