"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2557],{4543:function(e,n,t){t.r(n),t.d(n,{default:function(){return u}});var a=t(1151),l=t(7294);function c(e){const n=Object.assign({p:"p",span:"span"},(0,a.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.p,null,"GStreamer をビルドする過程で ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">meson</code>'}})," を調べたら、存外に良かった。\npython なので、CMake と比べてデバッガをアタッチできるのが圧倒的に楽。\nCMake はステップ実行とかできないからね。"),"\n",l.createElement(n.p,null,"成り行きで GStreamer に続いて、 Gtk4, PyGObject とかをビルドしていたら、\nGtk4 もわりと面白そうなことがわかった。\n昔、Windows では扱いが面倒だった GLArea がさくっと動いた。\nさらに Gtk4 で新しくできた Gsk 層が 2D の SceneGraph ぽくて、\nPyOpenGL と連携して遊べるかもしれない。\nNodeEditor とか Timeline(KeyFrame) Editor 作れないかなぁ。\nPyGObject まわりは、gir(xml) から Python の型ヒント(pyi stub) を生成することで、\nLanguageServer のインテリセンスをそれなりに効かせることができた。\n最近の python では、 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Qt</code>'}})," とか ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">bpy</code>'}})," といった ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">native extension</code>'}})," の方が、\n素の python モジュールより型情報が無くなるという逆転現象が起きているのだが、\nPyGObject はほぼ gir(xml) そのままなので、わりといい感じになる。"),"\n",l.createElement(n.p,null,"Gtk のビルドが短時間でできることがわかったので、\nGUI 層は自前ビルドでいけそうな気がしてきた。\nつまり、Linux と Windows 両方を gtk4 でなるべく同じツールを使ってみる。\nGentoo をクリーンインストールして下の層だけ ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">emerge</code>'}})," で入れた。\nGentoo は USE フラグで ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">-gtk -glib -qt</code>'}})," などとすることで、依存が連鎖することを止めることができる。"),"\n",l.createElement(n.p,null,"ついでに ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">wayland</code>'}})," に手を出したところ、",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">wayland</code>'}})," 界隈もビルドツールに\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">meson</code>'}})," が導入されているのを発見。\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">download/clone</code>'}})," => ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">meson</code>'}})," を自動化する python スクリプトの作成に着手した。"),"\n",l.createElement(n.p,null,"https://github.com/ousttrue/toprefix"),"\n",l.createElement(n.p,null,"プロトタイプとしてはまぁまぁの使い勝手。\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gentoo</code>'}})," と ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Windows</code>'}})," 共用で ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gtk4</code>'}})," などをさくっと展開できるようになる。予定。"),"\n",l.createElement(n.p,null,"さらに ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">dotfiles</code>'}})," の管理でやっている ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">neovim</code>'}})," のビルドも合流。\ngo 系の ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ghq</code>'}}),", ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">fzf</code>'}})," などの展開や、\nrust 系の ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">wezterm</code>'}}),", ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">stylua</code>'}}),", ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ripgrep</code>'}})," の展開もこっちに移そうかなと。\nわりと処理のパターンは決まっていて次のうちのどれかになる事が多い。"),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">download => extract => build => install: tar ball\ndownload => extract          => install: ビルド済み tar ball\n              clone => build => install: repository</code></pre></div>'}}),"\n",l.createElement(n.p,null,"これにパッチ当てが追加になることがある。"),"\n",l.createElement(n.p,null,"ついでに、\n以前作った ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">blender</code>'}})," の ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">bpy</code>'}})," モジュール生成スクリプトなんかも合流することを画策。\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">svn</code>'}})," なしで ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">blender</code>'}})," ビルドできんかね。\nとなると ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">pixar usd</code>'}})," も ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">llvm</code>'}})," もビルドしたいわね。\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">pyxar usd</code>'}})," は ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">boost</code>'}})," の除去したいけどね。\nTUI と Desktop のツール系は自前ビルドで遊べるようにしていく。"))}var s=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?l.createElement(n,e,l.createElement(c,e)):c(e)},r=t(8678),o=t(8838);const d={code:e=>{let{children:n,className:t}=e;return t?l.createElement(o.Z,{className:t},n):l.createElement("code",null,n)}};function g(e){let{data:n,children:t}=e;return l.createElement(r.Z,null,l.createElement("h1",null,n.mdx.frontmatter.title),l.createElement(a.Zo,{components:d},t))}function u(e){return l.createElement(g,e,l.createElement(s,e))}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2022-1121-build-prefix-md-a2a2776d5cadc74ad9ae.js.map