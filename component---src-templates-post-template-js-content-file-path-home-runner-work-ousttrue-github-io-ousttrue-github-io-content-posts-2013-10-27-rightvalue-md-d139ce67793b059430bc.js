"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3667],{620:function(n,t,e){e.r(t),e.d(t,{default:function(){return i}});var r=e(1151),u=e(7294);function o(n){const t=Object.assign({p:"p",pre:"pre",code:"code"},(0,r.ah)(),n.components);return u.createElement(u.Fragment,null,u.createElement(t.p,null,"右辺値の理解\nそろそろ右辺値を抑えておきたい気がしたのでテストコードを書きながら実験してみた(VC2010\nExpress Edition)。\nhttp://msdn.microsoft.com/ja-jp/library/vstudio/dd293665.aspx\nを参考に右辺値実験クラス RightKun を書いた。\nコピーコンストラクタと同じくシグニチャは決まったものがあって\n右辺値代入演算のオーバーロードとペアになるらしい。\n各関数の呼び出しでメッセージを表示するように仕込んだ。\nhttps://gist.github.com/ousttrue/7178535"),"\n",u.createElement(t.pre,null,u.createElement(t.code,{className:"language-cpp"},'#include <memory>\n#include <iostream>\n\n\nclass RightKun\n{\npublic:\n    RightKun()\n    {\n        std::cout << this << ":default constructor" << std::endl;\n    };\n\n    ~RightKun()\n    {\n        std::cout << this << ":destructor" << std::endl;\n    }\n\n    // 左辺値によるコピーコンストラクタ\n    RightKun(const RightKun &src)\n    {\n        std::cout << this << ":copy constructor: ";\n        *this=src;\n    }\n\n    RightKun &operator=(const RightKun &src)\n    {\n        std::cout << "left value operator= " << &src << std::endl;\n        return *this;\n    }\n\n    // 右辺値によるムーブコンストラクタ\n    RightKun(RightKun &&src)\n    {\n        std::cout << this << ":move constructor: ";\n        *this=std::move(src);\n    }\n\n    RightKun &operator=(RightKun &&src)\n    {\n        std::cout << "right value operator= " << &src << std::endl;\n        return *this;\n    }\n};\n')),"\n",u.createElement(t.p,null,"とりあえず使ってみる"),"\n",u.createElement(t.pre,null,u.createElement(t.code,{className:"language-cpp"},"{\n    // default\n    RightKun r1;\n\n    // copy\n    RightKun r2=r1;\n}\n\n結果\n0025FE33:default constructor\n0025FE32:copy constructor: left value operator= 0025FE33\n0025FE32:destructor\n0025FE33:destructor\n\n問題ない。\n通常の値返しの呼び出し\nRightKun create()\n{\n    return RightKun();\n}\n\n使う\n{\n    RightKun r=create();\n}\n\n結果\n0025FE2E:default constructor\n0025FE2E:destructor\n\nおや、コピーコンストラクタが呼ばれない。\nRVO\n調べてみたらこれはコンパイラのRVO(Return Value Optimization)という機能で\n返り値が変数に代入されていない場合(いわゆる右辺値)に代入を無しにできるというものらしい。\nなるほど。\nよくある\nvec3 cross(const vec3 &lhs, const vec3 &rhs)\n{\n  // x, y, z...\n  return vec3(x, y, z);\n}\n\nvec3 out=cross(v1, v2);\n\n的なものを\nvoid cross(vec3 *out, const vec3 *lhs, const vec3 *rhs)\n{\n  // x, y, z...\n  out->x=x;\n  out->y=y;\n  out->z=z;\n}\n\nvec3 out;\ncross(&out, &v1, &v2);\n\nと書いても別にパフォーマンスが変わらんと言うことですな。\n最近のコンパイラなら大丈夫というのは、RVOがたぶん効くということか。\nむしろ適切なコンストラクタで初期化できるので前者の方がよろしいな。\n後者だとデフォルトコンストラクタが0で初期化しないようにしたくなるし、\nいろいろよろしくない。\nRVOできないようにする\n先ほどの関数をRVOが無効になるように改造してみる。\nRightKun createNoRVO()\n{\n    RightKun r;\n    return r;\n}\n\n使う\n{\n    RightKun r=createNoRVO();\n}\n\n結果\n0025FDFB:default constructor\n0025FE31:move constructor: right value operator= 0025FDFB\n0025FDFB:destructor\n0025FE31:destructor\n\n期せずしてムーブコンストラクタ呼び出しが発生した。\nどういう条件で切り替わるんだこれは。\n調べてみるとムーブコンストラクタはRVOが効かない時に使われる、という記述を見つけた。\nhttp://msdn.microsoft.com/ja-jp/library/vstudio/dd293668.aspx\n\nコンパイラが戻り値の最適化 (RVO) または名前付き戻り値の最適化 (NRVO)\nを使用できない場合に、移動セマンティクスが役立ちます。\nこのような場合、型が移動コンストラクターを定義していれば、コンパイラはその移動コンストラクターを呼び出します\n\nほぅ。\nNRVOというのはRVOの進化型で戻り値が変数に代入(名前付き)されていても有効になるものらしい。上記の例だと単純なのでNRVOできそうな気もするがコンパイルオプションとかですかね。\nコンパイラが代入の右側を破棄してもよいと判断した場合にムーブコンストラクタが定義されていれば自動的にそっちを使うという暗黙的な仕組みのようだ。\ng++(4.6)ではNRVOされた\n右側を破棄できないようにしてみよう\nRightKun createCanNotMove(const RightKun &src, bool hoge)\n{\n    if(hoge){\n        return src;\n    }\n    return RightKun();\n}\n\n使う\n{\n    RightKun r=createCanNotMove(RightKun(), true);\n}\n\n結果\n0025FE2C:default constructor\n0025FE30:copy constructor: left value operator= 0025FE2C\n0025FE2C:destructor\n0025FE30:destructor\n\n予定通りコピーコンストラクタ呼び出し。問題ない。\n引数をRightKun&&にしてみる\nここでsrcの型をRightKun&&にすればムーブコンストラクタ呼び出しできるのではないか。\nstatic RightKun rightValueArg(RightKun &&src, bool hoge)\n{\n    if(hoge){\n        return src;\n    }\n    return RightKun();\n}\n\n使う\n{\n    RightKun r=rightValueArg(RightKun(), true);\n}\n\n結果\n0025FE2C:default constructor\n0025FE30:copy constructor: left value operator= 0025FE2C\n0025FE2C:destructor\n0025FE30:destructor\n\nところがぎっちょん、コピーの方。何故かというとrightValueArg内ではsrcはただの変数、左辺値として\n扱われるのだ。RightKun&&は実引数の制限だ。\n試しに以下のように呼び出すとエラーになる。\n{\n  RightKun leftvalue;\n  RightKun r=rightValueArg(leftvalue, true);\n}\n\nエラー\nerror C2664: 'rightValueArg' : 1 番目の引数を 'RightKun' から 'RightKun &&' に変換できません。\n\nsrcが右辺値であることを明示する\nプログラマはsrcが右辺値であることを明示できる。\nstatic RightKun moveExplicit(RightKun &&src, bool hoge)\n{\n    if(hoge){\n        return static_cast<RightKun&&>(src);\n    }\n    return RightKun();\n}\n\n使う\n{\n    RightKun r=moveExplicit(RightKun(), true);\n}\n\n結果\n0025FE2B:default constructor\n0025FE2F:move constructor: right value operator= 0025FE2B\n0025FE2B:destructor\n0025FE2F:destructor\n\n意図通りにムーブコンストラクタが呼ばれた。\nで、このキャストをラップするのがstd::moveですよと。\nただし、std::moveした変数をその後で使わないのはプログラマの責任と。\nということで右辺値とムーブコンストラクタのなんたるかがなんとなく分かった。\nムーブコンストラクタを呼ぶかどうかはコンパイラが判断するので\n使うほうは気にしなくても、知らないうちにムーブコンストラクタが呼ばれてパフォーマンス上の恩恵を受けることができるということですな。\n知っていればstd::moveによりムーブコンストラクタの呼び出しを増やせるかもしれない。\nunique_ptrでstd::moveを要求されるのはコピーコンストラクタを無効にしつつ、\nムーブコンストラクタを定義している故と類推できた。\nだいたい分かった結果、\n自分でムーブコンストラクタを定義するクラスを書くことはあまり無さそうな気がした。\nだめな書き方\n最後に右辺値を返す関数を書こうとして最初にはまった、だめなバージョンを書いておく\nRightKun &&moveFail()\n{\n    return RightKun();\n}\n\n使う\n{\n    RightKun r=moveFail();\n}\n")),"\n",u.createElement(t.p,null,"結果\n0025FE07:default constructor\n0025FE07:destructor\n0025FE2D:move constructor: right value operator= 0025FE07\n0025FE2D:destructor"),"\n",u.createElement(t.p,null,"destructor が動いた後のポインタで、ムーブコンストラクタが呼び出される\n大変危険なコードになった。 なんじゃこりゃー。\ngcc でやってみたらわかりやすいエラーメッセージが出た。\n警告: 一時オブジェクトへの参照を返そうとしています [デフォルトで有効]"),"\n",u.createElement(t.p,null,"関数返り値の宣言に&&を使ってはいけないということか"))}var c=function(n){void 0===n&&(n={});const{wrapper:t}=Object.assign({},(0,r.ah)(),n.components);return t?u.createElement(t,n,u.createElement(o,n)):o(n)};e(8678);function s(n){let{data:t,children:e}=n;return u.createElement(u.Fragment,null,u.createElement("h1",null,t.mdx.frontmatter.title),u.createElement(r.Zo,null,e))}function i(n){return u.createElement(s,n,u.createElement(c,n))}},8678:function(n,t,e){e(7294)},1151:function(n,t,e){e.d(t,{Zo:function(){return s},ah:function(){return o}});var r=e(7294);const u=r.createContext({});function o(n){const t=r.useContext(u);return r.useMemo((()=>"function"==typeof n?n(t):{...t,...n}),[t,n])}const c={};function s({components:n,children:t,disableParentContext:e}){let s;return s=e?"function"==typeof n?n({}):n||c:o(n),r.createElement(u.Provider,{value:s},t)}}}]);
//# sourceMappingURL=component---src-templates-post-template-js-content-file-path-home-runner-work-ousttrue-github-io-ousttrue-github-io-content-posts-2013-10-27-rightvalue-md-d139ce67793b059430bc.js.map